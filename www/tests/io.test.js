// Generated by CoffeeScript 1.6.3
/*

  Utils

  Random little snippets to make things easier.
  Default prototype extensions for String, Array, Math... everything

  Add miscellaneous helpers that can be useful in more than one file here, since
  this gets compiled before everything else.

         _____
        /__    \
        ___) E| -_
       \_____  -_  -_
                 -_  -_
                   -_  -_
                     -_ o |
                       -_ /     This is a wrench ok?
*/


(function() {
  var AntlerPoint, Antlers, Bounds, Circle, Color, CubicBezier, CurvePoint, CurveTo, Ellipse, Font, HorizTo, HoverTarget, Line, LineSegment, LineTo, Monsvg, MoveTo, PNG, Path, Point, PointsList, PointsSegment, Polygon, Polyline, Polynomial, Posn, Range, Ray, Rect, RotateTransformation, SETTINGS, SVG, ScaleTransformation, SmoothTo, Test, Text, TextEditable, Transformations, TranslateTransformation, Tspan, VertiTo, allowsHotkeys, async, cleanUpNumber, cloneObject, domToSelector, domToStr, float, int, io, isBezierControlHandle, isDefaultQuarantined, isHandle, isHoverTarget, isOnTopUI, isPointHandle, isSVGElement, isSVGElementInMain, isSwatch, isTextInput, isTransformerHandle, isUtilityWindow, listOfElems, objectValues, oots, pngObject, q, qa, queryElemByUUID, queryElemByZIndex, svgObject, svgObjectFromElems, testData, uuid, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  async = function(fun) {
    return setTimeout(fun, 1);
  };

  q = function(query) {
    return document.querySelector.call(document, query);
  };

  qa = function(query) {
    return document.querySelectorAll.call(document, query);
  };

  uuid = function() {
    var chars, i, id, _i;
    id = [];
    chars = 'abcdefghijklmnopqrstuvwxyz' + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '1234567890';
    for (i = _i = 1; _i <= 20; i = ++_i) {
      id.push(chars.split('')[parseInt(Math.random() * 62, 10)]);
    }
    return id.join('');
  };

  isSVGElement = function(target) {
    return target.namespaceURI === 'http://www.w3.org/2000/svg';
  };

  isSVGElementInMain = function(target) {
    return target.namespaceURI === 'http://www.w3.org/2000/svg' && $(target).closest("#main").length > 0 && target.id !== 'main';
  };

  isPointHandle = function(target) {
    return target.className === 'transform handle point';
  };

  isBezierControlHandle = function(target) {
    return target.className === 'transform handle point bz-ctrl';
  };

  isTransformerHandle = function(target) {
    return target.className.mentions('transform handle');
  };

  isHoverTarget = function(target) {
    var _ref;
    return ((_ref = target.parentNode) != null ? _ref.id : void 0) === 'hover-targets';
  };

  isHandle = function(target) {
    if (target.nodeName.toLowerCase() === 'div') {
      return target.className.mentions('handle');
    }
    return false;
  };

  isTextInput = function(target) {
    return target.nodeName.toLowerCase() === "input" && target.getAttribute("type") === "text";
  };

  isUtilityWindow = function(target) {
    return target.className.mentions("utility-window") || $(target).closest('.utility-window').length > 0;
  };

  isSwatch = function(target) {
    return target.className.mentions("swatch");
  };

  isOnTopUI = function(target) {
    var cl;
    if (typeof target.className === "string") {
      cl = target.className.split(" ");
      if (cl.has("disabled")) {
        return false;
      }
      if (cl.has("tool-button")) {
        return "tb";
      } else if (cl.has("menu")) {
        return "menu";
      } else if (cl.has("menu-item")) {
        return "menu-item";
      } else if (cl.has("menu-dropdown")) {
        return "dui";
      }
    }
    if (target.hasAttribute("buttontext")) {
      return true;
    }
    if (target.nodeName.toLowerCase() === "a") {
      return true;
    }
    if (target.id === "hd-file-loader") {
      return "file-loader";
    } else if (isTextInput(target)) {
      return "text-input";
    } else if (isUtilityWindow(target)) {
      return "utility-window";
    } else if (isSwatch(target)) {
      return "swatch";
    }
    return false;
  };

  allowsHotkeys = function(target) {
    return $(target).closest("[h]").length > 0;
  };

  isDefaultQuarantined = function(target) {
    if (target.hasAttribute("quarantine")) {
      return true;
    } else if ($(target).closest("[quarantine]").length > 0) {
      return true;
    } else {
      return false;
    }
  };

  queryElemByUUID = function(uuid) {
    return ui.queryElement(q('#main [uuid="' + uuid + '"]'));
  };

  queryElemByZIndex = function(zi) {
    return ui.queryElement(dom.$main.children()[zi]);
  };

  Math.lerp = function(a, b, c) {
    return b + a * (c - b);
  };

  String.prototype.toFloat = function() {
    return parseFloat(this.valueOf().match(/[\d\.]/g).join(''));
  };

  String.prototype.mentions = function(phrase) {
    var p, _i, _len;
    if (typeof phrase === 'string') {
      return this.indexOf(phrase) > -1;
    } else if (typeof phrase === 'object') {
      for (_i = 0, _len = phrase.length; _i < _len; _i++) {
        p = phrase[_i];
        if (this.mentions(p)) {
          return true;
        }
      }
      return false;
    }
  };

  SVGAnimatedString.prototype.mentions = function(phrase) {
    return this.baseVal.mentions(phrase);
  };

  String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
  };

  String.prototype.functionNamify = function() {
    return this.split(/[^a-z]/gi).map(function(x) {
      return x.capitalize();
    }).join('');
  };

  String.prototype.strip = function() {
    return this.replace(/(^\s*)|(\s+$)|\n/g, '');
  };

  Number.prototype.px = function() {
    return "" + (this.toPrecision()) + "px";
  };

  Number.prototype.invert = function() {
    return this * -1;
  };

  Number.prototype.within = function(n, other) {
    var d;
    d = this - other;
    return d < n && d > -n;
  };

  Number.prototype.roundIfWithin = function(tolerance) {
    if ((Math.ceil(this) - this) < tolerance) {
      return Math.ceil(this);
    } else if ((this - Math.floor(this)) < tolerance) {
      return Math.floor(this);
    } else {
      return this.valueOf();
    }
  };

  Number.prototype.ensureRealNumber = function() {
    var val;
    val = this.valueOf();
    if (val === Infinity || val === -Infinity || isNaN(val)) {
      return 1;
    }
    return val;
  };

  Number.prototype.toNearest = function(n, ifWithin) {
    var add, inverse, offset, val;
    add = false;
    val = this.valueOf();
    if (val < 0) {
      inverse = true;
      val *= -1;
    }
    offset = val % n;
    if (offset > n / 2) {
      offset = n - offset;
      add = true;
    }
    if ((ifWithin != null) && offset > ifWithin) {
      return val;
    }
    if (offset < n / 2) {
      if (add) {
        val = val + offset;
      } else {
        val = val - offset;
      }
    } else {
      if (add) {
        val = val - (n - offset);
      } else {
        val = val + (n - offset);
      }
    }
    if (inverse) {
      val *= -1;
    }
    return val;
  };

  Array.prototype.remove = function(el) {
    if (el instanceof RegExp) {
      return this.filter(function(a) {
        return !a.match(el);
      });
    } else {
      if (el instanceof Array) {
        return this.filter(function(a) {
          return !el.has(a);
        });
      } else {
        return this.filter(function(a) {
          return el !== a;
        });
      }
    }
  };

  Array.prototype.has = function(el) {
    return this.indexOf(el) > -1;
  };

  Array.prototype.ensure = function(el) {
    if (this.indexOf(el) === -1) {
      return this.push(el);
    }
  };

  Array.prototype.last = function() {
    return this[this.length - 1];
  };

  Array.prototype.sortByZIndex = function() {
    return this.sort(function(a, b) {
      if (a.zIndex() < b.zIndex()) {
        return -1;
      } else {
        return 1;
      }
    });
  };

  Array.prototype.replace = function(r, w) {
    var ind;
    ind = this.indexOf(r);
    if (ind === -1) {
      return this;
    } else {
      return this.slice(0, ind).concat(w instanceof Array ? w : [w]).concat(this.slice(ind + 1));
    }
  };

  Array.prototype.cannibalize = function() {
    this.push(this[0]);
    return this.slice(1);
  };

  Element.prototype.remove = function() {
    if (this.parentElement !== null) {
      return this.parentElement.removeChild(this);
    }
  };

  Element.prototype.removeChildren = function() {
    var _results;
    _results = [];
    while (this.childNodes.length > 0) {
      _results.push(this.childNodes[0].remove());
    }
    return _results;
  };

  Number.prototype.places = function(x) {
    return parseFloat(this.toFixed(x));
  };

  cleanUpNumber = function(n) {
    n = n.roundIfWithin(SETTINGS.MATH.POINT_ROUND_DGAF);
    n = n.places(SETTINGS.MATH.POINT_DECIMAL_PLACES);
    return n;
  };

  int = function(n) {
    return parseInt(n, 10);
  };

  float = function(n) {
    return parseFloat(n);
  };

  oots = Object.prototype.toString;

  Object.prototype.toString = function() {
    var e;
    if (this instanceof $) {
      return "$('" + this.selector + "') object";
    } else {
      try {
        return JSON.stringify(this);
      } catch (_error) {
        e = _error;
        return oots.call(this);
      }
    }
  };

  objectValues = function(obj) {
    var key, val, vals;
    vals = [];
    for (key in obj) {
      if (!__hasProp.call(obj, key)) continue;
      val = obj[key];
      vals.push(val);
    }
    return vals;
  };

  cloneObject = function(obj) {
    var key, newo, val;
    newo = new Object();
    for (key in obj) {
      if (!__hasProp.call(obj, key)) continue;
      val = obj[key];
      newo[key] = val;
    }
    return newo;
  };

  domToStr = function(domelem) {
    return new XMLSerializer.serializeToString(domelem);
  };

  domToSelector = function(domelem) {
    var nn;
    if (domelem == null) {
      return "";
    }
    nn = "" + (domelem.nodeName.toLowerCase());
    if (domelem.id != null) {
      nn += "#" + domelem.id;
    }
    if (domelem.getAttribute("class")) {
      nn += "." + (domelem.getAttribute("class").split(" ").join("."));
    }
    return nn;
  };

  Math.KAPPA = 0.5522847498307936;

  console.il = function(x) {
    return setInterval(function() {
      return console.log(x);
    }, 1000);
  };

  SETTINGS = {
    PRODUCTION: !(/localhost/.test(document.location.host)),
    MEOWSET: {
      AVAILABLE: true,
      ENDPOINT: this.PRODUCTION ? "http://localhost:8000" : "http://meowset.mondrian.io"
    },
    SVG_NAMESPACE: "http://www.w3.org/2000/svg",
    MATH: {
      POINT_DECIMAL_PLACES: 5,
      POINT_ROUND_DGAF: 1e-5
    },
    DOUBLE_CLICK_THRESHOLD: 600
  };

  /*
  
    io
    
    The goal of this is an IO that can take anything that could
    conceivably be SVG and convert it to Monsvg.
  */


  io = {
    parse: function(input, makeNew) {
      var $svg, bounds, parsed, svg, viewbox;
      if (makeNew == null) {
        makeNew = true;
      }
      $svg = this.findSVGRoot(input);
      svg = $svg[0];
      bounds = this.getBounds($svg);
      if (bounds.width == null) {
        bounds.width = 1000;
      }
      if (bounds.height == null) {
        bounds.height = 1000;
      }
      if (makeNew) {
        ui["new"](bounds.width, bounds.height);
      }
      parsed = this.recParse($svg);
      viewbox = svg.getAttribute("viewBox");
      if (viewbox) {
        viewbox = viewbox.split(" ");
        viewbox = new Bounds(viewbox[0], viewbox[1], viewbox[2], viewbox[3]);
      }
      return parsed;
    },
    getBounds: function(input) {
      var $svg, height, svg, viewbox, width;
      $svg = this.findSVGRoot(input);
      svg = $svg[0];
      width = svg.getAttribute("width");
      height = svg.getAttribute("height");
      viewbox = svg.getAttribute("viewBox");
      if (width == null) {
        if (viewbox != null) {
          width = viewbox.split(" ")[2];
        } else {
          console.warn("No width, defaulting to 1000");
          width = 1000;
        }
      }
      if (height == null) {
        if (viewbox != null) {
          height = viewbox.split(" ")[3];
        } else {
          console.warn("No height, defaulting to 1000");
          height = 1000;
        }
      }
      width = parseFloat(width);
      height = parseFloat(height);
      if (isNaN(width)) {
        console.warn("Width is NaN, defaulting to 1000");
        width = 1000;
      }
      if (isNaN(height)) {
        console.warn("Width is NaN, defaulting to 1000");
        height = 1000;
      }
      return new Bounds(0, 0, parseFloat(width), parseFloat(height));
    },
    recParse: function(container) {
      var elem, inside, monsvgs, parsed, parsedChildren, results, _i, _len, _ref;
      results = [];
      _ref = container.children();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (elem.nodeName === "defs") {
          continue;
          inside = this.recParse($(elem));
          results = results.concat(inside);
        } else if (elem.nodeName === "g") {
          parsedChildren = this.recParse($(elem));
          results = results.concat(parsedChildren);
        } else {
          parsed = this.parseElement(elem);
          if (parsed === false) {
            continue;
          }
          if (parsed instanceof Monsvg) {
            results.push(parsed);
          } else if (parsed instanceof Object && (parsed["xlink:href"] != null)) {
            parsed.reference = true;
            results.push(parsed);
          }
        }
      }
      monsvgs = results.filter(function(e) {
        return e instanceof Monsvg;
      });
      return results;
    },
    findSVGRoot: function(input) {
      var $svg;
      if (input instanceof Array) {
        return input[0].$rep.closest("svg");
      } else if (input instanceof $) {
        input = input.filter('svg');
        if (input.is("svg")) {
          return input;
        } else {
          $svg = input.find("svg");
          if ($svg.length === 0) {
            throw new Error("io: No svg node found.");
          } else {
            return $svg[0];
          }
        }
      } else {
        return this.findSVGRoot($(input));
      }
    },
    parseElement: function(elem) {
      var $elem, attr, attrs, classes, data, key, result, transform, type, virgin, virgins;
      classes = {
        'path': Path,
        'text': Text
      };
      virgins = {
        'rect': Rect,
        'ellipse': Ellipse,
        'polygon': Polygon,
        'polyline': Polyline
      };
      if (elem instanceof $) {
        $elem = elem;
        elem = elem[0];
      }
      attrs = elem.attributes;
      transform = null;
      for (key in attrs) {
        if (!__hasProp.call(attrs, key)) continue;
        attr = attrs[key];
        if (attr.name === "transform") {
          transform = attr.value;
        }
      }
      data = this.makeData(elem);
      type = elem.nodeName.toLowerCase();
      if ((classes[type] != null) || (virgins[type] != null)) {
        result = null;
        if (classes[type] != null) {
          result = new classes[elem.nodeName.toLowerCase()](data);
          if (type === "text") {
            result.setContent(elem.textContent);
          }
        } else if (virgins[type] != null) {
          virgin = new virgins[elem.nodeName.toLowerCase()](data);
          result = virgin.convertToPath();
          result.virgin = virgin;
        }
        if (transform && elem.nodeName.toLowerCase() !== "text") {
          result.carryOutTransformations(transform);
          delete result.data.transform;
          result.rep.removeAttribute("transform");
          result.commit();
        }
        return result;
      } else if (type === "use") {
        return false;
      } else {
        return null;
      }
    },
    makeData: function(elem) {
      var attrs, blacklist, blacklistCheck, data, key, val;
      blacklist = ["inkscape", "sodipodi", "uuid"];
      blacklistCheck = function(key) {
        var x, _i, _len;
        for (_i = 0, _len = blacklist.length; _i < _len; _i++) {
          x = blacklist[_i];
          if (key.indexOf(x) > -1) {
            return false;
          }
        }
        return true;
      };
      attrs = elem.attributes;
      data = {};
      for (key in attrs) {
        val = attrs[key];
        key = val.name;
        val = val.value;
        if (key === "") {
          continue;
        }
        if (key === "style" && elem.nodeName !== "text") {
          data = this.applyStyles(data, val);
        } else if ((val != null) && blacklistCheck(key)) {
          if (/^\d+$/.test(val)) {
            val = float(val);
          }
          data[key] = val;
        }
      }
      return data;
    },
    applyStyles: function(data, styles) {
      var blacklist, key, style, val, _i, _len;
      blacklist = ["display", "transform"];
      styles = styles.split(";");
      for (_i = 0, _len = styles.length; _i < _len; _i++) {
        style = styles[_i];
        style = style.split(":");
        key = style[0];
        val = style[1];
        if (blacklist.has(key)) {
          continue;
        }
        data[key] = val;
      }
      return data;
    },
    parseAndAppend: function(input, makeNew) {
      var parsed;
      parsed = this.parse(input, makeNew);
      parsed.map(function(elem) {
        return elem.appendTo('#main');
      });
      ui.refreshAfterZoom();
      return parsed;
    },
    prepareForExport: function() {
      var elem, _i, _len, _ref, _results;
      _ref = ui.elements;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (elem.type === "path") {
          if (elem.virgin != null) {
            elem.virginMode();
          }
        }
        _results.push(typeof elem.cleanUpPoints === "function" ? elem.cleanUpPoints() : void 0);
      }
      return _results;
    },
    cleanUpAfterExport: function() {
      var elem, _i, _len, _ref, _results;
      _ref = ui.elements;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (elem.type === "path") {
          if (elem.virgin != null) {
            _results.push(elem.editMode());
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    makeFile: function() {
      var attr, blacklist, main, _i, _len;
      this.prepareForExport();
      main = new XMLSerializer().serializeToString(dom.main);
      this.cleanUpAfterExport();
      main = main.replace(/>/gi, ">\n");
      blacklist = ["uuid"];
      for (_i = 0, _len = blacklist.length; _i < _len; _i++) {
        attr = blacklist[_i];
        main = main.replace(new RegExp(attr + '\\=\\"\[\\d\\w\]*\\"', 'gi'), '');
      }
      return "<!-- Made in Mondrian.io -->\n" + main;
    },
    makeBase64: function() {
      return btoa(this.makeFile());
    },
    makeBase64URI: function() {
      return "data:image/svg+xml;charset=utf-8;base64," + (this.makeBase64());
    },
    makePNGURI: function(elements, maxDimen) {
      var bounds, context, elem, s, sandbox, _i, _len;
      if (elements == null) {
        elements = ui.elements;
      }
      if (maxDimen == null) {
        maxDimen = void 0;
      }
      sandbox = dom.pngSandbox;
      context = sandbox.getContext("2d");
      if (elements.length) {
        bounds = this.getBounds(elements);
      } else {
        bounds = this.getBounds(dom.main);
      }
      sandbox.setAttribute("width", bounds.width);
      sandbox.setAttribute("height", bounds.height);
      if (maxDimen != null) {
        s = Math.max(context.canvas.width, context.canvas.height) / maxDimen;
        context.canvas.width /= s;
        context.canvas.height /= s;
        context.scale(1 / s, 1 / s);
      }
      if (typeof elements === "string") {
        elements = this.parse(elements, false);
      }
      for (_i = 0, _len = elements.length; _i < _len; _i++) {
        elem = elements[_i];
        elem.drawToCanvas(context);
      }
      return sandbox.toDataURL("png");
    }
  };

  /*
  
    SVG representation class/API
  */


  SVG = (function() {
    function SVG(contents) {
      this._ensureDoc(contents);
      if (this._svgRoot == null) {
        this._svgRoot = this.doc.querySelector('svg');
      }
      if (this._svgRoot == null) {
        throw new Error('No svg element found');
      }
      this._buildMetadata();
      if (this.elements == null) {
        this._buildElements();
      }
    }

    SVG.prototype._ensureDoc = function(contents) {
      var _this = this;
      if (typeof contents === 'string') {
        return this.doc = new DOMParser().parseFromString(contents, this.MIMETYPE);
      } else if (contents.documentURI != null) {
        return this.doc = contents;
      } else if (contents instanceof Array) {
        this.elements = contents;
        this.doc = document.implementation.createDocument();
        this.doc.removeChild(this.doc.childNodes[0]);
        this._svgRoot = this.doc.createElementNS(SETTINGS.SVG_NAMESPACE, "svg");
        this.doc.appendChild(this._svgRoot);
        this.elements.forEach(function(elem) {
          return _this._svgRoot.appendChild(elem.rep);
        });
        return this._deriveBoundsFromElements();
      } else {
        throw new Error('Bad input');
      }
    };

    SVG.prototype._buildMetadata = function() {
      this.metadata = {};
      this.metadata.width = parseInt(this._svgAttr('width', 10));
      this.metadata.height = parseInt(this._svgAttr('height', 10));
      if (this._bounds == null) {
        return this._bounds = new Bounds(0, 0, this.metadata.width, this.metadata.height);
      }
    };

    SVG.prototype._buildElements = function() {
      return this.elements = io.parse(this.toString(), false);
    };

    SVG.prototype._deriveBoundsFromElements = function() {
      var bounds, height, width;
      bounds = this.elements.map(function(elem) {
        return elem.bounds();
      });
      this._bounds = new Bounds(bounds);
      width = this._bounds.width + this._bounds.x;
      height = this._bounds.height + this._bounds.y;
      this._svgRoot.setAttribute('width', width);
      return this._svgRoot.setAttribute('height', height);
    };

    SVG.prototype._svgAttr = function(attr) {
      return this._svgRoot.getAttribute(attr);
    };

    SVG.prototype.toString = function() {
      return new XMLSerializer().serializeToString(this.doc);
    };

    SVG.prototype.toBase64 = function() {
      return "data:" + this.MIMETYPE + ";charset=" + this.CHARSET + ";base64," + (this.toString());
    };

    SVG.prototype.appendTo = function(selector) {
      return q(selector).appendChild(this._svgRoot);
    };

    SVG.prototype.MIMETYPE = 'image/svg+xml';

    SVG.prototype.CHARSET = 'utf-8';

    return SVG;

  })();

  /*
  
    Pseudo-PNG class that just draws to
    an off-screen canvas and exports that
  */


  PNG = (function() {
    function PNG(elements) {
      this._parseInput(elements);
      this._buildRep();
    }

    PNG.prototype.maxDimension = function(dimen) {
      var bounds, boundsScale, context, scale;
      this.clear();
      context = this.context();
      scale = Math.max(this.width, this.height) / dimen;
      this.setDimensions(this.width / scale, this.height / scale);
      bounds = this.svg._bounds;
      debugger;
      boundsScale = Math.max(bounds.width, bounds.height) / dimen;
      context.scale(1 / boundsScale, 1 / boundsScale);
      return this;
    };

    PNG.prototype["export"] = function() {
      this._draw();
      return this.rep.toDataURL('png');
    };

    PNG.prototype.destroy = function() {
      this.elements = null;
      this.rep.remove();
      this.rep = null;
      return this;
    };

    PNG.prototype.clear = function() {
      return this.context().clearRect(0, 0, this.width, this.height);
    };

    PNG._setScale = function(x, y) {
      this.context().scale(x / this._contextScaleX, y / this._contextScaleY);
      this._contextScaleX = x;
      return this._contextScaleY = y;
    };

    PNG.prototype._draw = function() {
      var context,
        _this = this;
      context = this.context();
      return this.elements.forEach(function(element) {
        return element.drawToCanvas(context);
      });
    };

    PNG.prototype._parseInput = function(elements) {
      if (typeof elements === 'string') {
        this.svg = new SVG(elements);
        return this.elements = this.svg.elements;
      } else if (elements instanceof SVG) {
        this.svg = elements;
        return this.elements = this.svg.elements;
      } else if (elements instanceof Array) {
        this.elements = elements;
        return this.svg = new SVG(this.elements);
      }
    };

    PNG.prototype._buildRep = function() {
      this.rep = document.createElement('canvas');
      this.rep.classList.add('offscreen-throwaway');
      this.setDimensions(this.svg.metadata.width, this.svg.metadata.height);
      this._contextScaleX = 1.0;
      this._contextScaleY = 1.0;
      return q('body').appendChild(this.rep);
    };

    PNG.prototype.attr = function(attr, val) {
      return this.rep.setAttribute(attr, val);
    };

    PNG.prototype.setDimensions = function(width, height) {
      this.width = width;
      this.height = height;
      this.attr('width', this.width);
      return this.attr('height', this.height);
    };

    PNG.prototype.context = function() {
      return this._context != null ? this._context : this._context = this.rep.getContext('2d');
    };

    return PNG;

  })();

  /*
  
    Management class for fontfaces
  */


  Font = (function() {
    function Font(name) {
      this.name = name;
    }

    Font.prototype.toListItem = function() {
      return $("<div class=\"dropdown-item\" style=\"font-family: '" + this.name + "'\">\n  " + this.name + "\n</div>");
    };

    return Font;

  })();

  /*
  
    Color
  
    A nice lil' class for representing and manipulating colors.
  */


  Color = (function() {
    function Color(r, g, b, a) {
      var rgb, vals;
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a != null ? a : 1.0;
      if (this.r instanceof Color) {
        return this.r;
      }
      if (this.r === null) {
        this.hex = "none";
      } else if (this.r === "none") {
        this.hex = "none";
        this.r = null;
        this.g = null;
        this.b = null;
      } else {
        if (typeof this.r === "string") {
          if (this.r.charAt(0) === "#" || this.r.length === 6) {
            this.hex = this.r.toUpperCase().replace("#", "");
            rgb = this.hexToRGB(this.hex);
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
          } else if (this.r.match(/rgba?\(.*\)/gi) != null) {
            vals = this.r.match(/[\d\.]+/gi);
            this.r = vals[0];
            this.g = vals[1];
            this.b = vals[2];
            if (vals[3] != null) {
              this.a = parseFloat(vals[3]);
            }
            this.hex = this.rgbToHex(this.r, this.g, this.b);
          }
        } else {
          if ((this.g == null) && (this.b == null)) {
            this.g = this.r;
            this.b = this.r;
          }
          this.hex = this.rgbToHex(this.r, this.g, this.b);
        }
        this.r = Math.min(this.r, 255);
        this.g = Math.min(this.g, 255);
        this.b = Math.min(this.b, 255);
        this.r = Math.max(this.r, 0);
        this.g = Math.max(this.g, 0);
        this.b = Math.max(this.b, 0);
      }
      if (isNaN(this.r || isNaN(this.g || isNaN(this.b)))) {
        if (isNaN(this.r)) {
          this.r = 0;
        }
        if (isNaN(this.g)) {
          this.g = 0;
        }
        if (isNaN(this.b)) {
          this.b = 0;
        }
        debugger;
        this.updateHex();
      }
    }

    Color.prototype.clone = function() {
      return new Color(this.r, this.g, this.b);
    };

    Color.prototype.absorb = function(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      this.a = color.a;
      this.hex = color.hex;
      if (typeof this.refresh === "function") {
        this.refresh();
      }
      return this;
    };

    Color.prototype.min = function() {
      return [this.r, this.g, this.b].sort(function(a, b) {
        return a - b;
      })[0];
    };

    Color.prototype.mid = function() {
      return [this.r, this.g, this.b].sort(function(a, b) {
        return a - b;
      })[1];
    };

    Color.prototype.max = function() {
      return [this.r, this.g, this.b].sort(function(a, b) {
        return a - b;
      })[2];
    };

    Color.prototype.midpoint = function() {
      return this.max() / 2;
    };

    Color.prototype.valToHex = function(val) {
      var chars;
      chars = '0123456789ABCDEF';
      return chars.charAt((val - val % 16) / 16) + chars.charAt(val % 16);
    };

    Color.prototype.hexToVal = function(hex) {
      var chars;
      chars = '0123456789ABCDEF';
      return chars.indexOf(hex.charAt(0)) * 16 + chars.indexOf(hex.charAt(1));
    };

    Color.prototype.rgbToHex = function(r, g, b) {
      return "" + (this.valToHex(r)) + (this.valToHex(g)) + (this.valToHex(b));
    };

    Color.prototype.hexToRGB = function(hex) {
      var b, g, r;
      r = this.hexToVal(hex.substring(0, 2));
      g = this.hexToVal(hex.substring(2, 4));
      b = this.hexToVal(hex.substring(4, 6));
      return {
        r: r,
        g: g,
        b: b
      };
    };

    Color.prototype.recalculateHex = function() {
      return this.hex = this.rgbToHex(this.r, this.g, this.b);
    };

    Color.prototype.darken = function(amt) {
      var macro;
      macro = function(val) {
        return val / amt;
      };
      return new Color(macro(this.r), macro(this.g), macro(this.b));
    };

    Color.prototype.lightness = function() {
      return ((this.min() + this.max()) / 2) / 255;
    };

    Color.prototype.saturation = function() {
      var d, max, min, sat;
      max = this.max();
      min = this.min();
      d = max - min;
      sat = this.lightness() >= 0.5 ? d / (510 - max - min) : d / (max + min);
      if (isNaN(sat)) {
        sat = 1.0;
      }
      return sat;
    };

    Color.prototype.desaturate = function(amt) {
      var mpt;
      if (amt == null) {
        amt = 1.0;
      }
      mpt = this.midpoint();
      this.r -= (this.r - mpt) * amt;
      this.g -= (this.g - mpt) * amt;
      this.b -= (this.b - mpt) * amt;
      this.hex = this.rgbToHex(this.r, this.g, this.b);
      return this;
    };

    Color.prototype.lighten = function(amt) {
      if (amt == null) {
        amt = 0.5;
      }
      amt *= 255;
      this.r = Math.min(255, this.r + amt);
      this.g = Math.min(255, this.g + amt);
      this.b = Math.min(255, this.b + amt);
      this.hex = this.rgbToHex(this.r, this.g, this.b);
      return this;
    };

    Color.prototype.toRGBString = function() {
      if (this.r === null) {
        return "none";
      } else {
        return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.a + ")";
      }
    };

    Color.prototype.toHexString = function() {
      return "#" + this.hex;
    };

    Color.prototype.toString = function() {
      this.removeNaNs();
      return this.toRGBString();
    };

    Color.prototype.removeNaNs = function() {
      if (isNaN(this.r)) {
        this.r = 0;
      }
      if (isNaN(this.g)) {
        this.g = 0;
      }
      if (isNaN(this.b)) {
        return this.b = 0;
      }
    };

    Color.prototype.equal = function(c) {
      return this.toHexString() === c.toHexString();
    };

    Color.prototype.updateHex = function() {
      return this.hex = this.rgbToHex(this.r, this.g, this.b);
    };

    return Color;

  })();

  window.Color = Color;

  Transformations = (function() {
    function Transformations(owner, transformations) {
      var transform,
        _this = this;
      this.owner = owner;
      this.transformations = transformations;
      transform = this.owner.rep.getAttribute("transform");
      this.transformations.map(function(t) {
        return t.family = _this;
      });
      if (transform != null) {
        this.parseExisting(transform);
      }
    }

    Transformations.prototype.commit = function() {
      return this.owner.data.transform = this.toAttr();
    };

    Transformations.prototype.toAttr = function() {
      return this.transformations.map(function(t) {
        return t.toAttr();
      }).join(" ");
    };

    Transformations.prototype.toCSS = function() {
      return this.transformations.map(function(t) {
        return t.toCSS();
      }).join(" ");
    };

    Transformations.prototype.get = function(key) {
      var f;
      f = this.transformations.filter(function(t) {
        return t.key === key;
      });
      if (f.length > 0) {
        return f[0];
      }
    };

    Transformations.prototype.parseExisting = function(transform) {
      var alreadyDefined, keyword, newlyDefined, op, operations, _i, _len, _results;
      operations = transform.match(/\w+\([^\)]*\)/g);
      _results = [];
      for (_i = 0, _len = operations.length; _i < _len; _i++) {
        op = operations[_i];
        keyword = op.match(/^\w+/g)[0];
        alreadyDefined = this.get(keyword);
        if (alreadyDefined != null) {
          _results.push(alreadyDefined.parse(op));
        } else {
          newlyDefined = new {
            rotate: RotateTransformation,
            scale: ScaleTransformation
          }[keyword]().parse(op);
          newlyDefined.family = this;
          _results.push(this.transformations.push(newlyDefined));
        }
      }
      return _results;
    };

    Transformations.prototype.applyAsCSS = function(rep) {
      var og, tr;
      og = "-" + this.owner.origin.x + " -" + this.owner.origin.y;
      tr = this.toCSS();
      rep.style.transformOrigin = og;
      rep.style.webkitTransformOrigin = og;
      rep.style.mozTransformOrigin = og;
      rep.style.transform = tr;
      rep.style.webkitTransformOrigin = og;
      rep.style.webkitTransform = tr;
      rep.style.mozTransformOrigin = og;
      return rep.style.mozTransform = tr;
    };

    return Transformations;

  })();

  RotateTransformation = (function() {
    function RotateTransformation(deg, family) {
      this.deg = deg;
      this.family = family;
    }

    RotateTransformation.prototype.key = "rotate";

    RotateTransformation.prototype.toAttr = function() {
      return "rotate(" + (this.deg.places(3)) + " " + (this.family.owner.center().x.places(3)) + " " + (this.family.owner.center().y.places(3)) + ")";
    };

    RotateTransformation.prototype.toCSS = function() {
      return "rotate(" + (this.deg.places(3)) + "deg)";
    };

    RotateTransformation.prototype.rotate = function(a) {
      this.deg += a;
      this.deg %= 360;
      return this;
    };

    RotateTransformation.prototype.parse = function(op) {
      var x, y, _ref;
      return _ref = op.match(/[\d\.]+/g).map(parseFloat), this.deg = _ref[0], x = _ref[1], y = _ref[2], _ref;
    };

    return RotateTransformation;

  })();

  ScaleTransformation = (function() {
    function ScaleTransformation(x, y) {
      this.x = x != null ? x : 1;
      this.y = y != null ? y : 1;
    }

    ScaleTransformation.prototype.key = "scale";

    ScaleTransformation.prototype.toAttr = function() {
      return "scale(" + this.x + " " + this.y + ")";
    };

    ScaleTransformation.prototype.toCSS = function() {
      return "scale(" + this.x + ", " + this.y + ")";
    };

    ScaleTransformation.prototype.parse = function(op) {
      var _ref;
      return _ref = op.match(/[\d\.]+/g).map(parseFloat), this.x = _ref[0], this.y = _ref[1], _ref;
    };

    ScaleTransformation.prototype.scale = function(x, y) {
      if (x == null) {
        x = 1;
      }
      if (y == null) {
        y = 1;
      }
      this.x *= x;
      return this.y *= y;
    };

    return ScaleTransformation;

  })();

  TranslateTransformation = (function() {
    function TranslateTransformation(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 1;
    }

    TranslateTransformation.prototype.key = "translate";

    TranslateTransformation.prototype.toAttr = function() {
      return "translate(" + this.x + " " + this.y + ")";
    };

    TranslateTransformation.prototype.toCSS = function() {
      return "translate(" + this.x + "px, " + this.y + "px)";
    };

    TranslateTransformation.prototype.parse = function(op) {
      var _ref;
      return _ref = op.match(/[\-\d\.]+/g).map(parseFloat), this.x = _ref[0], this.y = _ref[1], _ref;
    };

    TranslateTransformation.prototype.nudge = function(x, y) {
      console.log(x, y);
      this.x += x;
      return this.y -= y;
    };

    return TranslateTransformation;

  })();

  /*
  
    Posn
  
      •
        (x, y)
  
  
    Lowest-level geometry class.
  
    Consists of x, y coordinates. Provides methods for manipulating or representing 
    the point in two-dimensional space.
  
    Superclass: Point
  */


  Posn = (function() {
    function Posn(x, y, zoomLevel) {
      var split;
      this.x = x;
      this.y = y;
      this.zoomLevel = zoomLevel != null ? zoomLevel : 1.0;
      if (this.x instanceof Object) {
        if ((this.x.clientX != null) && (this.x.clientY != null)) {
          this.y = this.x.clientY;
          this.x = this.x.clientX;
        } else if ((this.x.left != null) && (this.x.top != null)) {
          this.y = this.x.top;
          this.x = this.x.left;
        } else if ((this.x.x != null) && (this.x.y != null)) {
          this.y = this.x.y;
          this.x = this.x.x;
        }
      } else if ((typeof this.x === "string") && (this.x.mentions(","))) {
        split = this.x.split(",").map(parseFloat);
        x = split[0];
        y = split[1];
        this.x = x;
        this.y = y;
      }
      this;
    }

    Posn.prototype.cleanUp = function() {
      return;
      this.x = cleanUpNumber(this.x);
      return this.y = cleanUpNumber(this.y);
    };

    Posn.prototype.zoomed = function(level) {
      if (level == null) {
        level = ui.canvas.zoom;
      }
      if (this.zoomLevel === level) {
        return this;
      }
      this.unzoomed();
      this.alterValues(function(val) {
        return val *= level;
      });
      this.zoomLevel = level;
      return this;
    };

    Posn.prototype.unzoomed = function() {
      var _this = this;
      if (this.zoomLevel === 1.0) {
        return;
      }
      this.alterValues(function(val) {
        return val /= _this.zoomLevel;
      });
      this.zoomLevel = 1.0;
      return this;
    };

    Posn.prototype.setZoom = function(zoomLevel) {
      this.zoomLevel = zoomLevel;
      this.x /= this.zoomLevel;
      this.y /= this.zoomLevel;
      return this;
    };

    Posn.prototype.zoomedc = function() {
      return this.clone().zoomed();
    };

    Posn.prototype.unzoomedc = function() {
      return this.clone.unzoomed();
    };

    Posn.prototype.alterValues = function(fun) {
      var a, _i, _len, _ref;
      _ref = ["x", "y", "x2", "y2", "x3", "y3"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        this[a] = this[a] != null ? fun(this[a]) : this[a];
      }
      return this;
    };

    Posn.prototype.toString = function() {
      return "" + this.x + "," + this.y;
    };

    Posn.prototype.toConstructorString = function() {
      return "new Posn(" + this.x + "," + this.y + ")";
    };

    Posn.prototype.nudge = function(x, y) {
      this.x += x;
      this.y -= y;
      return this;
    };

    Posn.prototype.lerp = function(b, factor) {
      return new Posn(this.x + (b.x - this.x) * factor, this.y + (b.y - this.y) * factor);
    };

    Posn.prototype.gte = function(p) {
      return this.x >= p.x && this.y >= p.y;
    };

    Posn.prototype.lte = function(p) {
      return this.x <= p.x && this.y <= p.y;
    };

    Posn.prototype.directionRelativeTo = function(p) {
      return "" + (this.y < p.y ? "t" : (this.y > p.y ? "b" : "")) + (this.x < p.x ? "l" : (this.x > p.x ? "r" : ""));
    };

    Posn.prototype.squareUpAgainst = function(p) {
      var direction, xDiff, yDiff;
      xDiff = Math.abs(this.x - p.x);
      yDiff = Math.abs(this.y - p.y);
      direction = this.directionRelativeTo(p);
      if ((xDiff === 0) && (yDiff === 0)) {
        return p;
      }
      switch (direction) {
        case "tl":
          if (xDiff < yDiff) {
            this.nudge(xDiff - yDiff, 0);
          } else if (yDiff < xDiff) {
            this.nudge(0, xDiff - yDiff, 0);
          }
          break;
        case "tr":
          if (xDiff < yDiff) {
            this.nudge(yDiff - xDiff, 0);
          } else if (yDiff < xDiff) {
            this.nudge(0, xDiff - yDiff);
          }
          break;
        case "br":
          if (xDiff < yDiff) {
            this.nudge(yDiff - xDiff, 0);
          } else if (yDiff < xDiff) {
            this.nudge(0, yDiff - xDiff);
          }
          break;
        case "bl":
          if (xDiff < yDiff) {
            this.nudge(xDiff - yDiff, 0);
          } else if (yDiff < xDiff) {
            this.nudge(0, yDiff - xDiff);
          }
          break;
        case "t":
        case "b":
          this.nudge(yDiff, 0);
          break;
        case "r":
        case "l":
          this.nudge(0, xDiff);
      }
      return this;
    };

    Posn.prototype.equal = function(p) {
      return this.x === p.x && this.y === p.y;
    };

    Posn.prototype.min = function(p) {
      return new Posn(Math.min(this.x, p.x), Math.min(this.y, p.y));
    };

    Posn.prototype.max = function(p) {
      return new Posn(Math.max(this.x, p.x), Math.max(this.y, p.y));
    };

    Posn.prototype.angle360 = function(base) {
      var a;
      a = 90 - new LineSegment(base, this).angle;
      return a + (this.x < base.x ? 180 : 0);
    };

    Posn.prototype.rotate = function(angle, origin) {
      var x, y;
      if (origin == null) {
        origin = new Posn(0, 0);
      }
      if (origin.equal(this)) {
        return this;
      }
      angle *= Math.PI / 180;
      this.x -= origin.x;
      this.y -= origin.y;
      x = (this.x * (Math.cos(angle))) - (this.y * Math.sin(angle));
      y = (this.x * (Math.sin(angle))) + (this.y * Math.cos(angle));
      this.x = x + origin.x;
      this.y = y + origin.y;
      return this;
    };

    Posn.prototype.scale = function(x, y, origin) {
      if (origin == null) {
        origin = new Posn(0, 0);
      }
      this.x += (this.x - origin.x) * (x - 1);
      this.y += (this.y - origin.y) * (y - 1);
      return this;
    };

    Posn.prototype.copy = function(p) {
      this.x = p.x;
      return this.y = p.y;
    };

    Posn.prototype.clone = function() {
      return new Posn(this.x, this.y, this.zoomLevel);
    };

    Posn.prototype.snap = function(to, threshold) {
      var perpLine;
      if (threshold == null) {
        threshold = Math.INFINITY;
      }
      perpLine = this.verti(10000);
      perpLine.rotate(to.angle360() + 90, this);
      return perpLine.intersection(to);
    };

    Posn.prototype.reflect = function(posn) {
      /*
      
        Reflect the point over an x and/or y axis
      
        I/P:
          posn: Posn
      */

      var x, y;
      x = posn.x;
      y = posn.y;
      return new Posn(x + (x - this.x), y + (y - this.y));
    };

    Posn.prototype.distanceFrom = function(p) {
      return new LineSegment(this, p).length;
    };

    Posn.prototype.perpendicularDistanceFrom = function(ls) {
      var inter, len, ray;
      ray = this.verti(1e5);
      ray.rotate(ls.angle360() + 90, this);
      inter = ray.intersection(ls);
      if (inter != null) {
        ls = new LineSegment(this, inter);
        len = ls.length;
        return [len, inter, ls];
      } else {
        return null;
      }
    };

    Posn.prototype.multiplyBy = function(s) {
      var np;
      switch (typeof s) {
        case 'number':
          np = this.clone();
          np.x *= s;
          np.y *= s;
          return np;
        case 'object':
          np = this.clone();
          np.x *= s.x;
          np.y *= s.y;
          return np;
      }
    };

    Posn.prototype.multiplyByMutable = function(s) {
      this.x *= s;
      this.y *= s;
      if (this.x2 != null) {
        this.x2 *= s;
        this.y2 *= s;
      }
      if (this.x3 != null) {
        this.x3 *= s;
        return this.y3 *= s;
      }
    };

    Posn.prototype.add = function(s) {
      switch (typeof s) {
        case 'number':
          return new Posn(this.x + s, this.y + s);
        case 'object':
          return new Posn(this.x + s.x, this.y + s.y);
      }
    };

    Posn.prototype.subtract = function(s) {
      switch (typeof s) {
        case 'number':
          return new Posn(this.x - s, this.y - s);
        case 'object':
          return new Posn(this.x - s.x, this.y - s.y);
      }
    };

    Posn.prototype.setPrec = function(prec) {
      this.prec = prec;
    };

    Posn.prototype.setSucc = function(succ) {
      this.succ = succ;
    };

    /*
        I love you artur
        hackerkate nows the sick code
    */


    Posn.prototype.inRanges = function(xr, yr) {
      return xr.contains(this.x && yr.contains(this.y));
    };

    Posn.prototype.inRangesInclusive = function(xr, yr) {
      return xr.containsInclusive(this.x) && yr.containsInclusive(this.y);
    };

    Posn.prototype.verti = function(ln) {
      return new LineSegment(this.clone().nudge(0, -ln), this.clone().nudge(0, ln));
    };

    Posn.prototype.insideOf = function(shape) {
      var counter, ray;
      if (shape instanceof Polygon || shape instanceof Path) {
        ray = new LineSegment(this, new Posn(this.x + 1e+20, this.y));
        counter = 0;
        shape.lineSegments().map(function(a) {
          var inter;
          inter = a.intersection(ray);
          if (inter instanceof Posn) {
            return ++counter;
          } else if (inter instanceof Array) {
            return counter += inter.length;
          }
        });
        return counter % 2 === 1;
      }
      if (shape instanceof Rect) {
        return shape.contains(this);
      }
    };

    Posn.prototype.dot = function(v) {
      return this.x * v.x + this.y * v.y;
    };

    Posn.prototype.within = function(tolerance, posn) {
      return Math.abs(this.x - posn.x) < tolerance && Math.abs(this.y - posn.y) < tolerance;
    };

    Posn.prototype.parseInt = function() {
      this.x = parseInt(this.x, 10);
      return this.y = parseInt(this.y, 10);
    };

    return Posn;

  })();

  /*
  
    Point
  
  
  
       o -----------
      /
     /
    /
  
    Tangible body for posn.
    Stored in PointsList for every shape.
    Comes in many flavors for a Path:
      MoveTo
      LineTo
      HorizTo
      VertiTo
      CurvePoint
        CurveTo
        SmoothTo
  
    This is the most heavily sub-classed class, even heavier than Monsvg.
    It's also the most heavily used, since all shapes are made of many of these.
  
    Needless to say, this is a very important class.
    Its efficiency basically decides the entire application's speed.
    (Not sure it's as good as it could be right now)
  */


  Point = (function(_super) {
    __extends(Point, _super);

    function Point(x, y, owner) {
      var p, prec;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.constructArgs = arguments;
      if ((this.x == null) && (this.y == null)) {
        return;
      }
      if (this.x instanceof Posn) {
        this.owner = this.y;
        this.y = this.x.y;
        this.x = this.x.x;
      } else if (this.x instanceof Object) {
        this.owner = this.y;
        if (this.x.clientX != null) {
          this.y = this.x.clientY;
          this.x = this.x.clientX;
        } else if ((this.x.x != null) && (this.x.y != null)) {
          this.y = this.x.y;
          this.x = this.x.x;
        }
      } else if (typeof this.x === "string") {
        if (this.owner != null) {
          prec = this.owner;
        }
        if (this.y != null) {
          this.owner = this.y;
        }
        p = this.fromString(this.x, prec);
        return p;
      }
      if (isNaN(this.x)) {
        debugger;
      }
      if (isNaN(this.y)) {
        debugger;
      }
      this.makeAntlers();
      Point.__super__.constructor.call(this, this.x, this.y);
    }

    Point.prototype.fromString = function(point, prec) {
      var classes, clen, constructed, coords, elen, i, key, lengths, matched, pairs, patterns, points, relative, set, sliceAt, val, values, _i, _ref;
      patterns = {
        moveTo: /M[^A-Za-z]+/gi,
        lineTo: /L[^A-Za-z]+/gi,
        curveTo: /C[^A-Za-z]+/gi,
        smoothTo: /S[^A-Za-z]+/gi,
        horizTo: /H[^A-Za-z]+/gi,
        vertiTo: /V[^A-Za-z]+/gi
      };
      classes = {
        moveTo: MoveTo,
        lineTo: LineTo,
        curveTo: CurveTo,
        smoothTo: SmoothTo,
        horizTo: HorizTo,
        vertiTo: VertiTo
      };
      lengths = {
        moveTo: 2,
        lineTo: 2,
        curveTo: 6,
        smoothTo: 4,
        horizTo: 1,
        vertiTo: 1
      };
      pairs = /[-+]?\d*\.?\d*(e\-)?\d*/g;
      points = [];
      for (key in patterns) {
        val = patterns[key];
        matched = point.match(val);
        if (matched !== null) {
          coords = (point.match(pairs)).filter(function(p) {
            return p.length > 0;
          }).map(parseFloat);
          relative = point.substring(0, 1).match(/[mlcshv]/) !== null;
          clen = coords.length;
          elen = lengths[key];
          if (clen % elen === 0) {
            sliceAt = 0;
            for (i = _i = 0, _ref = (clen / elen) - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
              set = coords.slice(sliceAt, sliceAt + elen);
              if (i > 0) {
                if (key === "moveTo") {
                  key = "lineTo";
                }
              }
              values = [null].concat(set);
              values.push(this.owner);
              values.push(prec);
              values.push(relative);
              if (values.join(' ').mentions("NaN")) {
                debugger;
              }
              constructed = new (Function.prototype.bind.apply(classes[key], values));
              points.push(constructed);
              sliceAt += elen;
            }
          } else {
            throw new Error("Wrong amount of coordinates: " + point + ". Expected " + elen + " and got " + clen + ".");
          }
          break;
        }
      }
      if (points.length === 0) {
        throw new Error("Unreadable path value: " + point);
      }
      if (points.length === 1) {
        return points[0];
      } else {
        return points;
      }
    };

    Point.prototype.select = function() {
      this.show();
      this.showHandles();
      this.antlers.refresh();
      this.baseHandle.setAttribute('selected', '');
      return this;
    };

    Point.prototype.deselect = function() {
      this.baseHandle.removeAttribute('selected');
      if (typeof this.hideHandles === "function") {
        this.hideHandles();
      }
      this.hide();
      return this;
    };

    Point.prototype.draw = function() {
      var _ref;
      this.$baseHandle = $('<div class="transform handle point"></div>');
      this.baseHandle = this.$baseHandle[0];
      if (this.at === void 0) {
        if (!(this instanceof AntlerPoint)) {
          debugger;
        }
      }
      this.baseHandle.setAttribute('at', this.at);
      if (this.owner != null) {
        this.baseHandle.setAttribute('owner', this.owner.metadata.uuid);
      }
      this.updateHandle(this.baseHandle, this.x, this.y);
      if ((_ref = dom.ui) != null) {
        _ref.appendChild(this.baseHandle);
      }
      return this;
    };

    Point.prototype.makeAntlers = function() {
      var p2, p3;
      if (this.succ != null) {
        p2 = this.succ.p2 != null ? this.succ.p2() : void 0;
      } else {
        p2 = null;
      }
      p3 = this.p3 != null ? this.p3() : null;
      this.antlers = new Antlers(this, p3, p2);
      return this;
    };

    Point.prototype.showHandles = function() {
      return this.antlers.show();
    };

    Point.prototype.hideHandles = function() {
      return this.antlers.hide();
    };

    Point.prototype.absoluteCached = void 0;

    Point.prototype.prec = null;

    Point.prototype.succ = null;

    Point.prototype.actionHint = function() {
      return this.baseHandle.setAttribute('action', '');
    };

    Point.prototype.hideActionHint = function() {
      return this.baseHandle.removeAttribute('action');
    };

    Point.prototype.updateHandle = function(handle, x, y) {
      if (handle == null) {
        handle = this.baseHandle;
      }
      if (x == null) {
        x = this.x;
      }
      if (y == null) {
        y = this.y;
      }
      if (handle === void 0) {
        return;
      }
      handle.style.left = x * ui.canvas.zoom;
      handle.style.top = y * ui.canvas.zoom;
      return this;
    };

    Point.prototype.inheritPosition = function(from) {
      this.at = from.at;
      this.prec = from.prec;
      this.succ = from.succ;
      this.prec.succ = this;
      this.succ.prec = this;
      this.owner = from.owner;
      if (from.baseHandle != null) {
        this.baseHandle = from.baseHandle;
      }
      return this;
    };

    Point.prototype.nudge = function(x, y, checkForFirstOrLast) {
      var old, _ref;
      if (checkForFirstOrLast == null) {
        checkForFirstOrLast = true;
      }
      old = this.clone();
      Point.__super__.nudge.call(this, x, y);
      if ((_ref = this.antlers) != null) {
        _ref.nudge(x, y);
      }
      this.updateHandle();
      if (this.owner.type === 'path') {
        if (checkForFirstOrLast && this.owner.points.closed) {
          if ((this === this.owner.points.first) && this.owner.points.last.equal(old)) {
            return this.owner.points.last.nudge(x, y, false);
          } else if ((this === this.owner.points.last) && this.owner.points.first.equal(old)) {
            return this.owner.points.first.nudge(x, y, false);
          }
        }
      }
    };

    Point.prototype.rotate = function(a, origin) {
      var _ref;
      Point.__super__.rotate.call(this, a, origin);
      if ((_ref = this.antlers) != null) {
        _ref.rotate(a, origin);
      }
      return this.updateHandle();
    };

    Point.prototype.scale = function(x, y, origin, angle) {
      var _ref;
      Point.__super__.scale.call(this, x, y, origin, angle);
      if ((_ref = this.antlers) != null) {
        _ref.scale(x, y, origin, angle);
      }
      this.updateHandle();
      return this;
    };

    Point.prototype.replaceWith = function(point) {
      return this.owner.points.replace(this, point);
    };

    Point.prototype.toPosn = function() {
      return new Posn(this.x, this.y);
    };

    Point.prototype.toLineSegment = function() {
      return new LineSegment(this.prec, this);
    };

    /*
     
     Visibility functions for the UI
    */


    Point.prototype.show = function() {
      if (this.baseHandle == null) {
        return;
      }
      if (!this.baseHandle) {
        this.draw();
      }
      this.baseHandle.style.display = 'block';
      return this.baseHandle.style.opacity = 1;
    };

    Point.prototype.hide = function(force) {
      if (force == null) {
        force = false;
      }
      if (this.baseHandle == null) {
        return;
      }
      if (!this.baseHandle.hasAttribute('selected') || force) {
        this.baseHandle.style.opacity = 0;
        this.baseHandle.removeAttribute('action');
        this.hideHandles();
        return this.unhover();
      }
    };

    Point.prototype.hover = function() {
      var _ref;
      if ((_ref = this.baseHandle) != null) {
        _ref.setAttribute('hover', '');
      }
      if (this.baseHandle == null) {
        console.log("base handle missing");
      }
      if (this.at === 0) {
        return this.owner.points.last.baseHandle.setAttribute('hover', '');
      } else if (this === this.owner.points.last) {
        return this.owner.points.first.baseHandle.setAttribute('hover', '');
      }
    };

    Point.prototype.unhover = function() {
      var _ref;
      return (_ref = this.baseHandle) != null ? _ref.removeAttribute('hover') : void 0;
    };

    Point.prototype.clear = function() {
      this.baseHandle.style.display = 'none';
      return this;
    };

    Point.prototype.unclear = function() {
      this.baseHandle.style.display = 'block';
      return this;
    };

    Point.prototype.remove = function() {
      var _ref;
      if ((_ref = this.antlers) != null) {
        _ref.hide();
      }
      return this.baseHandle.remove();
    };

    Point.prototype.toStringWithZoom = function() {
      var str;
      this.multiplyByMutable(ui.canvas.zoom);
      str = this.toString();
      this.multiplyByMutable(1 / ui.canvas.zoom);
      return str;
    };

    return Point;

  })(Posn);

  /*
  
    Polynomial
  */


  Polynomial = (function() {
    function Polynomial(coefs) {
      var i, l, v, _ref;
      this.coefs = coefs;
      l = this.coefs.length;
      _ref = this.coefs;
      for (i in _ref) {
        if (!__hasProp.call(_ref, i)) continue;
        v = _ref[i];
        this["p" + (l - i - 1)] = v;
      }
      this.coefs = this.coefs.reverse();
      this;
    }

    Polynomial.prototype.tolerance = 1e-6;

    Polynomial.prototype.accuracy = 6;

    Polynomial.prototype.degrees = function() {
      return this.coefs.length - 1;
    };

    Polynomial.prototype.interpolate = function(xs, xy, n, offset, x) {
      var c, d, den, diff, dift, dy, ho, hp, i, ns, result, w, y, _i, _j, _k, _ref, _ref1, _ref2;
      y = 0;
      dy = 0;
      ns = 0;
      c = [n];
      d = [n];
      diff = Math.abs(x - xs[offset]);
      for (i = _i = 0, _ref = n + 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        dift = Math.abs(x - xs[offset + i]);
        if (dift < diff) {
          ns = i;
          diff = dift;
        }
        c[i] = d[i] = ys[offset + i];
      }
      y = ys[offset + ns];
      ns -= 1;
      for (i = _j = 1, _ref1 = m + 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
        for (i = _k = 0, _ref2 = n - m + 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
          ho = xs[offset + i] - x;
          hp = xs[offset + i + m] - x;
          w = c[i + 1] - d[i];
          den = ho - hp;
          if (den === 0.0) {
            result = {
              y: 0,
              dy: 0
            };
            break;
          }
          den = w / den;
          d[i] = hp * den;
          c[i] = ho * den;
        }
        dy = 2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns -= 1];
        y += dy;
      }
      return {
        y: y,
        dy: dy
      };
    };

    Polynomial.prototype["eval"] = function(x) {
      var i, result, _i, _ref;
      result = 0;
      for (i = _i = _ref = this.coefs.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        result = result * x + this.coefs[i];
      }
      return result;
    };

    Polynomial.prototype.add = function(that) {
      var d1, d2, dmax, i, newCoefs, v1, v2, _i;
      newCoefs = [];
      d1 = this.degrees();
      d2 = that.degrees();
      dmax = Math.max(d1, d2);
      for (i = _i = 0; 0 <= dmax ? _i <= dmax : _i >= dmax; i = 0 <= dmax ? ++_i : --_i) {
        v1 = i <= d1 ? this.coefs[i] : 0;
        v2 = i <= d2 ? that.coefs[i] : 0;
        newCoefs[i] = v1 + v2;
      }
      newCoefs = newCoefs.reverse();
      return new Polynomial(newCoefs);
    };

    Polynomial.prototype.roots = function() {
      switch (this.coefs.length - 1) {
        case 0:
          return [];
        case 1:
          return this.linearRoot();
        case 2:
          return this.quadraticRoots();
        case 3:
          return this.cubicRoots();
        case 4:
          return this.quarticRoots();
        default:
          return [];
      }
    };

    Polynomial.prototype.derivative = function() {
      var i, newCoefs, _i, _ref;
      newCoefs = [];
      for (i = _i = 1, _ref = this.degrees(); 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        newCoefs.push(i * this.coefs[i]);
      }
      return new Polynomial(newCoefs.reverse());
    };

    Polynomial.prototype.bisection = function(min, max) {
      var i, iters, maxValue, minValue, result, tmp1, tmp2, value, _i, _ref;
      minValue = this["eval"](min);
      maxValue = this["eval"](max);
      if (Math.abs(minValue) <= this.tolerance) {
        return min;
      } else if (Math.abs(maxValue) <= this.tolerance) {
        return max;
      } else if (minValue * maxValue <= 0) {
        tmp1 = Math.log(max - min);
        tmp2 = Math.LN10 * this.accuracy;
        iters = Math.ceil((tmp1 + tmp2) / Math.LN2);
        for (i = _i = 0, _ref = iters - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          result = 0.5 * (min + max);
          value = this["eval"](result);
          if (Math.abs(value) <= this.tolerance) {
            break;
          }
          if (value * minValue < 0) {
            max = result;
            maxValue = value;
          } else {
            min = result;
            minValue = value;
          }
        }
      }
      return result;
    };

    Polynomial.prototype.rootsInterval = function(min, max) {
      var deriv, dlen, droots, i, r, results, root, _i, _ref;
      results = [];
      if (this.degrees() === 1) {
        root = this.bisection(min, max);
        if (root != null) {
          results.push(root);
        }
      } else {
        deriv = this.derivative();
        droots = deriv.rootsInterval(min, max);
        dlen = droots.length;
        if (dlen > 0) {
          root = this.bisection(min, droots[0]);
          if (root != null) {
            results.push(root);
          }
          for (i = _i = 0, _ref = dlen - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            r = droots[i];
            root = this.bisection(r, droots[i + 1]);
            if (root != null) {
              results.push(root);
            }
          }
          root = this.bisection(droots[dlen - 1], max);
          if (root != null) {
            results.push(root);
          }
        } else {
          root = this.bisection(min, max);
          if (root != null) {
            results.push(root);
          }
        }
      }
      return results;
    };

    Polynomial.prototype.linearRoot = function() {
      var result;
      result = [];
      if (this.p1 !== 0) {
        result.push(-this.p0 / this.p1);
      }
      return result;
    };

    Polynomial.prototype.quadraticRoots = function() {
      var a, b, c, d, e, results;
      results = [];
      a = this.p2;
      b = this.p1 / a;
      c = this.p0 / a;
      d = b * b - 4 * c;
      if (d > 0) {
        e = Math.sqrt(d);
        results.push(0.5 * (-b + e));
        results.push(0.5 * (-b - e));
      } else if (d === 0) {
        results.push(0.5 * -b);
      }
      return results;
    };

    Polynomial.prototype.cubicRoots = function() {
      var a, angle, b, c0, c1, c2, c3, cos, discrim, distance, e, halfB, offset, results, root, sin, sqrt3, tmp;
      results = [];
      c3 = this.p3;
      c2 = this.p2 / c3;
      c1 = this.p1 / c3;
      c0 = this.p0 / c3;
      a = (3 * c1 - c2 * c2) / 3;
      b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;
      offset = c2 / 3;
      discrim = b * b / 4 + a * a * a / 27;
      halfB = b / 2;
      if ((Math.abs(discrim)) <= 1e-6) {
        discrim = 0;
      }
      if (discrim > 0) {
        e = Math.sqrt(discrim);
        tmp = -halfB + e;
        root = tmp >= 0 ? Math.pow(tmp, 1 / 3) : -Math.pow(-tmp, 1 / 3);
        tmp = -halfB - e;
        root += tmp >= 0 ? Math.pow(tmp, 1 / 3) : -Math.pow(-tmp, 1 / 3);
        results.push(root - offset);
      } else if (discrim < 0) {
        distance = Math.sqrt(-a / 3);
        angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        sqrt3 = Math.sqrt(3);
        results.push(2 * distance * cos - offset);
        results.push(-distance * (cos + sqrt3 * sin) - offset);
        results.push(-distance * (cos - sqrt3 * sin) - offset);
      } else {
        if (halfB >= 0) {
          tmp = -Math.pow(halfB, 1 / 3);
        } else {
          tmp = Math.pow(-halfB, 1 / 3);
        }
        results.push(2 * tmp - offset);
        results.push(-tmp - offset);
      }
      return results;
    };

    return Polynomial;

  })();

  Range = (function() {
    function Range(min, max) {
      this.min = min;
      this.max = max;
    }

    Range.prototype.length = function() {
      return this.max - this.min;
    };

    Range.prototype.contains = function(n) {
      return n > this.min && n < this.max;
    };

    Range.prototype.containsInclusive = function(n, tolerance) {
      if (tolerance == null) {
        tolerance = 0;
      }
      return n >= this.min - tolerance && n <= this.max + tolerance;
    };

    Range.prototype.intersects = function(n) {
      return n === this.min || n === this.max;
    };

    Range.prototype.fromList = function(alon) {
      this.min = Math.min.apply(this, alon);
      this.max = Math.max.apply(this, alon);
      return this;
    };

    Range.prototype.fromRangeList = function(alor) {
      var maxs, mins;
      mins = alor.map(function(r) {
        return r.min;
      });
      maxs = alor.map(function(r) {
        return r.max;
      });
      this.min = Math.min.apply(this, mins);
      this.max = Math.max.apply(this, maxs);
      return this;
    };

    Range.prototype.nudge = function(amt) {
      this.min += amt;
      return this.max += amt;
    };

    Range.prototype.scale = function(amt, origin) {
      this.min += (this.min - origin) * (amt - 1);
      return this.max += (this.max - origin) * (amt - 1);
    };

    Range.prototype.toString = function() {
      return "[" + (this.min.places(4)) + "," + (this.max.places(4)) + "]";
    };

    Range.prototype.percentageOfValue = function(v) {
      return (v - this.min) / this.length();
    };

    return Range;

  })();

  Bounds = (function() {
    function Bounds(x, y, width, height) {
      var minX;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      if (this.x instanceof Array) {
        minX = Math.min.apply(this, this.x.map(function(b) {
          return b.x;
        }));
        this.y = Math.min.apply(this, this.x.map(function(b) {
          return b.y;
        }));
        this.x2 = Math.max.apply(this, this.x.map(function(b) {
          return b.x2;
        }));
        this.y2 = Math.max.apply(this, this.x.map(function(b) {
          return b.y2;
        }));
        this.x = minX;
        this.width = this.x2 - this.x;
        this.height = this.y2 - this.y;
      } else if (this.x instanceof Posn && this.y instanceof Posn) {
        x = Math.min(this.x.x, this.y.x);
        y = Math.min(this.x.y, this.y.y);
        this.x2 = Math.max(this.x.x, this.y.x);
        this.y2 = Math.max(this.x.y, this.y.y);
        this.x = x;
        this.y = y;
        this.width = this.x2 - this.x;
        this.height = this.y2 - this.y;
      } else {
        this.x2 = this.x + this.width;
        this.y2 = this.y + this.height;
      }
      this.xr = new Range(this.x, this.x + this.width);
      this.yr = new Range(this.y, this.y + this.height);
    }

    Bounds.prototype.tl = function() {
      return new Posn(this.x, this.y);
    };

    Bounds.prototype.tr = function() {
      return new Posn(this.x2, this.y);
    };

    Bounds.prototype.br = function() {
      return new Posn(this.x2, this.y2);
    };

    Bounds.prototype.bl = function() {
      return new Posn(this.x, this.y2);
    };

    Bounds.prototype.clone = function() {
      return new Bounds(this.x, this.y, this.width, this.height);
    };

    Bounds.prototype.toRect = function() {
      return new Rect({
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      });
    };

    Bounds.prototype.center = function() {
      return new Posn(this.x + (this.width / 2), this.y + (this.height / 2));
    };

    Bounds.prototype.points = function() {
      return [new Posn(this.x, this.y), new Posn(this.x2, this.y), new Posn(this.x2, this.y2), new Posn(this.x, this.y2)];
    };

    Bounds.prototype.contains = function(posn, tolerance) {
      return this.xr.containsInclusive(posn.x, tolerance) && this.yr.containsInclusive(posn.y, tolerance);
    };

    Bounds.prototype.overlapsBounds = function(other, recur) {
      if (recur == null) {
        recur = true;
      }
      return this.toRect().overlaps(other.toRect());
    };

    Bounds.prototype.nudge = function(x, y) {
      this.x += x;
      this.x2 += x;
      this.y += y;
      this.y2 += y;
      this.xr.nudge(x);
      return this.yr.nudge(y);
    };

    Bounds.prototype.scale = function(x, y, origin) {
      var br, tl;
      tl = new Posn(this.x, this.y);
      br = new Posn(this.x2, this.y2);
      tl.scale(x, y, origin);
      br.scale(x, y, origin);
      this.x = tl.x;
      this.y = tl.y;
      this.x2 = br.x;
      this.y2 = br.y;
      this.width *= x;
      this.height *= y;
      this.xr.scale(x, origin);
      this.yr.scale(y, origin);
      return this;
    };

    Bounds.prototype.squareSmaller = function(anchor) {
      if (this.width < this.height) {
        return this.height = this.width;
      } else {
        return this.width = this.height;
      }
    };

    Bounds.prototype.centerOn = function(posn) {
      var offset;
      offset = posn.subtract(this.center());
      return this.nudge(offset.x, offset.y);
    };

    Bounds.prototype.fitTo = function(bounds) {
      var sh, sm, sw;
      sw = this.width / bounds.width;
      sh = this.height / bounds.height;
      sm = Math.max(sw, sh);
      return new Bounds(0, 0, this.width / sm, this.height / sm);
    };

    Bounds.prototype.adjustElemsTo = function(bounds) {
      var offset, sh, sw;
      offset = this.tl().subtract(bounds.tl());
      sw = this.width / bounds.width;
      sh = this.height / bounds.height;
      return function(elem) {
        elem.scale(1 / sw, 1 / sh, bounds.tl());
        return elem.nudge(-offset.x, offset.y);
      };
    };

    Bounds.prototype.annotateCorners = function() {
      ui.annotations.drawDot(this.tl());
      ui.annotations.drawDot(this.tr());
      ui.annotations.drawDot(this.bl());
      return ui.annotations.drawDot(this.br());
    };

    return Bounds;

  })();

  /*
  
    Antlers
  
       \
          \ O  -  (succx, succy)
            \\
              \
               \
                o
                 \
                  \
                  \\
                  \ O  -  (basex, basey)
                  |
                  |
                 /
                /
  
  
    Control handles for any vector Point. Edits base's x3 and base's succ's p2
    Each CurvePoint gets one of these. It keeps track of coordinates locally so we can
    draw these pre-emptively. For example, if you take the Pen tool and just drag a curve point right away,
    those curves don't exist yet but they come into play as soon as you add another point
    (...which will have to be a CurvePoint even if it's a static click)
  
    This class handles the GUI and updating the base and its succ's x2 y2 x3 y3. :)
  */


  Antlers = (function() {
    function Antlers(base, basep3, succp2) {
      var diff;
      this.base = base;
      this.basep3 = basep3;
      this.succp2 = succp2;
      if ((this.basep3 != null) && (this.succp2 != null)) {
        diff = Math.abs(this.basep3.angle360(this.base) - this.succp2.angle360(this.base));
        this.lockAngle = diff.within(this.angleLockThreshold, 180);
      } else {
        this.lockAngle = false;
      }
      this;
    }

    Antlers.prototype.angleLockThreshold = 0.5;

    Antlers.prototype.commit = function() {
      if (this.basep3 != null) {
        this.base.x3 = this.basep3.x;
        this.base.y3 = this.basep3.y;
      }
      if ((this.succp2 != null) && this.succ()) {
        this.succ().x2 = this.succp2.x;
        this.succ().y2 = this.succp2.y;
      }
      return this;
    };

    Antlers.prototype.importNewSuccp2 = function(succp2) {
      this.succp2 = succp2;
      if (this.succp2 != null) {
        this.basep3 = this.succp2.reflect(this.base);
      }
      return this.commit().refresh();
    };

    Antlers.prototype.killSuccp2 = function() {
      this.succp2 = new Posn(this.base.x, this.base.y);
      return this.commit().refresh();
    };

    Antlers.prototype.succ = function() {
      return this.base.succ;
    };

    Antlers.prototype.refresh = function() {
      if (!this.visible) {
        return;
      }
      return this.hide().show();
    };

    Antlers.prototype.visible = false;

    Antlers.prototype.show = function() {
      var _this = this;
      this.hide();
      this.visible = true;
      if (this.basep3 != null) {
        this.basep = new AntlerPoint(this.basep3.x, this.basep3.y, this.base.owner, this, -1);
      }
      if (this.succp2 != null) {
        this.succp = new AntlerPoint(this.succp2.x, this.succp2.y, this.base.owner, this, 1);
      }
      return (function() {
        return _this.hide();
      });
    };

    Antlers.prototype.hide = function() {
      var _ref, _ref1, _ref2;
      this.visible = false;
      if ((_ref = this.basep) != null) {
        _ref.remove();
      }
      if ((_ref1 = this.succp) != null) {
        _ref1.remove();
      }
      if ((_ref2 = this.base.owner.antlerPoints) != null) {
        _ref2.remove([this.basep, this.succp]);
      }
      return this;
    };

    Antlers.prototype.redraw = function() {
      this.hide();
      this.show();
      return this;
    };

    Antlers.prototype.hideTemp = function(p) {
      var _ref;
      return (_ref = (p === 2 ? this.succp : this.basep)) != null ? _ref.hideTemp() : void 0;
    };

    Antlers.prototype.nudge = function(x, y) {
      var _ref, _ref1;
      if ((_ref = this.basep3) != null) {
        _ref.nudge(x, y);
      }
      if ((_ref1 = this.succp2) != null) {
        _ref1.nudge(x, y);
      }
      if (this.succ() instanceof CurvePoint) {
        this.succ().x2 += x;
        this.succ().y2 -= y;
      }
      return this.commit();
    };

    Antlers.prototype.scale = function(x, y, origin) {
      var _ref, _ref1;
      if ((_ref = this.basep3) != null) {
        _ref.scale(x, y, origin);
      }
      return (_ref1 = this.succp2) != null ? _ref1.scale(x, y, origin) : void 0;
    };

    Antlers.prototype.rotate = function(a, origin) {
      var _ref, _ref1;
      if ((_ref = this.basep3) != null) {
        _ref.rotate(a, origin);
      }
      if ((_ref1 = this.succp2) != null) {
        _ref1.rotate(a, origin);
      }
      return this;
    };

    Antlers.prototype.other = function(p) {
      if (p === this.succp) {
        return this.basep;
      } else {
        return this.succp;
      }
    };

    Antlers.prototype.angleDiff = function(a, b) {
      var x;
      x = a - b;
      if (x < 0) {
        x += 360;
      }
      return x;
    };

    Antlers.prototype.flatten = function() {
      var ahead, angleBasep3, angleSuccp2, compensate, p2p3d, p3p2d;
      if ((this.succp2 == null) || (this.basep3 == null)) {
        return;
      }
      angleSuccp2 = this.succp2.angle360(this.base);
      angleBasep3 = this.basep3.angle360(this.base);
      p2p3d = this.angleDiff(angleSuccp2, angleBasep3);
      p3p2d = this.angleDiff(angleBasep3, angleSuccp2);
      if (p2p3d < p3p2d) {
        ahead = "p2";
      } else {
        ahead = "p3";
      }
      if (ahead === "p2") {
        if (p2p3d < 180) {
          compensate = (180 - p2p3d) / 2;
          this.succp2 = this.succp2.rotate(compensate, this.base);
          return this.basep3 = this.basep3.rotate(-compensate, this.base);
        }
      } else {
        if (p3p2d < 180) {
          compensate = (180 - p3p2d) / 2;
          this.succp2 = this.succp2.rotate(-compensate, this.base);
          return this.basep3 = this.basep3.rotate(compensate, this.base);
        }
      }
    };

    return Antlers;

  })();

  AntlerPoint = (function(_super) {
    __extends(AntlerPoint, _super);

    function AntlerPoint(x, y, owner, family, role) {
      var _ref;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.family = family;
      this.role = role;
      AntlerPoint.__super__.constructor.call(this, this.x, this.y, this.owner);
      this.draw();
      this.baseHandle.className += ' bz-ctrl';
      this.line = ui.annotations.drawLine(this.zoomedc(), this.family.base.zoomedc());
      if ((_ref = this.owner.antlerPoints) != null) {
        _ref.push(this);
      }
    }

    AntlerPoint.prototype.succ = function() {
      return this.family.base.succ;
    };

    AntlerPoint.prototype.base = function() {
      return this.family.base;
    };

    AntlerPoint.prototype.hideTemp = function() {
      var _this = this;
      this.line.rep.style.display = 'none';
      this.baseHandle.style.display = 'none';
      return function() {
        _this.line.rep.style.display = 'block';
        return _this.baseHandle.style.display = 'block';
      };
    };

    AntlerPoint.prototype.remove = function() {
      this.line.remove();
      return AntlerPoint.__super__.remove.apply(this, arguments);
    };

    AntlerPoint.prototype.nudge = function(x, y) {
      var newangle, oldangle, s, _ref;
      if (!this.family.lockAngle) {
        AntlerPoint.__super__.nudge.call(this, x, y);
        this.persist();
      } else {
        oldangle = this.angle360(this.family.base);
        AntlerPoint.__super__.nudge.call(this, x, y);
        newangle = this.angle360(this.family.base);
        if ((_ref = this.family.other(this)) != null) {
          _ref.rotate(newangle - oldangle, this.family.base);
        }
        this.persist();
      }
      if (this.role === -1 && this.family.base.succ instanceof SmoothTo) {
        s = this.family.base.succ;
        return s.replaceWith(s.toCurveTo());
      }
    };

    AntlerPoint.prototype.scale = function(x, y, origin) {
      AntlerPoint.__super__.scale.call(this, x, y, origin);
      return this.persist();
    };

    AntlerPoint.prototype.rotate = function(a, origin) {
      AntlerPoint.__super__.rotate.call(this, a, origin);
      return this.persist();
    };

    AntlerPoint.prototype.persist = function() {
      var first;
      if (this.role === -1) {
        this.family.basep3.copy(this);
      }
      if (this.role === 1) {
        this.family.succp2.copy(this);
      }
      if (this.family.base === this.owner.points.last) {
        first = this.owner.points.first;
        if (this.family.base.equal(first)) {
          first.antlers.succp2 = this.family.succp2.clone();
          first.antlers.basep3 = this.family.basep3.clone();
          first.antlers.commit();
        }
      }
      this.line.absorbA(this.family.base.zoomedc());
      this.line.absorbB(this.zoomedc());
      this.line.commit();
      return this.family.commit();
    };

    return AntlerPoint;

  })(Point);

  /*
  
    Path points
    
    MoveTo
      Mx,y
      Begin a path at x,y
  
    LineTo
      Lx,y
      Draw straight line from pvx,pvy to x,y
  
    CurveTo
      Cx1,y1 x2,y2 x,y
      Draw a line to x,y.
      x1,y1 is the control point put on the previous point
      x2,y2 is the control point put on this point (x,y)
  
    SmoothTo
      Sx2,y2 x,y
      Shorthand for curveto. x1,y1 becomes x2,y2 from previous CurveTo.
  
    HorizTo
      Hx
      Draw a horizontal line inheriting the y-value from precessor
  
    VertiTo
      Vy
      Draw a vertical line inheriting the x-value from precessor
  */


  MoveTo = (function(_super) {
    __extends(MoveTo, _super);

    function MoveTo(x, y, owner, prec, rel) {
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      MoveTo.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    MoveTo.prototype.relative = function() {
      var m, precAbs, x, y;
      if (this.at === 0) {
        this.rel = false;
        return this;
      } else {
        if (this.rel) {
          return this;
        }
        precAbs = this.prec.absolute();
        x = precAbs.x;
        y = precAbs.y;
        m = new MoveTo(this.x - x, this.y - y, this.owner);
        m.rel = true;
        return m;
      }
    };

    MoveTo.prototype.absolute = function() {
      var m, point, precAbs, x, y, _i, _len, _ref, _results;
      if (this.at === 0) {
        this.rel = false;
        return this;
      } else {
        if (!this.rel) {
          return this;
        }
        precAbs = this.prec.absolute();
        x = precAbs.x;
        y = precAbs.y;
        m = new MoveTo(this.x + x, this.y + y, this.owner);
        m.rel = false;
        return m;
      }
      _ref = points.match(/[MLCSHV][\-\de\.\,\-\s]+/gi);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        _results.push(new Point(point, this.owner));
      }
      return _results;
    };

    MoveTo.prototype.p2 = function() {
      var _ref;
      if (((_ref = this.antlers) != null ? _ref.succp2 : void 0) != null) {
        return new Posn(this.antlers.succp2.x, this.antlers.succp2.y);
      } else {
        return null;
      }
    };

    MoveTo.prototype.toString = function() {
      return "" + (this.rel ? "m" : "M") + this.x + "," + this.y;
    };

    MoveTo.prototype.toLineSegment = function() {
      return this.prec.toLineSegment();
    };

    MoveTo.prototype.clone = function() {
      return new MoveTo(this.x, this.y, this.owner, this.prec, this.rel);
    };

    return MoveTo;

  })(Point);

  LineTo = (function(_super) {
    __extends(LineTo, _super);

    function LineTo(x, y, owner, prec, rel) {
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      LineTo.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    LineTo.prototype.relative = function() {
      var l, precAbs, x, y;
      if (this.rel) {
        return this;
      }
      precAbs = this.prec.absolute();
      x = precAbs.x;
      y = precAbs.y;
      l = new LineTo(this.x - x, this.y - y, this.owner);
      l.rel = true;
      return l;
    };

    LineTo.prototype.absolute = function() {
      var l, precAbs, x, y;
      if (!this.rel) {
        return this;
      }
      if (this.absoluteCached) {
        return this.absoluteCached;
      }
      precAbs = this.prec.absolute();
      x = precAbs.x;
      y = precAbs.y;
      l = new LineTo(this.x + x, this.y + y, this.owner);
      l.rel = false;
      this.absoluteCached = l;
      return l;
    };

    LineTo.prototype.toString = function() {
      return "" + (this.rel ? 'l' : 'L') + this.x + "," + this.y;
    };

    LineTo.prototype.clone = function() {
      return new LineTo(this.x, this.y, this.owner, this.prec, this.rel);
    };

    return LineTo;

  })(Point);

  HorizTo = (function(_super) {
    __extends(HorizTo, _super);

    function HorizTo(x, owner, prec, rel) {
      this.x = x;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      this.inheritFromPrec(this.prec);
      HorizTo.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    HorizTo.prototype.inheritFromPrec = function(prec) {
      this.prec = prec;
      return this.y = this.prec.absolute().y;
    };

    HorizTo.prototype.toString = function() {
      return "" + (this.rel ? 'h' : 'H') + this.x;
    };

    HorizTo.prototype.convertToLineTo = function() {
      var lineTo;
      lineTo = new LineTo(this.x, this.y);
      this.replaceWith(lineTo);
      return lineTo;
    };

    HorizTo.prototype.rotate = function(a, origin) {
      return this.convertToLineTo().rotate(a, origin);
    };

    HorizTo.prototype.absolute = function() {
      if (!this.rel) {
        return this;
      }
      if (this.absoluteCached) {
        return this.absoluteCached;
      }
      return this.absoluteCached = new HorizTo(this.x + this.prec.absolute().x, this.owner, this.prec, false);
    };

    HorizTo.prototype.relative = function() {
      if (this.rel) {
        return this;
      }
      return new HorizTo(this.x - this.prec.absolute().x, this.owner, this.prec, true);
    };

    HorizTo.prototype.clone = function() {
      return new HorizTo(this.x, this.owner, this.prec, this.rel);
    };

    return HorizTo;

  })(Point);

  VertiTo = (function(_super) {
    __extends(VertiTo, _super);

    function VertiTo(y, owner, prec, rel) {
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      this.inheritFromPrec(this.prec);
      VertiTo.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    VertiTo.prototype.inheritFromPrec = function(prec) {
      this.prec = prec;
      return this.x = this.prec.absolute().x;
    };

    VertiTo.prototype.toString = function() {
      return "" + (this.rel ? 'v' : 'V') + this.y;
    };

    VertiTo.prototype.convertToLineTo = function() {
      var lineTo;
      lineTo = new LineTo(this.x, this.y);
      this.replaceWith(lineTo);
      return lineTo;
    };

    VertiTo.prototype.rotate = function(a, origin) {
      return this.convertToLineTo().rotate(a, origin);
    };

    VertiTo.prototype.absolute = function() {
      if (!this.rel) {
        return this;
      }
      if (this.absoluteCached) {
        return this.absoluteCached;
      }
      return this.absoluteCached = new VertiTo(this.y + this.prec.absolute().y, this.owner, this.prec, false);
    };

    VertiTo.prototype.relative = function() {
      if (this.rel) {
        return this;
      }
      return new VertiTo(this.y - this.prec.absolute().y, this.owner, this.prec, true);
    };

    VertiTo.prototype.clone = function() {
      return new VertiTo(this.y, this.owner, this.prec, this.rel);
    };

    return VertiTo;

  })(Point);

  /*
  
    CurvePoint
  
    A Point that has handles. Builds the handles in its constructor.
  */


  CurvePoint = (function(_super) {
    __extends(CurvePoint, _super);

    function CurvePoint(x2, y2, x3, y3, x, y, owner, prec, rel) {
      this.x2 = x2;
      this.y2 = y2;
      this.x3 = x3;
      this.y3 = y3;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      /*
      
        This Class just extends into CurveTo and SmoothTo as a way of abstracting out the curve
        handling the control points. It has two control points in addition to the base point (handled by super)
      
        Each point has a predecessor and a successor (in terms of line segments).
      
        It has two control points:
          (@x2, @y2) is the first curve control point (p2), which becomes @p2h
          (@x3, @y3) is the second (p3), which becomes @p3h
        (Refer to ASCII art at top of cubic-bezier-line-segment.coffee for point name reference)
      
        Dragging these mofos will alter the correct control point(s), which will change the curve
      
        I/P:
          x2, y2: control point (p2)
          x3, y3: control point (p3)
          x, y:   next base point (like any other point)
          owner:  elem that owns this shape (supered into Point)
          prec:   point that comes before it
          rel:    bool - true if it's relative or false if it's absolute
      */

      CurvePoint.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    CurvePoint.prototype.p2 = function() {
      return new Posn(this.x2, this.y2);
    };

    CurvePoint.prototype.p3 = function() {
      return new Posn(this.x3, this.y3);
    };

    CurvePoint.prototype.p = function() {
      return new Posn(this.x, this.y);
    };

    CurvePoint.prototype.absorb = function(p, n) {
      this["x" + n] = p.x;
      return this["y" + n] = p.y;
    };

    CurvePoint.prototype.show = function() {
      if (!this.owner) {
        return this;
      }
      return CurvePoint.__super__.show.apply(this, arguments);
    };

    CurvePoint.prototype.cleanUp = function() {
      return;
      this.x2 = cleanUpNumber(this.x2);
      this.y2 = cleanUpNumber(this.y2);
      this.x3 = cleanUpNumber(this.x3);
      this.y3 = cleanUpNumber(this.y3);
      return CurvePoint.__super__.cleanUp.apply(this, arguments);
    };

    CurvePoint.prototype.scale = function(x, y, origin) {
      this.absorb(this.p2().scale(x, y, origin), 2);
      this.absorb(this.p3().scale(x, y, origin), 3);
      return CurvePoint.__super__.scale.call(this, x, y, origin);
    };

    CurvePoint.prototype.rotate = function(a, origin) {
      this.absorb(this.p2().rotate(a, origin), 2);
      this.absorb(this.p3().rotate(a, origin), 3);
      return CurvePoint.__super__.rotate.call(this, a, origin);
    };

    CurvePoint.prototype.relative = function() {
      var args, c, precAbs, x, y;
      if (this.rel) {
        return this;
      }
      precAbs = this.prec.absolute();
      x = precAbs.x;
      y = precAbs.y;
      args = [this.x2 - x, this.y2 - y, this.x3 - x, this.y3 - y, this.x - x, this.y - y, this.owner, this.prec];
      if (this.constructor === SmoothTo) {
        args = args.slice(2);
      }
      args.unshift(null);
      c = new (Function.prototype.bind.apply(this.constructor, args));
      c.rel = true;
      return c;
    };

    CurvePoint.prototype.absolute = function() {
      var args, c, precAbs, x, y;
      if (!this.rel) {
        return this;
      }
      precAbs = this.prec.absolute();
      x = precAbs.x;
      y = precAbs.y;
      args = [this.x2 + x, this.y2 + y, this.x3 + x, this.y3 + y, this.x + x, this.y + y, this.owner, this.prec];
      if (this.constructor === SmoothTo) {
        args = args.slice(2);
      }
      args.unshift(null);
      c = new (Function.prototype.bind.apply(this.constructor, args));
      c.rel = false;
      return c;
    };

    return CurvePoint;

  })(Point);

  CurveTo = (function(_super) {
    __extends(CurveTo, _super);

    function CurveTo(x2, y2, x3, y3, x, y, owner, prec, rel) {
      this.x2 = x2;
      this.y2 = y2;
      this.x3 = x3;
      this.y3 = y3;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      CurveTo.__super__.constructor.call(this, this.x2, this.y2, this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
    }

    CurveTo.prototype.toString = function() {
      return "" + (this.rel ? 'c' : 'C') + this.x2 + "," + this.y2 + " " + this.x3 + "," + this.y3 + " " + this.x + "," + this.y;
    };

    CurveTo.prototype.reverse = function() {
      return new CurveTo(this.x3, this.y3, this.x2, this.y2, this.x, this.y, this.owner, this.prec, this.rel).inheritPosition(this);
    };

    CurveTo.prototype.clone = function() {
      return new CurveTo(this.x2, this.y2, this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
    };

    return CurveTo;

  })(CurvePoint);

  SmoothTo = (function(_super) {
    __extends(SmoothTo, _super);

    function SmoothTo(x3, y3, x, y, owner, prec, rel) {
      this.x3 = x3;
      this.y3 = y3;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      this.inheritFromPrec(this.prec);
      SmoothTo.__super__.constructor.call(this, this.x2, this.y2, this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
    }

    SmoothTo.prototype.inheritFromPrec = function(prec) {
      var p2, precAbs;
      this.prec = prec;
      if (this.prec instanceof CurvePoint) {
        precAbs = this.prec.absolute();
        p2 = new Posn(precAbs.x3, precAbs.y3).reflect(precAbs);
      } else {
        p2 = new Posn(this.x, this.y);
      }
      this.x2 = p2.x;
      return this.y2 = p2.y;
    };

    SmoothTo.prototype.toCurveTo = function(p2) {
      var ct;
      if (p2 == null) {
        p2 = null;
      }
      if (p2 === null) {
        if (this.prec instanceof CurvePoint) {
          p2 = this.prec.p3().reflect(this.prec.p());
        } else {
          p2 = new Posn(this.x, this.y);
        }
      }
      ct = new CurveTo(p2.x, p2.y, this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
      ct.at = this.at;
      return ct;
    };

    SmoothTo.prototype.toString = function() {
      return "" + (this.rel ? 's' : 'S') + this.x3 + "," + this.y3 + " " + this.x + "," + this.y;
    };

    SmoothTo.prototype.reverse = function() {
      return new CurveTo(this.x3, this.y3, this.x2, this.y2, this.x, this.y, this.owner, this.prec, this.rel);
    };

    SmoothTo.prototype.clone = function() {
      return new SmoothTo(this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
    };

    return SmoothTo;

  })(CurvePoint);

  /*
  
    PointsList
  
    Stores points, keeps them in order, lets you do shit
    Basically a linked-list.
  */


  PointsList = (function() {
    function PointsList(alop, owner, segments) {
      var accumulatedSegment, commitSegment, ind, lastPoint, point,
        _this = this;
      this.owner = owner;
      this.segments = segments != null ? segments : [];
      if (typeof alop === "string") {
        alop = this.stringToAlop(alop);
      }
      accumulatedSegment = [];
      lastPoint = void 0;
      commitSegment = function() {
        var sgmt;
        if (accumulatedSegment.length === 0) {
          return;
        }
        sgmt = new PointsSegment(accumulatedSegment, _this);
        _this.lastSegment = sgmt;
        if (_this.firstSegment === null) {
          _this.firstSegment = sgmt;
        }
        _this.segments.push(sgmt);
        return accumulatedSegment = [];
      };
      if (this.segments.length !== 0) {
        this.firstSegment = this.segments[0];
        this.lastSegment = this.segments[this.segments.length - 1];
      }
      if (alop.length === 0) {
        return;
      }
      for (ind in alop) {
        if (!__hasProp.call(alop, ind)) continue;
        point = alop[ind];
        ind = parseInt(ind, 10);
        point.at = ind;
        if (ind === 0) {
          this.first = point;
        }
        if (ind === alop.length - 1) {
          this.last = point;
        }
        point.setPrec((lastPoint != null ? lastPoint : alop[alop.length - 1]));
        if (lastPoint != null) {
          lastPoint.setSucc(point);
        }
        if (point instanceof MoveTo) {
          commitSegment();
        }
        accumulatedSegment.push(point);
        lastPoint = point;
      }
      commitSegment();
      lastPoint.setSucc(this.first);
    }

    PointsList.prototype.segments = [];

    PointsList.prototype.first = null;

    PointsList.prototype.last = null;

    PointsList.prototype.firstSegment = null;

    PointsList.prototype.lastSegment = null;

    PointsList.prototype.closed = false;

    PointsList.prototype.stringToAlop = function(points) {
      var all_matches, p, point, previous, results, _i, _len;
      results = [];
      all_matches = points.match(/[MLCSHV][\-\de\.\,\-\s]+/gi);
      for (_i = 0, _len = all_matches.length; _i < _len; _i++) {
        point = all_matches[_i];
        p = new Point(point, this.owner, previous);
        if (p instanceof Point) {
          if (typeof previous !== "undefined" && previous !== null) {
            p.setPrec(previous);
          }
          previous = p;
          if ((p instanceof SmoothTo) && (this.owner instanceof Point)) {
            p.setPrec(this.owner);
          }
          results.push(p);
        } else if (p instanceof Array) {
          if (previous != null) {
            p[0].setPrec(previous);
            p.reduce(function(a, b) {
              return b.setPrec(a);
            });
          }
          results = results.concat(p);
        }
      }
      return results;
    };

    PointsList.prototype.closedOnSameSpot = function() {
      return this.closed && (this.last.equal(this.first));
    };

    PointsList.prototype.all = function() {
      var pts, s, _i, _len, _ref;
      pts = [];
      _ref = this.segments;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        pts = pts.concat(s.points);
      }
      return pts;
    };

    PointsList.prototype.renumber = function() {
      return this.all().map(function(p, i) {
        p.at = i;
        return p;
      });
    };

    PointsList.prototype.pushSegment = function(sgmt) {
      this.lastSegment = sgmt;
      return this.segments.push(sgmt);
    };

    PointsList.prototype.push = function(point, after) {
      if (this.segments.length === 0) {
        this.pushSegment(new PointsSegment([], this));
      }
      point.owner = this.owner;
      if (after == null) {
        point.at = this.lastSegment.points.length;
        this.lastSegment.points.push(point);
        if (this.last != null) {
          this.last.setSucc(point);
          point.setPrec(this.last);
        } else {
          point.setPrec(point);
        }
        if (this.first != null) {
          this.first.setPrec(point);
          point.setSucc(this.first);
        } else {
          point.setSucc(point);
        }
        this.last = point;
        return this;
      }
    };

    PointsList.prototype.replace = function(old, replacement) {
      return this.segmentContaining(old).replace(old, replacement);
    };

    PointsList.prototype.reverse = function() {
      return new PointsList([], this.owner, this.segments.map(function(s) {
        return s.reverse();
      }));
    };

    PointsList.prototype.at = function(n) {
      return this.segmentContaining(parseInt(n, 10)).at(n);
    };

    PointsList.prototype.close = function() {
      this.closed = true;
      return this;
    };

    PointsList.prototype.relative = function() {
      this.segments = this.segments.map(function(s) {
        s.points = s.points.map(function(p) {
          var abs;
          abs = p.relative();
          abs.inheritPosition(p);
          return abs;
        });
        return s;
      });
      return this;
    };

    PointsList.prototype.absolute = function() {
      this.segments = this.segments.map(function(s) {
        s.points = s.points.map(function(p) {
          var abs;
          abs = p.absolute();
          abs.inheritPosition(p);
          return abs;
        });
        return s;
      });
      return this;
    };

    PointsList.prototype.drawBasePoints = function() {
      this.map(function(p) {
        var _ref;
        if ((_ref = p.baseHandle) != null) {
          _ref.remove();
        }
        p.draw();
        return p.makeAntlers();
      });
      return this;
    };

    PointsList.prototype.removeBasePoints = function() {
      this.map(function(p) {
        var _ref;
        return (_ref = p.baseHandle) != null ? _ref.remove() : void 0;
      });
      return this;
    };

    PointsList.prototype.hide = function() {
      return this.map(function(p) {
        return p.hide();
      });
    };

    PointsList.prototype.unhover = function() {
      return this.map(function(p) {
        return p.unhover();
      });
    };

    PointsList.prototype.join = function(x) {
      return this.all().join(x);
    };

    PointsList.prototype.segmentContaining = function(a) {
      var s, segm, segments, _i, _len, _ref;
      if (typeof a === "number") {
        _ref = this.segments;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          if (s.startsAt <= a) {
            segm = s;
          } else {
            break;
          }
        }
        return segm;
      } else {
        segments = this.segments.filter(function(s) {
          return s.points.indexOf(a > -1);
        });
        if (segments.length === 1) {
          return segments[0];
        }
      }
      return [];
    };

    PointsList.prototype.remove = function(x) {
      var p, _i, _len, _results;
      if (typeof x === "number") {
        x = this.at(x);
      }
      if (x instanceof Array) {
        _results = [];
        for (_i = 0, _len = x.length; _i < _len; _i++) {
          p = x[_i];
          _results.push(this.remove(p));
        }
        return _results;
      } else if (x instanceof Point) {
        return this.segmentContaining(x).remove(x);
      }
    };

    PointsList.prototype.filter = function(fun) {
      return this.all().filter(fun);
    };

    PointsList.prototype.fetch = function(cl) {
      return this.all().filter(function(p) {
        return p instanceof cl;
      });
    };

    PointsList.prototype.map = function(fun) {
      return this.segments.map(function(s) {
        return s.points.map(fun);
      });
    };

    PointsList.prototype.mapApply = function(fun) {
      return this.segments.map(function(s) {
        return s.points = s.points.map(fun);
      });
    };

    PointsList.prototype.xRange = function() {
      var xs;
      xs = this.all().map(function(p) {
        return p.x;
      });
      return new Range(Math.min.apply(this, xs), Math.max.apply(this, xs));
    };

    PointsList.prototype.yRange = function() {
      var ys;
      ys = this.all().map(function(p) {
        return p.y;
      });
      return new Range(Math.min.apply(this, ys), Math.max.apply(this, ys));
    };

    PointsList.prototype.toString = function() {
      return this.segments.join(' ') + (this.closed ? "z" : "");
    };

    return PointsList;

  })();

  /*
  
    PointsSegment
  
    A segment of points which might compose part or all of
    a Path's PointsList.
  
    Manages points from a MoveTo to the point before the next MoveTo,
    which in essence are a seperate set of points from the rest of
    the shape (if it has several of these segments).
  */


  PointsSegment = (function() {
    function PointsSegment(points, list) {
      this.points = points;
      this.list = list;
      this.startsAt = this.points.length !== 0 ? this.points[0].at : 0;
      if (this.list != null) {
        this.owner = this.list.owner;
      }
      if (this.points[0] instanceof MoveTo) {
        this.moveTo = this.points[0];
      }
    }

    PointsSegment.prototype.toString = function() {
      return this.points.join(' ');
    };

    PointsSegment.prototype.at = function(n) {
      return this.points[n - this.startsAt];
    };

    PointsSegment.prototype.remove = function(x) {
      x.prec.succ = x.succ;
      x.succ.prec = x.prec;
      if (x === this.list.last) {
        this.list.last = x.prec;
      }
      if (x === this.list.first) {
        this.list.first = x.succ;
      }
      x.remove();
      return this.points = this.points.remove(x);
    };

    PointsSegment.prototype.moveMoveTo = function(otherPoint) {
      var i, segment, tail, _i, _ref;
      tail = this.points.slice(1);
      for (i = _i = 0, _ref = otherPoint.at - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        segment = segment.cannibalize();
      }
      this.moveTo.copy(otherPoint);
      return this.points = [this.moveTo].concat(segment);
    };

    PointsSegment.prototype.replace = function(old, replacement) {
      var at, np, p, prec, replen, succ, _i, _j, _len, _len1, _ref;
      if (replacement instanceof Point) {
        replacement.inheritPosition(old);
        this.points = this.points.replace(old, replacement);
      } else if (replacement instanceof Array) {
        replen = replacement.length;
        at = old.at;
        prec = old.prec;
        succ = old.succ;
        old.succ.prec = replacement[replen - 1];
        for (_i = 0, _len = replacement.length; _i < _len; _i++) {
          np = replacement[_i];
          np.owner = this.owner;
          np.at = at;
          np.prec = prec;
          np.succ = succ;
          prec.succ = np;
          prec = np;
          at += 1;
        }
        this.points = this.points.replace(old, replacement);
        _ref = this.points.slice(at);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          p = _ref[_j];
          p.at += replen - 1;
        }
      }
      return replacement;
    };

    PointsSegment.prototype.validateLinks = function() {
      var i, p, prev, succ, _ref;
      console.log(this.points.map(function(p) {
        return "" + p.prec.at + " " + p.at + " " + p.succ.at;
      }));
      prev = this.points.length - 1;
      _ref = this.points;
      for (i in _ref) {
        if (!__hasProp.call(_ref, i)) continue;
        p = _ref[i];
        i = parseInt(i, 10);
        if (!(p.prec === this.points[prev])) {
          console.log(p, "prec wrong. Expecting", prev);
          debugger;
          return false;
          break;
        }
        succ = i === this.points.length - 1 ? 0 : i + 1;
        if (!(p.succ === this.points[succ])) {
          console.log(p, "succ wrong");
          return false;
          break;
        }
        prev = i;
      }
      return true;
    };

    PointsSegment.prototype.reverse = function() {
      var index, point, positions, stack, tailRev, _ref;
      positions = [];
      stack = [];
      _ref = this.points;
      for (index in _ref) {
        if (!__hasProp.call(_ref, index)) continue;
        point = _ref[index];
        stack.push(point);
        positions.push({
          x: point.x,
          y: point.y
        });
      }
      tailRev = stack.slice(1).reverse().map(function(p) {
        if (p instanceof CurvePoint) {
          return p.reverse();
        } else {
          return p;
        }
      });
      positions = positions.reverse();
      stack = stack.slice(0, 1).concat(tailRev);
      stack = stack.map(function(p, i) {
        var c, succ;
        c = positions[0];
        p.x = c.x;
        p.y = c.y;
        succ = p.succ;
        p.succ = p.prec;
        p.prec = succ;
        p.at = i;
        positions = positions.slice(1);
        return p;
      });
      return new PointsSegment(stack, this.list);
    };

    return PointsSegment;

  })();

  /*
    Internal representation of a straight line segment
  
    a
     \
      \
       \
        \
         \
          \
           \
            b
  
    I/P:
      a: First point
      b: Second point
  */


  LineSegment = (function() {
    function LineSegment(a, b, source) {
      this.a = a;
      this.b = b;
      this.source = source;
      this.calculate();
    }

    LineSegment.prototype.calculate = function() {
      this.slope = (this.a.y - this.b.y) / (this.b.x - this.a.x);
      this.angle = Math.atan(this.slope) / (Math.PI / 180);
      this.length = Math.sqrt(Math.pow(this.b.x - this.a.x, 2) + Math.pow(this.b.y - this.a.y, 2));
      return this;
    };

    LineSegment.prototype.toString = function() {
      return "(Line segment: " + (this.a.toString()) + " " + (this.b.toString()) + ")";
    };

    LineSegment.prototype.constructorString = function() {
      return "new LineSegment(" + (this.a.constructorString()) + ", " + (this.b.constructorString()) + ")";
    };

    LineSegment.prototype.angle360 = function() {
      return this.b.angle360(this.a);
    };

    LineSegment.prototype.toLineTo = function() {
      return new LineTo(this.b.x, this.b.y);
    };

    LineSegment.prototype.toSVGPoint = function() {
      return this.toLineTo();
    };

    LineSegment.prototype.reverse = function() {
      return new LineSegment(this.b, this.a);
    };

    LineSegment.prototype.bounds = function(useCached) {
      var height, maxx, maxy, minx, miny, width;
      if (useCached == null) {
        useCached = false;
      }
      if ((this.boundsCached != null) && useCached) {
        return this.boundsCached;
      }
      minx = Math.min(this.a.x, this.b.x);
      maxx = Math.max(this.a.x, this.b.x);
      miny = Math.min(this.a.y, this.b.y);
      maxy = Math.max(this.a.y, this.b.y);
      width = this.width();
      height = this.height();
      return this.boundsCached = new Bounds(minx, miny, width, height);
    };

    LineSegment.prototype.boundsCached = void 0;

    LineSegment.prototype.rotate = function(angle, origin) {
      return new LineSegment(this.a.rotate(angle, origin), this.b.rotate(angle, origin));
    };

    LineSegment.prototype.width = function() {
      return Math.abs(this.a.x - this.b.x);
    };

    LineSegment.prototype.height = function() {
      return Math.abs(this.a.y - this.b.y);
    };

    LineSegment.prototype.xRange = function() {
      return new Range(Math.min(this.a.x, this.b.x), Math.max(this.a.x, this.b.x));
    };

    LineSegment.prototype.yRange = function() {
      return new Range(Math.min(this.a.y, this.b.y), Math.max(this.a.y, this.b.y));
    };

    LineSegment.prototype.xDiff = function() {
      return Math.max(this.b.x, this.a.x) - Math.min(this.b.x, this.a.x);
    };

    LineSegment.prototype.xbaDiff = function() {
      return this.b.x - this.a.x;
    };

    LineSegment.prototype.yDiff = function() {
      return Math.max(this.b.y, this.a.y) - Math.min(this.b.y, this.a.y);
    };

    LineSegment.prototype.ybaDiff = function() {
      return this.b.y - this.a.y;
    };

    LineSegment.prototype.yAtX = function(x, extrapolate) {
      if (extrapolate == null) {
        extrapolate = true;
      }
      if (!extrapolate && !this.xRange().containsInclusive(x)) {
        return null;
      }
      return this.a.y + ((x - this.a.x) * this.slope);
    };

    LineSegment.prototype.xAtY = function(y, extrapolate) {
      if (extrapolate == null) {
        extrapolate = true;
      }
      if (!extrapolate && !this.yRange().containsInclusive(y)) {
        return null;
      }
      return this.a.x + ((y - this.a.y) / this.slope);
    };

    LineSegment.prototype.ends = function() {
      return [a, b];
    };

    LineSegment.prototype.posnAtPercent = function(p) {
      return new Posn(this.a.x + (this.b.x - this.a.x) * p, this.a.y + (this.b.y - this.a.y) * p);
    };

    LineSegment.prototype.findPercentageOfPoint = function(p) {
      var xperc, yperc;
      xperc = this.xRange().percentageOfValue(p.x);
      yperc = this.yRange().percentageOfValue(p.y);
      return (xperc + yperc) / 2;
    };

    LineSegment.prototype.splitAt = function(p, forced) {
      var distances, distancesSorted, key, nextA, posn, segments, split, _i, _j, _len, _len1;
      if (forced == null) {
        forced = null;
      }
      if (typeof p === "number") {
        split = forced ? forced : this.posnAtPercent(p);
        return [new LineSegment(this.a, split), new LineSegment(split, this.b)];
      } else if (p instanceof Array) {
        segments = [];
        distances = {};
        for (_i = 0, _len = p.length; _i < _len; _i++) {
          posn = p[_i];
          distances[posn.distanceFrom(this.a)] = posn;
        }
        console.log(distances);
        distancesSorted = Object.keys(distances).sort();
        console.log(distancesSorted);
        nextA = this.a;
        for (_j = 0, _len1 = distancesSorted.length; _j < _len1; _j++) {
          key = distancesSorted[_j];
          posn = distances[key];
          segments.push(new LineSegment(nextA, posn));
          nextA = posn;
        }
        segments.push(new LineSegment(nextA, this.b));
        return segments;
      } else if (p instanceof Posn) {
        return [new LineSegment(this.a, p), new LineSegment(p, this.b)];
      }
    };

    LineSegment.prototype.midPoint = function() {
      return this.splitAt(0.5)[0].b;
    };

    LineSegment.prototype.nudge = function(x, y) {
      this.a.nudge(x, y);
      return this.b.nudge(x, y);
    };

    LineSegment.prototype.scale = function(x, y, origin) {
      this.a.scale(x, y, origin);
      return this.b.scale(x, y, origin);
    };

    LineSegment.prototype.intersects = function(s) {
      var inter;
      inter = this.intersection(s);
      return inter instanceof Posn || inter instanceof Array;
    };

    LineSegment.prototype.intersection = function(s) {
      if (s instanceof LineSegment) {
        return this.intersectionWithLineSegment(s);
      } else if (s instanceof Circle) {
        return this.intersectionWithCircle(s);
      } else if (s instanceof CubicBezier) {
        return s.intersectionWithLineSegment(this);
      }
    };

    LineSegment.prototype.intersectionWithLineSegment = function(s) {
      /*
        Get intersection with another LineSegment
       
        I/P : LineSegment
       
        O/P : If intersection exists, [x, y] coords of intersection
              If none exists, null
              If they're parallel, 0
              If they're coincident, Infinity
       
        Source: http://www.kevlindev.com/gui/math/intersection/Intersection.js
      */

      var ana_m, ana_s, anam, anas, crossDiff;
      ana_s = s.xbaDiff() * (this.a.y - s.a.y) - s.ybaDiff() * (this.a.x - s.a.x);
      ana_m = this.xbaDiff() * (this.a.y - s.a.y) - this.ybaDiff() * (this.a.x - s.a.x);
      crossDiff = s.ybaDiff() * this.xbaDiff() - s.xbaDiff() * this.ybaDiff();
      if (crossDiff !== 0) {
        anas = ana_s / crossDiff;
        anam = ana_m / crossDiff;
        if (0 <= anas && anas <= 1 && 0 <= anam && anam <= 1) {
          return new Posn(this.a.x + anas * (this.b.x - this.a.x), this.a.y + anas * (this.b.y - this.a.y));
        } else {
          return null;
        }
      } else {
        if (ana_s === 0 || ana_m === 0) {
          return Infinity;
        } else {
          return 0;
        }
      }
    };

    LineSegment.prototype.intersectionWithEllipse = function(s) {
      /*
       Get intersection with an ellipse
      
       I/P: Ellipse
      
       O/P: null if no intersections, or Array of Posn(s) if there are
      
        Source: http://www.kevlindev.com/gui/math/intersection/Intersection.js
      */

      var a, b, c, center, cx, cy, d, diff, dir, mDiff, mDir, origin, results, root, rx, ry, t, t_a, t_b;
      rx = s.data.rx;
      ry = s.data.ry;
      cx = s.data.cx;
      cy = s.data.cy;
      origin = new Posn(this.a.x, this.a.y);
      dir = new Posn(this.b.x - this.a.x, this.b.y - this.a.y);
      center = new Posn(cx, cy);
      diff = origin.subtract(center);
      mDir = new Posn(dir.x / (rx * rx), dir.y / (ry * ry));
      mDiff = new Posn(diff.x / (rx * rx), diff.y / (ry * ry));
      results = [];
      a = dir.dot(mDir);
      b = dir.dot(mDiff);
      c = diff.dot(mDiff) - 1.0;
      d = b * b - a * c;
      if (d < 0) {
        return null;
      } else if (d > 0) {
        root = Math.sqrt(d);
        t_a = (-b - root) / a;
        t_b = (-b + root) / a;
        if ((t_a < 0 || 1 < t_a) && (t_b < 0 || 1 < t_b)) {
          if ((t_a < 0 && t_b < 0) && (t_a > 1 && t_b > 1)) {
            return null;
          } else {
            return null;
          }
        } else {
          if (0 <= t_a && t_a <= 1) {
            results.push(this.a.lerp(this.b, t_a));
          }
          if (0 <= t_b && t_b <= 1) {
            results.push(this.a.lerp(this.b, t_b));
          }
        }
      } else {
        t = -b / a;
        if (0 <= t && t <= 1) {
          results.push(this.a.lerp(this.b, t));
        } else {
          return null;
        }
      }
      return results;
    };

    LineSegment.prototype.intersectionWithCircle = function(s) {
      /*
        Get intersection with a circle
       
        I/P : Circle
       
        O/P : If intersection exists, [x, y] coords of intersection
              If none exists, null
              If they're parallel, 0
              If they're coincident, Infinity
       
        Source: http://www.kevlindev.com/gui/math/intersection/Intersection.js
      */

      var a, b, cc, deter, e, ints, u1, u2;
      a = Math.pow(this.xDiff(), 2) + Math.pow(this.yDiff(), 2);
      b = 2 * ((this.b.x - this.a.x) * (this.a.x - s.data.cx) + (this.b.y - this.a.y) * (this.a.y - s.data.cy));
      cc = Math.pow(s.data.cx, 2) + Math.pow(s.data.cy, 2) + Math.pow(this.a.x, 2) + Math.pow(this.a.y, 2) - 2 * (s.data.cx * this.a.x + s.data.cy * this.a.y) - Math.pow(s.data.r, 2);
      deter = b * b - 4 * a * cc;
      if (deter < 0) {
        return null;
      } else if (deter === 0) {
        return 0;
      } else {
        e = Math.sqrt(deter);
        u1 = (-b + e) / (2 * a);
        u2 = (-b - e) / (2 * a);
        if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {
          if ((u1 < 0 && u2 < 0) || (u1 > 1 && u2 > 1)) {
            return null;
          } else {
            return true;
          }
        } else {
          ints = [];
          if (0 <= u1 && u1 <= 1) {
            ints.push(this.a.lerp(this.b, u1));
          }
          if (0 <= u2 && u2 <= 1) {
            ints.push(this.a.lerp(this.b, u2));
          }
          return ints;
        }
      }
    };

    return LineSegment;

  })();

  Ray = (function(_super) {
    __extends(Ray, _super);

    function Ray(a, angle) {
      this.a = a;
      this.angle = angle;
      Ray.__super__.constructor.call(this, this.a, this.a.clone().nudge(0, -1e5).rotate(this.angle, this.a));
    }

    return Ray;

  })(LineSegment);

  /*
    Internal representation of a cubic bezier line segment
  
    p1                                     p4
     o                                     o
      \\                                 //
       \\                               //
        \ \                           / /
         \   \                     /   /
          \     _               _     /
           \      __         __      /
            °       --_____--       °
             p2                    p3
  
    I/P:
      p1: First absolute point, the moveto
      p2: The first point's curve handle
      p3: The second point's curve handle
      p4: The second absolute point
  
      In context with syntax: M[p1]C[p2] [p3] [p4]
  */


  CubicBezier = (function() {
    function CubicBezier(p1, p2, p3, p4, source) {
      this.p1 = p1;
      this.p2 = p2;
      this.p3 = p3;
      this.p4 = p4;
      this.source = source;
    }

    /*
    toString: ->
      "(Cubic bezier: #{@p1},#{@p2},#{@p3},#{@p4})"
    */


    CubicBezier.prototype.toString = function() {
      return "new CubicBezier(" + this.p1 + ", " + this.p2 + ", " + this.p3 + ", " + this.p4 + ")";
    };

    CubicBezier.prototype.toCurveTo = function() {
      return new CurveTo(this.p2.x, this.p2.y, this.p3.x, this.p3.y, this.p4.x, this.p4.y);
    };

    CubicBezier.prototype.toSVGPoint = function() {
      return this.toCurveTo();
    };

    CubicBezier.prototype.nudge = function(x, y) {
      this.p1.nudge(x, y);
      this.p2.nudge(x, y);
      this.p3.nudge(x, y);
      this.p4.nudge(x, y);
      return this;
    };

    CubicBezier.prototype.scale = function(x, y, origin) {
      this.p1.scale(x, y, origin);
      this.p2.scale(x, y, origin);
      this.p3.scale(x, y, origin);
      this.p4.scale(x, y, origin);
      return this;
    };

    CubicBezier.prototype.rotate = function(angle, origin) {
      this.p1.rotate(angle, origin);
      this.p2.rotate(angle, origin);
      this.p3.rotate(angle, origin);
      this.p4.rotate(angle, origin);
      return this;
    };

    CubicBezier.prototype.reverse = function() {
      return new CubicBezier(this.p4, this.p3, this.p2, this.p1);
    };

    CubicBezier.prototype.intersects = function(other) {
      var inter;
      inter = this.intersection(other);
      return inter instanceof Posn || (inter instanceof Array && inter.length > 0);
    };

    CubicBezier.prototype.intersection = function(other) {
      switch (other.constructor) {
        case LineSegment:
          return this.intersectionWithLineSegment(other);
        case CubicBezier:
          return this.intersectionWithCubicBezier(other);
      }
    };

    CubicBezier.prototype.xRange = function() {
      return this.bounds().xr;
    };

    CubicBezier.prototype.yRange = function() {
      return this.bounds().yr;
    };

    CubicBezier.prototype.ends = function() {
      return [this.p1, this.p4];
    };

    CubicBezier.prototype.midPoint = function() {
      return this.splitAt(0.5)[0].p4;
    };

    CubicBezier.prototype.bounds = function(useCached) {
      var d, height, i, maxx, maxy, minx, miny, px, py, qx, qy, rx, ry, sx, sy, top2x, top2y, top3x, top3y, top4x, top4y, toqx, toqy, torx, tory, totx, toty, tx, ty, width, x, y, _i;
      if (useCached == null) {
        useCached = false;
      }
      if ((this.boundsCached != null) && useCached) {
        return this.boundsCached;
      }
      minx = miny = Infinity;
      maxx = maxy = -Infinity;
      top2x = this.p2.x - this.p1.x;
      top2y = this.p2.y - this.p1.y;
      top3x = this.p3.x - this.p2.x;
      top3y = this.p3.y - this.p2.y;
      top4x = this.p4.x - this.p3.x;
      top4y = this.p4.y - this.p3.y;
      for (i = _i = 0; _i <= 40; i = ++_i) {
        d = i / 40;
        px = this.p1.x + d * top2x;
        py = this.p1.y + d * top2y;
        qx = this.p2.x + d * top3x;
        qy = this.p2.y + d * top3y;
        rx = this.p3.x + d * top4x;
        ry = this.p3.y + d * top4y;
        toqx = qx - px;
        toqy = qy - py;
        torx = rx - qx;
        tory = ry - qy;
        sx = px + d * toqx;
        sy = py + d * toqy;
        tx = qx + d * torx;
        ty = qy + d * tory;
        totx = tx - sx;
        toty = ty - sy;
        x = sx + d * totx;
        y = sy + d * toty;
        minx = Math.min(minx, x);
        miny = Math.min(miny, y);
        maxx = Math.max(maxx, x);
        maxy = Math.max(maxy, y);
        width = maxx - minx;
        height = maxy - miny;
      }
      return this.boundsCached = new Bounds(minx, miny, width, height);
    };

    CubicBezier.prototype.boundsCached = void 0;

    CubicBezier.prototype.intoLineSegments = function(n) {
      var i, last, m, segments, x, y, _i;
      segments = [];
      for (m = _i = 0; 0 <= n ? _i <= n : _i >= n; m = 0 <= n ? ++_i : --_i) {
        i = 1 / m;
        x = Math.pow(1 - i, 3) * this.p1.x + 3 * Math.pow(1 - i, 2) * i * this.p2.x + 3 * (1 - i) * Math.pow(i, 2) * this.p3.x + Math.pow(i, 3) * this.p4.x;
        y = Math.pow(1 - i, 3) * this.p1.y + 3 * Math.pow(1 - i, 2) * i * this.p2.y + 3 * (1 - i) * Math.pow(i, 2) * this.p3.y + Math.pow(i, 3) * this.p4.y;
        if (m % 2 === 0) {
          last = new Posn(x, y);
        } else {
          segments.push(new LineSegment(last, new Posn(x, y)));
        }
      }
      return segments.splice(1);
    };

    CubicBezier.prototype.splitAt = function(t, force) {
      var p10, p5, p6, p7, p8, p9, pair, perc, percent, percentages, posn, segments, sortedPosns, tail, _i, _j, _len, _len1;
      if (force == null) {
        force = null;
      }
      if (typeof t === "number") {
        p5 = new LineSegment(this.p1, this.p2).posnAtPercent(t);
        p6 = new LineSegment(this.p2, this.p3).posnAtPercent(t);
        p7 = new LineSegment(this.p3, this.p4).posnAtPercent(t);
        p8 = new LineSegment(p5, p6).posnAtPercent(t);
        p9 = new LineSegment(p6, p7).posnAtPercent(t);
        p10 = force ? force : new LineSegment(p8, p9).posnAtPercent(t);
        return [new CubicBezier(this.p1, p5, p8, p10), new CubicBezier(p10, p9, p7, this.p4)];
      } else if (t instanceof Posn) {
        return this.splitAt(this.findPercentageOfPoint(t), t);
      } else if (t instanceof Array) {
        sortedPosns = {};
        segments = [];
        for (_i = 0, _len = t.length; _i < _len; _i++) {
          posn = t[_i];
          percent = this.findPercentageOfPoint(posn);
          sortedPosns[percent] = posn;
        }
        percentages = Object.keys(sortedPosns).sort().map(parseFloat);
        tail = this;
        for (_j = 0, _len1 = percentages.length; _j < _len1; _j++) {
          perc = percentages[_j];
          pair = tail.splitAt(sortedPosns[perc]);
          segments.push(pair[0]);
          tail = pair[1];
        }
        segments.push(tail);
        return segments;
      }
    };

    CubicBezier.prototype.findPercentageOfPoint = function(posn, tolerance, accumulated, nextstep) {
      var a, ab, ac, b, bb, bc, split;
      if (tolerance == null) {
        tolerance = 1e-3;
      }
      if (accumulated == null) {
        accumulated = 0.0;
      }
      if (nextstep == null) {
        nextstep = 0.5;
      }
      split = this.splitAt(0.5);
      a = split[0];
      b = split[1];
      if (a.p4.within(tolerance, posn) || nextstep < 1e-4) {
        return accumulated;
      }
      ab = a.bounds();
      bb = b.bounds();
      if (ab.xr.containsInclusive(posn.x, 0.2) && ab.yr.containsInclusive(posn.y, 0.2)) {
        ac = a.findPercentageOfPoint(posn, tolerance, accumulated, nextstep / 2);
      }
      if (bb.xr.containsInclusive(posn.x, 0.2) && bb.yr.containsInclusive(posn.y, 0.2)) {
        bc = b.findPercentageOfPoint(posn, tolerance, accumulated + nextstep, nextstep / 2);
      }
      if (ac != null) {
        return ac;
      } else if (bc != null) {
        return bc;
      } else {
        return accumulated;
      }
    };

    /*
    
      Intersection methods
    */


    CubicBezier.prototype.intersectionWithLineSegment = function(l) {
      /*
      
        Given a LineSegment, lists intersection point(s).
      
        I/P: LineSegment
        O/P: Array of Posns
        
        I am a cute sick Kate Whiper Snapper
        i love monodebe and I learn all about the flexible scemless data base
      
        Disclaimer: I don't really understand this but it passes my tests.
      */

      var a, b, c, c0, c1, c2, c3, cl, d, i, max, min, n, p10, p5, p6, p7, p8, p9, results, roots, t;
      min = l.a.min(l.b);
      max = l.a.max(l.b);
      results = [];
      a = this.p1.multiplyBy(-1);
      b = this.p2.multiplyBy(3);
      c = this.p3.multiplyBy(-3);
      d = a.add(b.add(c.add(this.p4)));
      c3 = new Posn(d.x, d.y);
      a = this.p1.multiplyBy(3);
      b = this.p2.multiplyBy(-6);
      c = this.p3.multiplyBy(3);
      d = a.add(b.add(c));
      c2 = new Posn(d.x, d.y);
      a = this.p1.multiplyBy(-3);
      b = this.p2.multiplyBy(3);
      c = a.add(b);
      c1 = new Posn(c.x, c.y);
      c0 = new Posn(this.p1.x, this.p1.y);
      n = new Posn(l.a.y - l.b.y, l.b.x - l.a.x);
      cl = l.a.x * l.b.y - l.b.x * l.a.y;
      roots = new Polynomial([n.dot(c3), n.dot(c2), n.dot(c1), n.dot(c0) + cl]).roots();
      for (i in roots) {
        t = roots[i];
        if (0 <= t && t <= 1) {
          p5 = this.p1.lerp(this.p2, t);
          p6 = this.p2.lerp(this.p3, t);
          p7 = this.p3.lerp(this.p4, t);
          p8 = p5.lerp(p6, t);
          p9 = p6.lerp(p7, t);
          p10 = p8.lerp(p9, t);
          if (l.a.x === l.b.x) {
            if ((min.y <= p10.y) && (p10.y <= max.y)) {
              results.push(p10);
            }
          } else if (l.a.y === l.b.y) {
            if (min.x <= p10.x && p10.x <= max.x) {
              results.push(p10);
            }
          } else if (p10.gte(min) && p10.lte(max)) {
            results.push(p10);
          }
        }
      }
      return results;
    };

    CubicBezier.prototype.intersectionWithCubicBezier = function(other) {
      var a, b, c, c10, c10x2, c10x3, c10y2, c10y3, c11, c11x2, c11x3, c11y2, c11y3, c12, c12x2, c12x3, c12y2, c12y3, c13, c13x2, c13x3, c13y2, c13y3, c20, c20x2, c20x3, c20y2, c20y3, c21, c21x2, c21x3, c21y2, c22, c22x2, c22x3, c22y2, c23, c23x2, c23x3, c23y2, c23y3, d, i, j, k, poly, results, roots, s, stop, tolerance, xRoot, xRoots, yRoot, yRoots;
      results = [];
      a = this.p1.multiplyBy(-1);
      b = this.p2.multiplyBy(3);
      c = this.p3.multiplyBy(-3);
      d = a.add(b.add(c.add(this.p4)));
      c13 = new Posn(d.x, d.y);
      a = this.p1.multiplyBy(3);
      b = this.p2.multiplyBy(-6);
      c = this.p3.multiplyBy(3);
      d = a.add(b.add(c));
      c12 = new Posn(d.x, d.y);
      a = this.p1.multiplyBy(-3);
      b = this.p2.multiplyBy(3);
      c = a.add(b);
      c11 = new Posn(c.x, c.y);
      c10 = new Posn(this.p1.x, this.p1.y);
      a = other.p1.multiplyBy(-1);
      b = other.p2.multiplyBy(3);
      c = other.p3.multiplyBy(-3);
      d = a.add(b.add(c.add(other.p4)));
      c23 = new Posn(d.x, d.y);
      a = other.p1.multiplyBy(3);
      b = other.p2.multiplyBy(-6);
      c = other.p3.multiplyBy(3);
      d = a.add(b.add(c));
      c22 = new Posn(d.x, d.y);
      a = other.p1.multiplyBy(-3);
      b = other.p2.multiplyBy(3);
      c = a.add(b);
      c21 = new Posn(c.x, c.y);
      c20 = new Posn(other.p1.x, other.p1.y);
      c10x2 = c10.x * c10.x;
      c10x3 = c10.x * c10.x * c10.x;
      c10y2 = c10.y * c10.y;
      c10y3 = c10.y * c10.y * c10.y;
      c11x2 = c11.x * c11.x;
      c11x3 = c11.x * c11.x * c11.x;
      c11y2 = c11.y * c11.y;
      c11y3 = c11.y * c11.y * c11.y;
      c12x2 = c12.x * c12.x;
      c12x3 = c12.x * c12.x * c12.x;
      c12y2 = c12.y * c12.y;
      c12y3 = c12.y * c12.y * c12.y;
      c13x2 = c13.x * c13.x;
      c13x3 = c13.x * c13.x * c13.x;
      c13y2 = c13.y * c13.y;
      c13y3 = c13.y * c13.y * c13.y;
      c20x2 = c20.x * c20.x;
      c20x3 = c20.x * c20.x * c20.x;
      c20y2 = c20.y * c20.y;
      c20y3 = c20.y * c20.y * c20.y;
      c21x2 = c21.x * c21.x;
      c21x3 = c21.x * c21.x * c21.x;
      c21y2 = c21.y * c21.y;
      c22x2 = c22.x * c22.x;
      c22x3 = c22.x * c22.x * c22.x;
      c22y2 = c22.y * c22.y;
      c23x2 = c23.x * c23.x;
      c23x3 = c23.x * c23.x * c23.x;
      c23y2 = c23.y * c23.y;
      c23y3 = c23.y * c23.y * c23.y;
      poly = new Polynomial([-c13x3 * c23y3 + c13y3 * c23x3 - 3 * c13.x * c13y2 * c23x2 * c23.y + 3 * c13x2 * c13.y * c23.x * c23y2, -6 * c13.x * c22.x * c13y2 * c23.x * c23.y + 6 * c13x2 * c13.y * c22.y * c23.x * c23.y + 3 * c22.x * c13y3 * c23x2 - 3 * c13x3 * c22.y * c23y2 - 3 * c13.x * c13y2 * c22.y * c23x2 + 3 * c13x2 * c22.x * c13.y * c23y2, -6 * c21.x * c13.x * c13y2 * c23.x * c23.y - 6 * c13.x * c22.x * c13y2 * c22.y * c23.x + 6 * c13x2 * c22.x * c13.y * c22.y * c23.y + 3 * c21.x * c13y3 * c23x2 + 3 * c22x2 * c13y3 * c23.x + 3 * c21.x * c13x2 * c13.y * c23y2 - 3 * c13.x * c21.y * c13y2 * c23x2 - 3 * c13.x * c22x2 * c13y2 * c23.y + c13x2 * c13.y * c23.x * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-c21.y * c23y2 - 2 * c22y2 * c23.y - c23.y * (2 * c21.y * c23.y + c22y2)), c11.x * c12.y * c13.x * c13.y * c23.x * c23.y - c11.y * c12.x * c13.x * c13.y * c23.x * c23.y + 6 * c21.x * c22.x * c13y3 * c23.x + 3 * c11.x * c12.x * c13.x * c13.y * c23y2 + 6 * c10.x * c13.x * c13y2 * c23.x * c23.y - 3 * c11.x * c12.x * c13y2 * c23.x * c23.y - 3 * c11.y * c12.y * c13.x * c13.y * c23x2 - 6 * c10.y * c13x2 * c13.y * c23.x * c23.y - 6 * c20.x * c13.x * c13y2 * c23.x * c23.y + 3 * c11.y * c12.y * c13x2 * c23.x * c23.y - 2 * c12.x * c12y2 * c13.x * c23.x * c23.y - 6 * c21.x * c13.x * c22.x * c13y2 * c23.y - 6 * c21.x * c13.x * c13y2 * c22.y * c23.x - 6 * c13.x * c21.y * c22.x * c13y2 * c23.x + 6 * c21.x * c13x2 * c13.y * c22.y * c23.y + 2 * c12x2 * c12.y * c13.y * c23.x * c23.y + c22x3 * c13y3 - 3 * c10.x * c13y3 * c23x2 + 3 * c10.y * c13x3 * c23y2 + 3 * c20.x * c13y3 * c23x2 + c12y3 * c13.x * c23x2 - c12x3 * c13.y * c23y2 - 3 * c10.x * c13x2 * c13.y * c23y2 + 3 * c10.y * c13.x * c13y2 * c23x2 - 2 * c11.x * c12.y * c13x2 * c23y2 + c11.x * c12.y * c13y2 * c23x2 - c11.y * c12.x * c13x2 * c23y2 + 2 * c11.y * c12.x * c13y2 * c23x2 + 3 * c20.x * c13x2 * c13.y * c23y2 - c12.x * c12y2 * c13.y * c23x2 - 3 * c20.y * c13.x * c13y2 * c23x2 + c12x2 * c12.y * c13.x * c23y2 - 3 * c13.x * c22x2 * c13y2 * c22.y + c13x2 * c13.y * c23.x * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c13x2 * c22.x * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c21.y * c22.y * c23.y - c20.y * c23y2 - c22.y * (2 * c21.y * c23.y + c22y2) - c23.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), 6 * c11.x * c12.x * c13.x * c13.y * c22.y * c23.y + c11.x * c12.y * c13.x * c22.x * c13.y * c23.y + c11.x * c12.y * c13.x * c13.y * c22.y * c23.x - c11.y * c12.x * c13.x * c22.x * c13.y * c23.y - c11.y * c12.x * c13.x * c13.y * c22.y * c23.x - 6 * c11.y * c12.y * c13.x * c22.x * c13.y * c23.x - 6 * c10.x * c22.x * c13y3 * c23.x + 6 * c20.x * c22.x * c13y3 * c23.x + 6 * c10.y * c13x3 * c22.y * c23.y + 2 * c12y3 * c13.x * c22.x * c23.x - 2 * c12x3 * c13.y * c22.y * c23.y + 6 * c10.x * c13.x * c22.x * c13y2 * c23.y + 6 * c10.x * c13.x * c13y2 * c22.y * c23.x + 6 * c10.y * c13.x * c22.x * c13y2 * c23.x - 3 * c11.x * c12.x * c22.x * c13y2 * c23.y - 3 * c11.x * c12.x * c13y2 * c22.y * c23.x + 2 * c11.x * c12.y * c22.x * c13y2 * c23.x + 4 * c11.y * c12.x * c22.x * c13y2 * c23.x - 6 * c10.x * c13x2 * c13.y * c22.y * c23.y - 6 * c10.y * c13x2 * c22.x * c13.y * c23.y - 6 * c10.y * c13x2 * c13.y * c22.y * c23.x - 4 * c11.x * c12.y * c13x2 * c22.y * c23.y - 6 * c20.x * c13.x * c22.x * c13y2 * c23.y - 6 * c20.x * c13.x * c13y2 * c22.y * c23.x - 2 * c11.y * c12.x * c13x2 * c22.y * c23.y + 3 * c11.y * c12.y * c13x2 * c22.x * c23.y + 3 * c11.y * c12.y * c13x2 * c22.y * c23.x - 2 * c12.x * c12y2 * c13.x * c22.x * c23.y - 2 * c12.x * c12y2 * c13.x * c22.y * c23.x - 2 * c12.x * c12y2 * c22.x * c13.y * c23.x - 6 * c20.y * c13.x * c22.x * c13y2 * c23.x - 6 * c21.x * c13.x * c21.y * c13y2 * c23.x - 6 * c21.x * c13.x * c22.x * c13y2 * c22.y + 6 * c20.x * c13x2 * c13.y * c22.y * c23.y + 2 * c12x2 * c12.y * c13.x * c22.y * c23.y + 2 * c12x2 * c12.y * c22.x * c13.y * c23.y + 2 * c12x2 * c12.y * c13.y * c22.y * c23.x + 3 * c21.x * c22x2 * c13y3 + 3 * c21x2 * c13y3 * c23.x - 3 * c13.x * c21.y * c22x2 * c13y2 - 3 * c21x2 * c13.x * c13y2 * c23.y + c13x2 * c22.x * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c13x2 * c13.y * c23.x * (6 * c20.y * c22.y + 3 * c21y2) + c21.x * c13x2 * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c20.y * c22.y * c23.y - c23.y * (2 * c20.y * c22.y + c21y2) - c21.y * (2 * c21.y * c23.y + c22y2) - c22.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), c11.x * c21.x * c12.y * c13.x * c13.y * c23.y + c11.x * c12.y * c13.x * c21.y * c13.y * c23.x + c11.x * c12.y * c13.x * c22.x * c13.y * c22.y - c11.y * c12.x * c21.x * c13.x * c13.y * c23.y - c11.y * c12.x * c13.x * c21.y * c13.y * c23.x - c11.y * c12.x * c13.x * c22.x * c13.y * c22.y - 6 * c11.y * c21.x * c12.y * c13.x * c13.y * c23.x - 6 * c10.x * c21.x * c13y3 * c23.x + 6 * c20.x * c21.x * c13y3 * c23.x + 2 * c21.x * c12y3 * c13.x * c23.x + 6 * c10.x * c21.x * c13.x * c13y2 * c23.y + 6 * c10.x * c13.x * c21.y * c13y2 * c23.x + 6 * c10.x * c13.x * c22.x * c13y2 * c22.y + 6 * c10.y * c21.x * c13.x * c13y2 * c23.x - 3 * c11.x * c12.x * c21.x * c13y2 * c23.y - 3 * c11.x * c12.x * c21.y * c13y2 * c23.x - 3 * c11.x * c12.x * c22.x * c13y2 * c22.y + 2 * c11.x * c21.x * c12.y * c13y2 * c23.x + 4 * c11.y * c12.x * c21.x * c13y2 * c23.x - 6 * c10.y * c21.x * c13x2 * c13.y * c23.y - 6 * c10.y * c13x2 * c21.y * c13.y * c23.x - 6 * c10.y * c13x2 * c22.x * c13.y * c22.y - 6 * c20.x * c21.x * c13.x * c13y2 * c23.y - 6 * c20.x * c13.x * c21.y * c13y2 * c23.x - 6 * c20.x * c13.x * c22.x * c13y2 * c22.y + 3 * c11.y * c21.x * c12.y * c13x2 * c23.y - 3 * c11.y * c12.y * c13.x * c22x2 * c13.y + 3 * c11.y * c12.y * c13x2 * c21.y * c23.x + 3 * c11.y * c12.y * c13x2 * c22.x * c22.y - 2 * c12.x * c21.x * c12y2 * c13.x * c23.y - 2 * c12.x * c21.x * c12y2 * c13.y * c23.x - 2 * c12.x * c12y2 * c13.x * c21.y * c23.x - 2 * c12.x * c12y2 * c13.x * c22.x * c22.y - 6 * c20.y * c21.x * c13.x * c13y2 * c23.x - 6 * c21.x * c13.x * c21.y * c22.x * c13y2 + 6 * c20.y * c13x2 * c21.y * c13.y * c23.x + 2 * c12x2 * c21.x * c12.y * c13.y * c23.y + 2 * c12x2 * c12.y * c21.y * c13.y * c23.x + 2 * c12x2 * c12.y * c22.x * c13.y * c22.y - 3 * c10.x * c22x2 * c13y3 + 3 * c20.x * c22x2 * c13y3 + 3 * c21x2 * c22.x * c13y3 + c12y3 * c13.x * c22x2 + 3 * c10.y * c13.x * c22x2 * c13y2 + c11.x * c12.y * c22x2 * c13y2 + 2 * c11.y * c12.x * c22x2 * c13y2 - c12.x * c12y2 * c22x2 * c13.y - 3 * c20.y * c13.x * c22x2 * c13y2 - 3 * c21x2 * c13.x * c13y2 * c22.y + c12x2 * c12.y * c13.x * (2 * c21.y * c23.y + c22y2) + c11.x * c12.x * c13.x * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c21.x * c13x2 * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c12x3 * c13.y * (-2 * c21.y * c23.y - c22y2) + c10.y * c13x3 * (6 * c21.y * c23.y + 3 * c22y2) + c11.y * c12.x * c13x2 * (-2 * c21.y * c23.y - c22y2) + c11.x * c12.y * c13x2 * (-4 * c21.y * c23.y - 2 * c22y2) + c10.x * c13x2 * c13.y * (-6 * c21.y * c23.y - 3 * c22y2) + c13x2 * c22.x * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c20.x * c13x2 * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c20.y * c21.y * c23.y - c22.y * (2 * c20.y * c22.y + c21y2) - c20.y * (2 * c21.y * c23.y + c22y2) - c21.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), -c10.x * c11.x * c12.y * c13.x * c13.y * c23.y + c10.x * c11.y * c12.x * c13.x * c13.y * c23.y + 6 * c10.x * c11.y * c12.y * c13.x * c13.y * c23.x - 6 * c10.y * c11.x * c12.x * c13.x * c13.y * c23.y - c10.y * c11.x * c12.y * c13.x * c13.y * c23.x + c10.y * c11.y * c12.x * c13.x * c13.y * c23.x + c11.x * c11.y * c12.x * c12.y * c13.x * c23.y - c11.x * c11.y * c12.x * c12.y * c13.y * c23.x + c11.x * c20.x * c12.y * c13.x * c13.y * c23.y + c11.x * c20.y * c12.y * c13.x * c13.y * c23.x + c11.x * c21.x * c12.y * c13.x * c13.y * c22.y + c11.x * c12.y * c13.x * c21.y * c22.x * c13.y - c20.x * c11.y * c12.x * c13.x * c13.y * c23.y - 6 * c20.x * c11.y * c12.y * c13.x * c13.y * c23.x - c11.y * c12.x * c20.y * c13.x * c13.y * c23.x - c11.y * c12.x * c21.x * c13.x * c13.y * c22.y - c11.y * c12.x * c13.x * c21.y * c22.x * c13.y - 6 * c11.y * c21.x * c12.y * c13.x * c22.x * c13.y - 6 * c10.x * c20.x * c13y3 * c23.x - 6 * c10.x * c21.x * c22.x * c13y3 - 2 * c10.x * c12y3 * c13.x * c23.x + 6 * c20.x * c21.x * c22.x * c13y3 + 2 * c20.x * c12y3 * c13.x * c23.x + 2 * c21.x * c12y3 * c13.x * c22.x + 2 * c10.y * c12x3 * c13.y * c23.y - 6 * c10.x * c10.y * c13.x * c13y2 * c23.x + 3 * c10.x * c11.x * c12.x * c13y2 * c23.y - 2 * c10.x * c11.x * c12.y * c13y2 * c23.x - 4 * c10.x * c11.y * c12.x * c13y2 * c23.x + 3 * c10.y * c11.x * c12.x * c13y2 * c23.x + 6 * c10.x * c10.y * c13x2 * c13.y * c23.y + 6 * c10.x * c20.x * c13.x * c13y2 * c23.y - 3 * c10.x * c11.y * c12.y * c13x2 * c23.y + 2 * c10.x * c12.x * c12y2 * c13.x * c23.y + 2 * c10.x * c12.x * c12y2 * c13.y * c23.x + 6 * c10.x * c20.y * c13.x * c13y2 * c23.x + 6 * c10.x * c21.x * c13.x * c13y2 * c22.y + 6 * c10.x * c13.x * c21.y * c22.x * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c23.y + 6 * c10.y * c20.x * c13.x * c13y2 * c23.x + 2 * c10.y * c11.y * c12.x * c13x2 * c23.y - 3 * c10.y * c11.y * c12.y * c13x2 * c23.x + 2 * c10.y * c12.x * c12y2 * c13.x * c23.x + 6 * c10.y * c21.x * c13.x * c22.x * c13y2 - 3 * c11.x * c20.x * c12.x * c13y2 * c23.y + 2 * c11.x * c20.x * c12.y * c13y2 * c23.x + c11.x * c11.y * c12y2 * c13.x * c23.x - 3 * c11.x * c12.x * c20.y * c13y2 * c23.x - 3 * c11.x * c12.x * c21.x * c13y2 * c22.y - 3 * c11.x * c12.x * c21.y * c22.x * c13y2 + 2 * c11.x * c21.x * c12.y * c22.x * c13y2 + 4 * c20.x * c11.y * c12.x * c13y2 * c23.x + 4 * c11.y * c12.x * c21.x * c22.x * c13y2 - 2 * c10.x * c12x2 * c12.y * c13.y * c23.y - 6 * c10.y * c20.x * c13x2 * c13.y * c23.y - 6 * c10.y * c20.y * c13x2 * c13.y * c23.x - 6 * c10.y * c21.x * c13x2 * c13.y * c22.y - 2 * c10.y * c12x2 * c12.y * c13.x * c23.y - 2 * c10.y * c12x2 * c12.y * c13.y * c23.x - 6 * c10.y * c13x2 * c21.y * c22.x * c13.y - c11.x * c11.y * c12x2 * c13.y * c23.y - 2 * c11.x * c11y2 * c13.x * c13.y * c23.x + 3 * c20.x * c11.y * c12.y * c13x2 * c23.y - 2 * c20.x * c12.x * c12y2 * c13.x * c23.y - 2 * c20.x * c12.x * c12y2 * c13.y * c23.x - 6 * c20.x * c20.y * c13.x * c13y2 * c23.x - 6 * c20.x * c21.x * c13.x * c13y2 * c22.y - 6 * c20.x * c13.x * c21.y * c22.x * c13y2 + 3 * c11.y * c20.y * c12.y * c13x2 * c23.x + 3 * c11.y * c21.x * c12.y * c13x2 * c22.y + 3 * c11.y * c12.y * c13x2 * c21.y * c22.x - 2 * c12.x * c20.y * c12y2 * c13.x * c23.x - 2 * c12.x * c21.x * c12y2 * c13.x * c22.y - 2 * c12.x * c21.x * c12y2 * c22.x * c13.y - 2 * c12.x * c12y2 * c13.x * c21.y * c22.x - 6 * c20.y * c21.x * c13.x * c22.x * c13y2 - c11y2 * c12.x * c12.y * c13.x * c23.x + 2 * c20.x * c12x2 * c12.y * c13.y * c23.y + 6 * c20.y * c13x2 * c21.y * c22.x * c13.y + 2 * c11x2 * c11.y * c13.x * c13.y * c23.y + c11x2 * c12.x * c12.y * c13.y * c23.y + 2 * c12x2 * c20.y * c12.y * c13.y * c23.x + 2 * c12x2 * c21.x * c12.y * c13.y * c22.y + 2 * c12x2 * c12.y * c21.y * c22.x * c13.y + c21x3 * c13y3 + 3 * c10x2 * c13y3 * c23.x - 3 * c10y2 * c13x3 * c23.y + 3 * c20x2 * c13y3 * c23.x + c11y3 * c13x2 * c23.x - c11x3 * c13y2 * c23.y - c11.x * c11y2 * c13x2 * c23.y + c11x2 * c11.y * c13y2 * c23.x - 3 * c10x2 * c13.x * c13y2 * c23.y + 3 * c10y2 * c13x2 * c13.y * c23.x - c11x2 * c12y2 * c13.x * c23.y + c11y2 * c12x2 * c13.y * c23.x - 3 * c21x2 * c13.x * c21.y * c13y2 - 3 * c20x2 * c13.x * c13y2 * c23.y + 3 * c20y2 * c13x2 * c13.y * c23.x + c11.x * c12.x * c13.x * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c12x3 * c13.y * (-2 * c20.y * c23.y - 2 * c21.y * c22.y) + c10.y * c13x3 * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c11.y * c12.x * c13x2 * (-2 * c20.y * c23.y - 2 * c21.y * c22.y) + c12x2 * c12.y * c13.x * (2 * c20.y * c23.y + 2 * c21.y * c22.y) + c11.x * c12.y * c13x2 * (-4 * c20.y * c23.y - 4 * c21.y * c22.y) + c10.x * c13x2 * c13.y * (-6 * c20.y * c23.y - 6 * c21.y * c22.y) + c20.x * c13x2 * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c21.x * c13x2 * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c13x3 * (-2 * c20.y * c21.y * c22.y - c20y2 * c23.y - c21.y * (2 * c20.y * c22.y + c21y2) - c20.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), -c10.x * c11.x * c12.y * c13.x * c13.y * c22.y + c10.x * c11.y * c12.x * c13.x * c13.y * c22.y + 6 * c10.x * c11.y * c12.y * c13.x * c22.x * c13.y - 6 * c10.y * c11.x * c12.x * c13.x * c13.y * c22.y - c10.y * c11.x * c12.y * c13.x * c22.x * c13.y + c10.y * c11.y * c12.x * c13.x * c22.x * c13.y + c11.x * c11.y * c12.x * c12.y * c13.x * c22.y - c11.x * c11.y * c12.x * c12.y * c22.x * c13.y + c11.x * c20.x * c12.y * c13.x * c13.y * c22.y + c11.x * c20.y * c12.y * c13.x * c22.x * c13.y + c11.x * c21.x * c12.y * c13.x * c21.y * c13.y - c20.x * c11.y * c12.x * c13.x * c13.y * c22.y - 6 * c20.x * c11.y * c12.y * c13.x * c22.x * c13.y - c11.y * c12.x * c20.y * c13.x * c22.x * c13.y - c11.y * c12.x * c21.x * c13.x * c21.y * c13.y - 6 * c10.x * c20.x * c22.x * c13y3 - 2 * c10.x * c12y3 * c13.x * c22.x + 2 * c20.x * c12y3 * c13.x * c22.x + 2 * c10.y * c12x3 * c13.y * c22.y - 6 * c10.x * c10.y * c13.x * c22.x * c13y2 + 3 * c10.x * c11.x * c12.x * c13y2 * c22.y - 2 * c10.x * c11.x * c12.y * c22.x * c13y2 - 4 * c10.x * c11.y * c12.x * c22.x * c13y2 + 3 * c10.y * c11.x * c12.x * c22.x * c13y2 + 6 * c10.x * c10.y * c13x2 * c13.y * c22.y + 6 * c10.x * c20.x * c13.x * c13y2 * c22.y - 3 * c10.x * c11.y * c12.y * c13x2 * c22.y + 2 * c10.x * c12.x * c12y2 * c13.x * c22.y + 2 * c10.x * c12.x * c12y2 * c22.x * c13.y + 6 * c10.x * c20.y * c13.x * c22.x * c13y2 + 6 * c10.x * c21.x * c13.x * c21.y * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c22.y + 6 * c10.y * c20.x * c13.x * c22.x * c13y2 + 2 * c10.y * c11.y * c12.x * c13x2 * c22.y - 3 * c10.y * c11.y * c12.y * c13x2 * c22.x + 2 * c10.y * c12.x * c12y2 * c13.x * c22.x - 3 * c11.x * c20.x * c12.x * c13y2 * c22.y + 2 * c11.x * c20.x * c12.y * c22.x * c13y2 + c11.x * c11.y * c12y2 * c13.x * c22.x - 3 * c11.x * c12.x * c20.y * c22.x * c13y2 - 3 * c11.x * c12.x * c21.x * c21.y * c13y2 + 4 * c20.x * c11.y * c12.x * c22.x * c13y2 - 2 * c10.x * c12x2 * c12.y * c13.y * c22.y - 6 * c10.y * c20.x * c13x2 * c13.y * c22.y - 6 * c10.y * c20.y * c13x2 * c22.x * c13.y - 6 * c10.y * c21.x * c13x2 * c21.y * c13.y - 2 * c10.y * c12x2 * c12.y * c13.x * c22.y - 2 * c10.y * c12x2 * c12.y * c22.x * c13.y - c11.x * c11.y * c12x2 * c13.y * c22.y - 2 * c11.x * c11y2 * c13.x * c22.x * c13.y + 3 * c20.x * c11.y * c12.y * c13x2 * c22.y - 2 * c20.x * c12.x * c12y2 * c13.x * c22.y - 2 * c20.x * c12.x * c12y2 * c22.x * c13.y - 6 * c20.x * c20.y * c13.x * c22.x * c13y2 - 6 * c20.x * c21.x * c13.x * c21.y * c13y2 + 3 * c11.y * c20.y * c12.y * c13x2 * c22.x + 3 * c11.y * c21.x * c12.y * c13x2 * c21.y - 2 * c12.x * c20.y * c12y2 * c13.x * c22.x - 2 * c12.x * c21.x * c12y2 * c13.x * c21.y - c11y2 * c12.x * c12.y * c13.x * c22.x + 2 * c20.x * c12x2 * c12.y * c13.y * c22.y - 3 * c11.y * c21x2 * c12.y * c13.x * c13.y + 6 * c20.y * c21.x * c13x2 * c21.y * c13.y + 2 * c11x2 * c11.y * c13.x * c13.y * c22.y + c11x2 * c12.x * c12.y * c13.y * c22.y + 2 * c12x2 * c20.y * c12.y * c22.x * c13.y + 2 * c12x2 * c21.x * c12.y * c21.y * c13.y - 3 * c10.x * c21x2 * c13y3 + 3 * c20.x * c21x2 * c13y3 + 3 * c10x2 * c22.x * c13y3 - 3 * c10y2 * c13x3 * c22.y + 3 * c20x2 * c22.x * c13y3 + c21x2 * c12y3 * c13.x + c11y3 * c13x2 * c22.x - c11x3 * c13y2 * c22.y + 3 * c10.y * c21x2 * c13.x * c13y2 - c11.x * c11y2 * c13x2 * c22.y + c11.x * c21x2 * c12.y * c13y2 + 2 * c11.y * c12.x * c21x2 * c13y2 + c11x2 * c11.y * c22.x * c13y2 - c12.x * c21x2 * c12y2 * c13.y - 3 * c20.y * c21x2 * c13.x * c13y2 - 3 * c10x2 * c13.x * c13y2 * c22.y + 3 * c10y2 * c13x2 * c22.x * c13.y - c11x2 * c12y2 * c13.x * c22.y + c11y2 * c12x2 * c22.x * c13.y - 3 * c20x2 * c13.x * c13y2 * c22.y + 3 * c20y2 * c13x2 * c22.x * c13.y + c12x2 * c12.y * c13.x * (2 * c20.y * c22.y + c21y2) + c11.x * c12.x * c13.x * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c12x3 * c13.y * (-2 * c20.y * c22.y - c21y2) + c10.y * c13x3 * (6 * c20.y * c22.y + 3 * c21y2) + c11.y * c12.x * c13x2 * (-2 * c20.y * c22.y - c21y2) + c11.x * c12.y * c13x2 * (-4 * c20.y * c22.y - 2 * c21y2) + c10.x * c13x2 * c13.y * (-6 * c20.y * c22.y - 3 * c21y2) + c20.x * c13x2 * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c13x3 * (-2 * c20.y * c21y2 - c20y2 * c22.y - c20.y * (2 * c20.y * c22.y + c21y2)), -c10.x * c11.x * c12.y * c13.x * c21.y * c13.y + c10.x * c11.y * c12.x * c13.x * c21.y * c13.y + 6 * c10.x * c11.y * c21.x * c12.y * c13.x * c13.y - 6 * c10.y * c11.x * c12.x * c13.x * c21.y * c13.y - c10.y * c11.x * c21.x * c12.y * c13.x * c13.y + c10.y * c11.y * c12.x * c21.x * c13.x * c13.y - c11.x * c11.y * c12.x * c21.x * c12.y * c13.y + c11.x * c11.y * c12.x * c12.y * c13.x * c21.y + c11.x * c20.x * c12.y * c13.x * c21.y * c13.y + 6 * c11.x * c12.x * c20.y * c13.x * c21.y * c13.y + c11.x * c20.y * c21.x * c12.y * c13.x * c13.y - c20.x * c11.y * c12.x * c13.x * c21.y * c13.y - 6 * c20.x * c11.y * c21.x * c12.y * c13.x * c13.y - c11.y * c12.x * c20.y * c21.x * c13.x * c13.y - 6 * c10.x * c20.x * c21.x * c13y3 - 2 * c10.x * c21.x * c12y3 * c13.x + 6 * c10.y * c20.y * c13x3 * c21.y + 2 * c20.x * c21.x * c12y3 * c13.x + 2 * c10.y * c12x3 * c21.y * c13.y - 2 * c12x3 * c20.y * c21.y * c13.y - 6 * c10.x * c10.y * c21.x * c13.x * c13y2 + 3 * c10.x * c11.x * c12.x * c21.y * c13y2 - 2 * c10.x * c11.x * c21.x * c12.y * c13y2 - 4 * c10.x * c11.y * c12.x * c21.x * c13y2 + 3 * c10.y * c11.x * c12.x * c21.x * c13y2 + 6 * c10.x * c10.y * c13x2 * c21.y * c13.y + 6 * c10.x * c20.x * c13.x * c21.y * c13y2 - 3 * c10.x * c11.y * c12.y * c13x2 * c21.y + 2 * c10.x * c12.x * c21.x * c12y2 * c13.y + 2 * c10.x * c12.x * c12y2 * c13.x * c21.y + 6 * c10.x * c20.y * c21.x * c13.x * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c21.y + 6 * c10.y * c20.x * c21.x * c13.x * c13y2 + 2 * c10.y * c11.y * c12.x * c13x2 * c21.y - 3 * c10.y * c11.y * c21.x * c12.y * c13x2 + 2 * c10.y * c12.x * c21.x * c12y2 * c13.x - 3 * c11.x * c20.x * c12.x * c21.y * c13y2 + 2 * c11.x * c20.x * c21.x * c12.y * c13y2 + c11.x * c11.y * c21.x * c12y2 * c13.x - 3 * c11.x * c12.x * c20.y * c21.x * c13y2 + 4 * c20.x * c11.y * c12.x * c21.x * c13y2 - 6 * c10.x * c20.y * c13x2 * c21.y * c13.y - 2 * c10.x * c12x2 * c12.y * c21.y * c13.y - 6 * c10.y * c20.x * c13x2 * c21.y * c13.y - 6 * c10.y * c20.y * c21.x * c13x2 * c13.y - 2 * c10.y * c12x2 * c21.x * c12.y * c13.y - 2 * c10.y * c12x2 * c12.y * c13.x * c21.y - c11.x * c11.y * c12x2 * c21.y * c13.y - 4 * c11.x * c20.y * c12.y * c13x2 * c21.y - 2 * c11.x * c11y2 * c21.x * c13.x * c13.y + 3 * c20.x * c11.y * c12.y * c13x2 * c21.y - 2 * c20.x * c12.x * c21.x * c12y2 * c13.y - 2 * c20.x * c12.x * c12y2 * c13.x * c21.y - 6 * c20.x * c20.y * c21.x * c13.x * c13y2 - 2 * c11.y * c12.x * c20.y * c13x2 * c21.y + 3 * c11.y * c20.y * c21.x * c12.y * c13x2 - 2 * c12.x * c20.y * c21.x * c12y2 * c13.x - c11y2 * c12.x * c21.x * c12.y * c13.x + 6 * c20.x * c20.y * c13x2 * c21.y * c13.y + 2 * c20.x * c12x2 * c12.y * c21.y * c13.y + 2 * c11x2 * c11.y * c13.x * c21.y * c13.y + c11x2 * c12.x * c12.y * c21.y * c13.y + 2 * c12x2 * c20.y * c21.x * c12.y * c13.y + 2 * c12x2 * c20.y * c12.y * c13.x * c21.y + 3 * c10x2 * c21.x * c13y3 - 3 * c10y2 * c13x3 * c21.y + 3 * c20x2 * c21.x * c13y3 + c11y3 * c21.x * c13x2 - c11x3 * c21.y * c13y2 - 3 * c20y2 * c13x3 * c21.y - c11.x * c11y2 * c13x2 * c21.y + c11x2 * c11.y * c21.x * c13y2 - 3 * c10x2 * c13.x * c21.y * c13y2 + 3 * c10y2 * c21.x * c13x2 * c13.y - c11x2 * c12y2 * c13.x * c21.y + c11y2 * c12x2 * c21.x * c13.y - 3 * c20x2 * c13.x * c21.y * c13y2 + 3 * c20y2 * c21.x * c13x2 * c13.y, c10.x * c10.y * c11.x * c12.y * c13.x * c13.y - c10.x * c10.y * c11.y * c12.x * c13.x * c13.y + c10.x * c11.x * c11.y * c12.x * c12.y * c13.y - c10.y * c11.x * c11.y * c12.x * c12.y * c13.x - c10.x * c11.x * c20.y * c12.y * c13.x * c13.y + 6 * c10.x * c20.x * c11.y * c12.y * c13.x * c13.y + c10.x * c11.y * c12.x * c20.y * c13.x * c13.y - c10.y * c11.x * c20.x * c12.y * c13.x * c13.y - 6 * c10.y * c11.x * c12.x * c20.y * c13.x * c13.y + c10.y * c20.x * c11.y * c12.x * c13.x * c13.y - c11.x * c20.x * c11.y * c12.x * c12.y * c13.y + c11.x * c11.y * c12.x * c20.y * c12.y * c13.x + c11.x * c20.x * c20.y * c12.y * c13.x * c13.y - c20.x * c11.y * c12.x * c20.y * c13.x * c13.y - 2 * c10.x * c20.x * c12y3 * c13.x + 2 * c10.y * c12x3 * c20.y * c13.y - 3 * c10.x * c10.y * c11.x * c12.x * c13y2 - 6 * c10.x * c10.y * c20.x * c13.x * c13y2 + 3 * c10.x * c10.y * c11.y * c12.y * c13x2 - 2 * c10.x * c10.y * c12.x * c12y2 * c13.x - 2 * c10.x * c11.x * c20.x * c12.y * c13y2 - c10.x * c11.x * c11.y * c12y2 * c13.x + 3 * c10.x * c11.x * c12.x * c20.y * c13y2 - 4 * c10.x * c20.x * c11.y * c12.x * c13y2 + 3 * c10.y * c11.x * c20.x * c12.x * c13y2 + 6 * c10.x * c10.y * c20.y * c13x2 * c13.y + 2 * c10.x * c10.y * c12x2 * c12.y * c13.y + 2 * c10.x * c11.x * c11y2 * c13.x * c13.y + 2 * c10.x * c20.x * c12.x * c12y2 * c13.y + 6 * c10.x * c20.x * c20.y * c13.x * c13y2 - 3 * c10.x * c11.y * c20.y * c12.y * c13x2 + 2 * c10.x * c12.x * c20.y * c12y2 * c13.x + c10.x * c11y2 * c12.x * c12.y * c13.x + c10.y * c11.x * c11.y * c12x2 * c13.y + 4 * c10.y * c11.x * c20.y * c12.y * c13x2 - 3 * c10.y * c20.x * c11.y * c12.y * c13x2 + 2 * c10.y * c20.x * c12.x * c12y2 * c13.x + 2 * c10.y * c11.y * c12.x * c20.y * c13x2 + c11.x * c20.x * c11.y * c12y2 * c13.x - 3 * c11.x * c20.x * c12.x * c20.y * c13y2 - 2 * c10.x * c12x2 * c20.y * c12.y * c13.y - 6 * c10.y * c20.x * c20.y * c13x2 * c13.y - 2 * c10.y * c20.x * c12x2 * c12.y * c13.y - 2 * c10.y * c11x2 * c11.y * c13.x * c13.y - c10.y * c11x2 * c12.x * c12.y * c13.y - 2 * c10.y * c12x2 * c20.y * c12.y * c13.x - 2 * c11.x * c20.x * c11y2 * c13.x * c13.y - c11.x * c11.y * c12x2 * c20.y * c13.y + 3 * c20.x * c11.y * c20.y * c12.y * c13x2 - 2 * c20.x * c12.x * c20.y * c12y2 * c13.x - c20.x * c11y2 * c12.x * c12.y * c13.x + 3 * c10y2 * c11.x * c12.x * c13.x * c13.y + 3 * c11.x * c12.x * c20y2 * c13.x * c13.y + 2 * c20.x * c12x2 * c20.y * c12.y * c13.y - 3 * c10x2 * c11.y * c12.y * c13.x * c13.y + 2 * c11x2 * c11.y * c20.y * c13.x * c13.y + c11x2 * c12.x * c20.y * c12.y * c13.y - 3 * c20x2 * c11.y * c12.y * c13.x * c13.y - c10x3 * c13y3 + c10y3 * c13x3 + c20x3 * c13y3 - c20y3 * c13x3 - 3 * c10.x * c20x2 * c13y3 - c10.x * c11y3 * c13x2 + 3 * c10x2 * c20.x * c13y3 + c10.y * c11x3 * c13y2 + 3 * c10.y * c20y2 * c13x3 + c20.x * c11y3 * c13x2 + c10x2 * c12y3 * c13.x - 3 * c10y2 * c20.y * c13x3 - c10y2 * c12x3 * c13.y + c20x2 * c12y3 * c13.x - c11x3 * c20.y * c13y2 - c12x3 * c20y2 * c13.y - c10.x * c11x2 * c11.y * c13y2 + c10.y * c11.x * c11y2 * c13x2 - 3 * c10.x * c10y2 * c13x2 * c13.y - c10.x * c11y2 * c12x2 * c13.y + c10.y * c11x2 * c12y2 * c13.x - c11.x * c11y2 * c20.y * c13x2 + 3 * c10x2 * c10.y * c13.x * c13y2 + c10x2 * c11.x * c12.y * c13y2 + 2 * c10x2 * c11.y * c12.x * c13y2 - 2 * c10y2 * c11.x * c12.y * c13x2 - c10y2 * c11.y * c12.x * c13x2 + c11x2 * c20.x * c11.y * c13y2 - 3 * c10.x * c20y2 * c13x2 * c13.y + 3 * c10.y * c20x2 * c13.x * c13y2 + c11.x * c20x2 * c12.y * c13y2 - 2 * c11.x * c20y2 * c12.y * c13x2 + c20.x * c11y2 * c12x2 * c13.y - c11.y * c12.x * c20y2 * c13x2 - c10x2 * c12.x * c12y2 * c13.y - 3 * c10x2 * c20.y * c13.x * c13y2 + 3 * c10y2 * c20.x * c13x2 * c13.y + c10y2 * c12x2 * c12.y * c13.x - c11x2 * c20.y * c12y2 * c13.x + 2 * c20x2 * c11.y * c12.x * c13y2 + 3 * c20.x * c20y2 * c13x2 * c13.y - c20x2 * c12.x * c12y2 * c13.y - 3 * c20x2 * c20.y * c13.x * c13y2 + c12x2 * c20y2 * c12.y * c13.x]);
      roots = poly.rootsInterval(0, 1);
      for (i in roots) {
        if (!__hasProp.call(roots, i)) continue;
        s = roots[i];
        xRoots = new Polynomial([c13.x, c12.x, c11.x, c10.x - c20.x - s * c21.x - s * s * c22.x - s * s * s * c23.x]).roots();
        yRoots = new Polynomial([c13.y, c12.y, c11.y, c10.y - c20.y - s * c21.y - s * s * c22.y - s * s * s * c23.y]).roots();
        if (xRoots.length > 0 && yRoots.length > 0) {
          tolerance = 1e-2;
          stop = false;
          for (j in xRoots) {
            if (!__hasProp.call(xRoots, j)) continue;
            xRoot = xRoots[j];
            if (0 <= xRoot && xRoot <= 1) {
              for (k in yRoots) {
                if (!__hasProp.call(yRoots, k)) continue;
                yRoot = yRoots[k];
                if (Math.abs(xRoot - yRoot) < tolerance) {
                  results.push(c23.multiplyBy(s * s * s).add(c22.multiplyBy(s * s).add(c21.multiplyBy(s).add(c20))));
                  stop = true;
                }
              }
            }
          }
        }
      }
      return results;
    };

    return CubicBezier;

  })();

  /*
  
      Mondrian SVG library
  
      Artur Sapek 2012 - 2013
  */


  Monsvg = (function() {
    function Monsvg(data) {
      this.data = data != null ? data : {};
      this.rep = this.toSVG();
      this.$rep = $(this.rep);
      this.metadata = {
        angle: 0,
        locked: false
      };
      if (!this.data.dontTrack) {
        this.metadata.uuid = uuid();
      }
      this.rep.setAttribute('uuid', this.metadata.uuid);
      this.validateColors();
      if (this.type !== "text") {
        this.data = $.extend({
          fill: new Color("none"),
          stroke: new Color("none")
        }, this.data);
      }
      this.updateDataArchived();
      if (this.data["mondrian:angle"] != null) {
        this.metadata.angle = parseFloat(this.data["mondrian:angle"], 10);
      }
      /*
      if @data.transform?
        attrs = @data.transform.split(" ")
        for attr in attrs
          key = attr.match(/[a-z]+/gi)?[0]
          val = attr.match(/\([\-\d\,\.]*\)/gi)?[0].replace(/[\(\)]/gi, "")
        @transform[key] = val.replace(/[\(\)]/gi, "")
        #console.log "saved #{attr} as #{key} #{val}"
      */

    }

    Monsvg.prototype.commit = function() {
      /*
      newTransform = []
      
      for own key, val of @transform
        if key is "translate"
          newTransform.push "#{key}(#{val.x},#{val.y})"
        else
          newTransform.push "#{key}(#{val})"
      
      @data.transform = newTransform.join(" ")
      */

      var key, val, _ref;
      _ref = this.data;
      for (key in _ref) {
        val = _ref[key];
        if (key === "") {
          delete this.data[""];
        } else {
          if (("" + val).mentions("NaN")) {
            throw new Error("NaN! Ack. Attribute = " + key + ", Value = " + val);
          }
          this.rep.setAttribute(key, val);
        }
      }
      if (this.metadata.angle === 0) {
        this.rep.removeAttribute('mondrian:angle');
      } else {
        if (this.metadata.angle < 0) {
          this.metadata.angle += 360;
        }
        this.rep.setAttribute('mondrian:angle', this.metadata.angle);
      }
      return this;
    };

    Monsvg.prototype.updateDataArchived = function(attr) {
      if (attr != null) {
        return this.dataArchived[attr] = this.data[attr];
      } else {
        return this.dataArchived = cloneObject(this.data);
      }
    };

    Monsvg.prototype.toSVG = function() {
      var key, self, val, _ref;
      self = document.createElementNS('http://www.w3.org/2000/svg', this.type);
      _ref = this.data;
      for (key in _ref) {
        val = _ref[key];
        if (key !== "") {
          self.setAttribute(key, val);
        }
      }
      return self;
    };

    Monsvg.prototype.validateColors = function() {
      if ((this.data.fill != null) && !(this.data.fill instanceof Color)) {
        this.data.fill = new Color(this.data.fill);
      }
      if ((this.data.stroke != null) && !(this.data.stroke instanceof Color)) {
        this.data.stroke = new Color(this.data.stroke);
      }
      if (this.data["stroke-width"] == null) {
        return this.data["stroke-width"] = 1;
      }
    };

    Monsvg.prototype.points = [];

    Monsvg.prototype.center = function() {
      var xr, yr;
      xr = this.xRange();
      yr = this.yRange();
      return new Posn(xr.min + (xr.max - xr.min) / 2, yr.min + (yr.max - yr.min) / 2);
    };

    Monsvg.prototype.queryPoint = function(rep) {
      return this.points.filter(function(a) {
        return a.baseHandle === rep;
      })[0];
    };

    Monsvg.prototype.queryAntlerPoint = function(rep) {
      return this.antlerPoints.filter(function(a) {
        return a.baseHandle === rep;
      })[0];
    };

    Monsvg.prototype.show = function() {
      return this.rep.style.display = "block";
    };

    Monsvg.prototype.hide = function() {
      return this.rep.style.display = "none";
    };

    Monsvg.prototype.showPoints = function() {
      this.points.map(function(point) {
        return point.show();
      });
      return this;
    };

    Monsvg.prototype.hidePoints = function() {
      this.points.map(function(point) {
        return point.hide();
      });
      return this;
    };

    Monsvg.prototype.unhoverPoints = function() {
      this.points.map(function(point) {
        return point.unhover();
      });
      return this;
    };

    Monsvg.prototype.removePoints = function() {
      this.points.map(function(point) {
        return point.clear();
      });
      return this;
    };

    Monsvg.prototype.unremovePoints = function() {
      this.points.map(function(point) {
        return point.unclear();
      });
      return this;
    };

    Monsvg.prototype.destroyPoints = function() {
      return this.points.map(function(p) {
        return p.remove();
      });
    };

    Monsvg.prototype.removeHoverTargets = function() {
      var existent, ht, _i, _len, _results;
      existent = qa("svg#hover-targets [owner='" + this.metadata.uuid + "']");
      _results = [];
      for (_i = 0, _len = existent.length; _i < _len; _i++) {
        ht = existent[_i];
        _results.push(ht.remove());
      }
      return _results;
    };

    Monsvg.prototype.redrawHoverTargets = function() {
      var _this = this;
      this.removeHoverTargets();
      this.points.map(function(p) {
        return new HoverTarget(p.prec, p);
      });
      return this;
    };

    Monsvg.prototype.topLeftBound = function() {
      return new Posn(this.xRange().min, this.yRange().min);
    };

    Monsvg.prototype.topRightBound = function() {
      return new Posn(this.xRange().max, this.yRange().min);
    };

    Monsvg.prototype.bottomRightBound = function() {
      return new Posn(this.xRange().max, this.yRange().max);
    };

    Monsvg.prototype.bottomLeftBound = function() {
      return new Posn(this.xRange().min, this.yRange().max);
    };

    Monsvg.prototype.attr = function(data) {
      var key, val, _results;
      _results = [];
      for (key in data) {
        val = data[key];
        if (typeof val === 'function') {
          _results.push(this.data[key] = val(this.data[key]));
        } else {
          _results.push(this.data[key] = val);
        }
      }
      return _results;
    };

    Monsvg.prototype.appendTo = function(selector, track) {
      var target;
      if (track == null) {
        track = true;
      }
      if (typeof selector === "string") {
        target = q(selector);
      } else {
        target = selector;
      }
      target.appendChild(this.rep);
      if (track) {
        if (!ui.elements.has(this)) {
          ui.elements.push(this);
        }
      }
      return this;
    };

    Monsvg.prototype.clone = function() {
      var clone, cloneData, cloneTransform;
      cloneData = cloneObject(this.data);
      cloneTransform = cloneObject(this.transform);
      delete cloneData.id;
      clone = new this.constructor(cloneData);
      clone.transform = cloneTransform;
      return clone;
    };

    Monsvg.prototype["delete"] = function() {
      var _this = this;
      this.rep.remove();
      ui.elements = ui.elements.remove(this);
      return async(function() {
        _this.destroyPoints();
        _this.removeHoverTargets();
        if (_this.group) {
          return _this.group["delete"]();
        }
      });
    };

    Monsvg.prototype.zIndex = function() {
      var zi,
        _this = this;
      zi = 0;
      dom.$main.children().each(function(ind, elem) {
        if (elem.getAttribute("uuid") === _this.metadata.uuid) {
          zi = ind;
          return false;
        }
      });
      return zi;
    };

    Monsvg.prototype.moveForward = function(n) {
      var next, x, _i;
      if (n == null) {
        n = 1;
      }
      for (x = _i = 1; 1 <= n ? _i <= n : _i >= n; x = 1 <= n ? ++_i : --_i) {
        next = this.$rep.next();
        if (next.length === 0) {
          break;
        }
        next.after(this.$rep);
      }
      return this;
    };

    Monsvg.prototype.moveBack = function(n) {
      var prev, x, _i;
      if (n == null) {
        n = 1;
      }
      for (x = _i = 1; 1 <= n ? _i <= n : _i >= n; x = 1 <= n ? ++_i : --_i) {
        prev = this.$rep.prev();
        if (prev.length === 0) {
          break;
        }
        prev.before(this.$rep);
      }
      return this;
    };

    Monsvg.prototype.bringToFront = function() {
      return dom.$main.append(this.$rep);
    };

    Monsvg.prototype.sendToBack = function() {
      return dom.$main.prepend(this.$rep);
    };

    Monsvg.prototype.transform = {};

    Monsvg.prototype.swapFillAndStroke = function() {
      var swap;
      swap = this.data.stroke;
      this.attr({
        'stroke': this.data.fill,
        'fill': swap
      });
      return this.commit();
    };

    Monsvg.prototype.eyedropper = function(sample) {
      this.data.fill = sample.data.fill;
      this.data.stroke = sample.data.stroke;
      this.data['stroke-width'] = sample.data['stroke-width'];
      return this.commit();
    };

    Monsvg.prototype.bounds = function() {
      var cached, xr, yr;
      cached = this.boundsCached;
      if (cached !== null && this.caching) {
        return cached;
      } else {
        xr = this.xRange();
        yr = this.yRange();
        return this.boundsCached = new Bounds(xr.min, yr.min, xr.length(), yr.length());
      }
    };

    Monsvg.prototype.boundsCached = null;

    Monsvg.prototype.hideUI = function() {
      return ui.removePointHandles();
    };

    Monsvg.prototype.refreshUI = function() {
      this.points.map(function(p) {
        return p.updateHandle();
      });
      return this.redrawHoverTargets();
    };

    Monsvg.prototype.overlaps = function(other) {
      return this['overlaps' + other.type.capitalize()](other);
    };

    Monsvg.prototype.lineSegmentsIntersect = function(other) {
      var a, b, continueChecking, mbounds, mline, ms, obounds, oline, os, _i, _j, _len, _len1;
      ms = this.lineSegments();
      os = other.lineSegments();
      for (_i = 0, _len = ms.length; _i < _len; _i++) {
        mline = ms[_i];
        if (mline instanceof CubicBezier) {
          mbounds = mline.bounds(true);
        }
        a = mline instanceof LineSegment ? mline.a : mline.p1;
        b = mline instanceof LineSegment ? mline.b : mline.p2;
        if ((other.contains(a)) || (other.contains(b))) {
          return true;
        }
        for (_j = 0, _len1 = os.length; _j < _len1; _j++) {
          oline = os[_j];
          if (mline instanceof CubicBezier || oline instanceof CubicBezier) {
            obounds = oline.bounds(true);
            continueChecking = mbounds.overlapsBounds(obounds);
          } else {
            continueChecking = true;
          }
          if (continueChecking) {
            if (mline.intersects(oline)) {
              return true;
            }
          }
        }
      }
      return false;
    };

    Monsvg.prototype.lineSegmentIntersections = function(other) {
      var inter, intersections, mbounds, mline, ms, obounds, oline, os, _i, _j, _len, _len1;
      intersections = [];
      ms = this.lineSegments();
      os = other.lineSegments();
      for (_i = 0, _len = ms.length; _i < _len; _i++) {
        mline = ms[_i];
        mbounds = mline.bounds(true);
        for (_j = 0, _len1 = os.length; _j < _len1; _j++) {
          oline = os[_j];
          obounds = oline.bounds(true);
          inter = mline.intersection(oline);
          if (inter instanceof Posn) {
            intersections.push({
              intersection: [inter],
              aline: mline,
              bline: oline,
              a: mline.source,
              b: oline.source
            });
          } else if (inter instanceof Array && inter.length > 0) {
            intersections.push({
              intersection: inter,
              aline: mline,
              bline: oline,
              a: mline.source,
              b: oline.source
            });
          }
        }
      }
      return intersections;
    };

    Monsvg.prototype.remove = function() {
      this.rep.remove();
      if (this.points !== []) {
        return this.points.map(function(p) {
          var _ref;
          return (_ref = p.baseHandle) != null ? _ref.remove() : void 0;
        });
      }
    };

    Monsvg.prototype.convertTo = function(type) {
      var result;
      result = this["convertTo" + type]();
      result.eyedropper(this);
      return result;
    };

    Monsvg.prototype.toString = function() {
      return "(" + this.type + " Monsvg object)";
    };

    Monsvg.prototype.repToString = function() {
      return new XMLSerializer().serializeToString(this.rep);
    };

    Monsvg.prototype.carryOutTransformations = function(transform, center) {
      var attr, attrs, factor, key, val, x, y, _i, _len, _ref, _ref1, _results;
      if (transform == null) {
        transform = this.data.transform;
      }
      if (center == null) {
        center = new Posn(0, 0);
      }
      /*
        We do things this way because fuck the transform attribute.
      
        Basically, when we commit shapes for the first time from some other file,
        if they have a transform attribute we effectively just alter the data
        that makes those shapes up so that they still look the same, but they no longer
        have a transform attr.
      */

      attrs = transform.replace(", ", ",").split(" ").reverse();
      _results = [];
      for (_i = 0, _len = attrs.length; _i < _len; _i++) {
        attr = attrs[_i];
        key = (_ref = attr.match(/[a-z]+/gi)) != null ? _ref[0] : void 0;
        val = (_ref1 = attr.match(/\([\-\d\,\.]*\)/gi)) != null ? _ref1[0].replace(/[\(\)]/gi, "") : void 0;
        switch (key) {
          case "scale":
            factor = parseFloat(val);
            this.scale(factor, factor, center);
            _results.push(this.data["stroke-width"] *= factor);
            break;
          case "translate":
            val = val.split(",");
            x = parseFloat(val[0]);
            y = val[1] != null ? parseFloat(val[1]) : 0;
            _results.push(this.nudge(x, -y));
            break;
          case "rotate":
            this.rotate(parseFloat(val), center);
            _results.push(this.metadata.angle = 0);
            break;
          default:
            _results.push(void 0);
        }
      }
      return _results;
    };

    Monsvg.prototype.applyTransform = function(transform) {
      var attr, key, val, x, y, _i, _len, _ref, _ref1, _ref2;
      console.log("apply transform");
      _ref = transform.split(" ");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attr = _ref[_i];
        key = (_ref1 = attr.match(/[a-z]+/gi)) != null ? _ref1[0] : void 0;
        val = (_ref2 = attr.match(/\([\-\d\,\.]*\)/gi)) != null ? _ref2[0].replace(/[\(\)]/gi, "") : void 0;
        switch (key) {
          case "scale":
            val = parseFloat(val);
            if (this.transform.scale != null) {
              this.transform.scale *= val;
            } else {
              this.transform.scale = val;
            }
            break;
          case "translate":
            val = val.split(",");
            x = parseFloat(val[0]);
            y = parseFloat(val[1]);
            x = parseFloat(x);
            y = parseFloat(y);
            if (this.transform.translate != null) {
              this.transform.translate.x += x;
              this.transform.translate.y += y;
            } else {
              this.transform.translate = {
                x: x,
                y: y
              };
            }
            break;
          case "rotate":
            val = parseFloat(val);
            if (this.transform.rotate != null) {
              this.transform.rotate += val;
              this.transform.rotate %= 360;
            } else {
              this.transform.rotate = val;
            }
        }
      }
      return this.commit();
    };

    Monsvg.prototype.setFill = function(val) {
      return this.data.fill = new Color(val);
    };

    Monsvg.prototype.setStroke = function(val) {
      return this.data.stroke = new Color(val);
    };

    Monsvg.prototype.setStrokeWidth = function(val) {
      return this.data['stroke-width'] = val;
    };

    Monsvg.prototype.setupToCanvas = function(context) {
      var _ref;
      context.beginPath();
      context.fillStyle = "" + this.data.fill;
      if (((this.data['stroke-width'] != null) > 0) && (((_ref = this.data.stroke) != null ? _ref.hex : void 0) !== "none")) {
        context.strokeStyle = "" + this.data.stroke;
        context.lineWidth = parseFloat(this.data['stroke-width']);
      } else {
        context.strokeStyle = "none";
        context.lineWidth = "0";
      }
      return context;
    };

    Monsvg.prototype.finishToCanvas = function(context) {
      var _ref, _ref1;
      if ((_ref = this.points) != null ? _ref.closed : void 0) {
        context.closePath();
      }
      context.fill();
      if ((this.data['stroke-width'] > 0) && (((_ref1 = this.data.stroke) != null ? _ref1.hex : void 0) !== "none")) {
        context.stroke();
      }
      return context;
    };

    Monsvg.prototype.clearCachedObjects = function() {};

    Monsvg.prototype.lineSegments = function() {};

    return Monsvg;

  })();

  /*
  
    HoverTarget
  */


  HoverTarget = (function(_super) {
    __extends(HoverTarget, _super);

    HoverTarget.prototype.type = 'path';

    function HoverTarget(a, b, width) {
      this.a = a;
      this.b = b;
      this.width = width;
      if (this.width == null) {
        this.width = 1;
      }
      this.owner = this.b.owner;
      b = this.b instanceof SmoothTo ? this.b.toCurveTo() : this.b;
      this.d = "M" + (this.a.x * ui.canvas.zoom) + "," + (this.a.y * ui.canvas.zoom) + " " + (b.toStringWithZoom());
      this.data = {
        fill: "none",
        stroke: "rgba(75, 175, 255, 0.0)",
        "stroke-width": 4 / ui.canvas.zoom,
        d: this.d
      };
      this.b.hoverTarget = this;
      HoverTarget.__super__.constructor.call(this, this.data);
      this.appendTo('#hover-targets', false);
      this.rep.setAttribute('a', this.a.at);
      this.rep.setAttribute('b', this.b.at);
      this.rep.setAttribute('owner', this.owner.metadata.uuid);
    }

    HoverTarget.prototype.highlight = function() {
      ui.unhighlightHoverTargets();
      this.a.hover();
      this.b.hover();
      this.attr({
        "stroke-width": 5,
        stroke: "#4981e0"
      });
      ui.hoverTargetsHighlighted.push(this);
      return this.commit();
    };

    HoverTarget.prototype.unhighlight = function() {
      this.attr({
        "stroke-width": 5,
        stroke: "rgba(75, 175, 255, 0.0)"
      });
      return this.commit();
    };

    HoverTarget.prototype.active = function() {
      this.a.baseHandle.setAttribute('active', '');
      return this.b.baseHandle.setAttribute('active', '');
    };

    HoverTarget.prototype.nudge = function(x, y) {
      this.a.nudge(x, y);
      this.b.nudge(x, y);
      this.owner.commit();
      this.unhighlight();
      return this.constructor(this.a, this.b, this.width);
    };

    return HoverTarget;

  })(Monsvg);

  /*
  
    Line
  */


  Line = (function(_super) {
    __extends(Line, _super);

    function Line() {
      _ref = Line.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Line.prototype.type = 'line';

    Line.prototype.a = function() {
      return new Posn(this.data.x1, this.data.y1);
    };

    Line.prototype.b = function() {
      return new Posn(this.data.x2, this.data.y2);
    };

    Line.prototype.absorbA = function(a) {
      this.data.x1 = a.x;
      return this.data.y1 = a.y;
    };

    Line.prototype.absorbB = function(b) {
      this.data.x2 = b.x;
      return this.data.y2 = b.y;
    };

    Line.prototype.asLineSegment = function() {
      return new LineSegment(this.a(), this.b());
    };

    Line.prototype.fromLineSegment = function(ls) {
      this.absorbA(ls.a);
      return this.absorbB(ls.b);
    };

    Line.prototype.xRange = function() {
      return this.asLineSegment().xRange();
    };

    Line.prototype.yRange = function() {
      return this.asLineSegment().yRange();
    };

    Line.prototype.nudge = function(x, y) {
      this.data.x1 += x;
      this.data.x2 += x;
      this.data.y1 -= y;
      this.data.y2 -= y;
      return this.commit();
    };

    Line.prototype.scale = function(x, y, origin) {
      this.absorbA(this.a().scale(x, y, origin));
      this.absorbB(this.b().scale(x, y, origin));
      return this.commit();
    };

    Line.prototype.overlapsRect = function(rect) {
      var l, ls, _i, _len, _ref1;
      ls = this.asLineSegment();
      if (this.a().insideOf(rect)) {
        return true;
      }
      if (this.b().insideOf(rect)) {
        return true;
      }
      _ref1 = rect.lineSegments();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        l = _ref1[_i];
        if (l.intersects(ls)) {
          return true;
        }
      }
      return false;
    };

    return Line;

  })(Monsvg);

  Rect = (function(_super) {
    __extends(Rect, _super);

    Rect.prototype.type = 'rect';

    function Rect(data) {
      this.data = data;
      Rect.__super__.constructor.call(this, this.data);
      if (this.data.x == null) {
        this.data.x = 0;
      }
      if (this.data.y == null) {
        this.data.y = 0;
      }
      this.data.x = parseFloat(this.data.x);
      this.data.y = parseFloat(this.data.y);
      this.data.width = parseFloat(this.data.width);
      this.data.height = parseFloat(this.data.height);
    }

    Rect.prototype.points = function() {
      return [new Point(this.data.x, this.data.y), new Point(this.data.x + this.data.width, this.data.y), new Point(this.data.x + this.data.width, this.data.y + this.data.height), new Point(this.data.x, this.data.y + this.data.height)];
    };

    /*
    
      Geometric data
    
        points()
        lineSegments()
        center()
        xRange()
        yRange()
    */


    Rect.prototype.lineSegments = function() {
      var p;
      p = this.points();
      return [new LineSegment(p[0], p[1], p[1]), new LineSegment(p[1], p[2], p[2]), new LineSegment(p[2], p[3], p[3]), new LineSegment(p[3], p[0], p[0])];
    };

    Rect.prototype.center = function() {
      return new Posn(this.data.x + (this.data.width / 2), this.data.y + (this.data.height / 2));
    };

    Rect.prototype.xRange = function() {
      return new Range(this.data.x, this.data.x + this.data.width);
    };

    Rect.prototype.yRange = function() {
      return new Range(this.data.y, this.data.y + this.data.height);
    };

    Rect.prototype.clearCachedObjects = function() {};

    /*
    
      Relationship analysis
    
        contains()
        overlaps()
        intersections()
        containments()
        containmentsBothWays()
    */


    Rect.prototype.contains = function(posn) {
      return this.xRange().contains(posn.x) && this.yRange().contains(posn.y);
    };

    Rect.prototype.overlaps = function(other) {
      /*
        Fuck you whore
        Redirects to appropriate method.
      
        I/P: Polygon/Circle/Rect
        O/P: true or false
      */

      return this['overlaps' + other.type.capitalize()](other);
    };

    Rect.prototype.overlapsPolygon = function(polygon) {
      if (this.contains(polygon.center() || polygon.contains(this.center()))) {
        return true;
      }
      return this.lineSegmentsIntersect(polygon);
    };

    Rect.prototype.overlapsCircle = function(circle) {};

    Rect.prototype.overlapsRect = function(rectangle) {
      return this.overlapsPolygon(rectangle);
    };

    Rect.prototype.intersections = function(obj) {
      var inter, intersections, s1, s2, _i, _j, _len, _len1, _ref1, _ref2;
      intersections = [];
      _ref1 = this.lineSegments();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        s1 = _ref1[_i];
        _ref2 = obj.lineSegments();
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          s2 = _ref2[_j];
          inter = s1.intersection(s2);
          if (inter instanceof Posn) {
            intersections.push(inter);
          }
        }
      }
      return intersections;
    };

    Rect.prototype.containments = function(obj) {
      var containments, point, points, xr, yr, _i, _len;
      containments = [];
      points = obj.points;
      xr = this.xRange();
      yr = this.yRange();
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        point = points[_i];
        if (xr.contains(point.x) && yr.contains(point.y)) {
          containments.push(point);
        }
      }
      return containments;
    };

    Rect.prototype.containmentsBothWays = function(obj) {
      return this.containments(obj).concat(obj.containments(this));
    };

    Rect.prototype.scale = function(factorX, factorY, origin) {
      var _this = this;
      if (origin == null) {
        origin = this.center();
      }
      this.attr({
        x: function(x) {
          return (x - origin.x) * factorX + origin.x;
        },
        y: function(y) {
          return (y - origin.y) * factorY + origin.y;
        },
        width: function(w) {
          return w * factorX;
        },
        height: function(h) {
          return h * factorY;
        }
      });
      return this.commit();
    };

    Rect.prototype.nudge = function(x, y) {
      this.data.x += x;
      this.data.y -= y;
      return this.commit();
    };

    Rect.prototype.convertToPath = function() {
      var path, pts;
      pts = this.points();
      path = new Path({
        d: "M" + pts[0] + " L" + pts[1] + " L" + pts[2] + " L" + pts[3] + " L" + pts[0]
      });
      path.eyedropper(this);
      path.updateDataArchived();
      return path;
    };

    Rect.prototype.drawToCanvas = function(context) {
      context = this.setupToCanvas(context);
      context.rect(this.data.x, this.data.y, this.data.width, this.data.height);
      return context = this.finishToCanvas(context);
    };

    return Rect;

  })(Monsvg);

  Circle = (function(_super) {
    __extends(Circle, _super);

    function Circle() {
      _ref1 = Circle.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Circle.prototype.type = 'circle';

    Circle.prototype.scale = function(factor, origin) {
      this.attr({
        'r': function(r) {
          return r * factor;
        }
      });
      return this.commit();
    };

    Circle.prototype.scaleXY = function(x, y, origin) {};

    Circle.prototype.points = [];

    Circle.prototype.center = function() {
      return new Posn(this.data.cx, this.data.cy);
    };

    Circle.prototype.xRange = function() {
      return new Range(this.data.cx - this.data.r, this.data.cx + this.data.r);
    };

    Circle.prototype.yRange = function() {
      return new Range(this.data.cy - this.data.r, this.data.cy + this.data.r);
    };

    Circle.prototype.overlaps = function(other) {
      /*
        Checks for overlap with another shape.
        Redirects to appropriate method.
      
        I/P: Polygon/Circle/Rect
        O/P: true or false
      */

      return this['overlaps' + other.type.capitalize()](other);
    };

    Circle.prototype.overlapsPolygon = function(polygon) {
      var line, _i, _len, _ref2;
      if (polygon.contains(this.center())) {
        return true;
      }
      _ref2 = polygon.lineSegments();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        line = _ref2[_i];
        if (line.intersects(this)) {
          return true;
        }
      }
      return false;
    };

    Circle.prototype.overlapsCircle = function(circle) {};

    Circle.prototype.overlapsRect = function(rectangle) {
      return this.overlapsPolygon(rectangle);
    };

    Circle.prototype.nudge = function(x, y) {
      this.attr({
        cx: function(cx) {
          return cx += x;
        },
        cy: function(cy) {
          return cy -= y;
        }
      });
      return this.commit();
    };

    return Circle;

  })(Monsvg);

  /*
  
    Ellipse
  */


  Ellipse = (function(_super) {
    __extends(Ellipse, _super);

    Ellipse.prototype.type = 'ellipse';

    function Ellipse(data) {
      this.data = data;
      Ellipse.__super__.constructor.call(this, this.data);
      this.data.cx = parseFloat(this.data.cx);
      this.data.cy = parseFloat(this.data.cy);
      this.data.rx = parseFloat(this.data.rx);
      this.data.ry = parseFloat(this.data.ry);
    }

    Ellipse.prototype.xRange = function() {
      return new Range(this.data.cx - this.data.rx, this.data.cx + this.data.rx);
    };

    Ellipse.prototype.yRange = function() {
      return new Range(this.data.cy - this.data.ry, this.data.cy + this.data.ry);
    };

    Ellipse.prototype.c = function() {
      return new Posn(this.data.cx, this.data.cy);
    };

    Ellipse.prototype.top = function() {
      return new Posn(this.data.cx, this.data.cy - this.data.ry);
    };

    Ellipse.prototype.right = function() {
      return new Posn(this.data.cx + this.data.rx, this.data.cy);
    };

    Ellipse.prototype.bottom = function() {
      return new Posn(this.data.cx, this.data.cy + this.data.ry);
    };

    Ellipse.prototype.left = function() {
      return new Posn(this.data.cx - this.data.rx, this.data.cy);
    };

    Ellipse.prototype.overlapsRect = function(r) {
      var l, _i, _len, _ref2;
      _ref2 = r.lineSegments();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        l = _ref2[_i];
        if ((l.intersectionWithEllipse(this)) instanceof Array) {
          return true;
        }
      }
    };

    Ellipse.prototype.nudge = function(x, y) {
      this.data.cx += x;
      this.data.cy -= y;
      return this.commit();
    };

    Ellipse.prototype.scale = function(x, y, origin) {
      var c;
      c = this.c().scale(x, y, origin);
      this.data.cx = c.x;
      this.data.cy = c.y;
      this.data.rx *= x;
      this.data.ry *= y;
      return this.commit();
    };

    Ellipse.prototype.convertToPath = function() {
      var bottom, kx, ky, left, p, right, rx, ry, top;
      p = new Path({
        d: "M" + this.data.cx + "," + (this.data.cy - this.data.ry)
      });
      p.eyedropper(this);
      top = this.top();
      right = this.right();
      bottom = this.bottom();
      left = this.left();
      rx = this.data.rx;
      ry = this.data.ry;
      ky = Math.KAPPA * ry;
      kx = Math.KAPPA * rx;
      p.points.push(new CurveTo(top.x + kx, top.y, right.x, right.y - ky, right.x, right.y));
      p.points.push(new CurveTo(right.x, right.y + ky, bottom.x + kx, bottom.y, bottom.x, bottom.y));
      p.points.push(new CurveTo(bottom.x - kx, bottom.y, left.x, left.y + ky, left.x, left.y));
      p.points.push(new CurveTo(left.x, left.y - ky, top.x - kx, top.y, top.x, top.y));
      p.points.close();
      p.points.drawBasePoints();
      p.updateDataArchived();
      return p;
    };

    return Ellipse;

  })(Monsvg);

  Polygon = (function(_super) {
    __extends(Polygon, _super);

    Polygon.prototype.type = 'polygon';

    function Polygon(data) {
      this.data = data;
      this.points = new PointsList(this.parsePoints(this.data.points));
      Polygon.__super__.constructor.call(this, this.data);
    }

    Polygon.prototype.appendTo = function(selector, track) {
      if (track == null) {
        track = true;
      }
      Polygon.__super__.appendTo.call(this, selector, track);
      this.points.drawBasePoints().hide();
      if (track) {
        this.redrawHoverTargets();
      }
      return this;
    };

    Polygon.prototype.commit = function() {
      this.data.points = this.points.toString();
      return Polygon.__super__.commit.apply(this, arguments);
    };

    Polygon.prototype.lineSegments = function() {
      var points, segments;
      points = this.points.points;
      segments = [];
      points.map(function(curr, ind) {
        var next;
        next = points[ind === (points.length - 1) ? 0 : ind + 1];
        return segments.push(new LineSegment(curr, next));
      });
      return segments;
    };

    Polygon.prototype.xs = function() {
      return this.points.all().map(function(posn) {
        return posn.x;
      });
    };

    Polygon.prototype.ys = function() {
      return this.points.all().map(function(posn) {
        return posn.y;
      });
    };

    Polygon.prototype.xRange = function() {
      return new Range().fromList(this.xs());
    };

    Polygon.prototype.yRange = function() {
      return new Range().fromList(this.ys());
    };

    Polygon.prototype.topLeftBound = function() {
      return new Posn(this.xRange().min, this.yRange().min);
    };

    Polygon.prototype.topRightBound = function() {
      return new Posn(this.xRange().max, this.yRange().min);
    };

    Polygon.prototype.bottomRightBound = function() {
      return new Posn(this.xRange().max, this.yRange().max);
    };

    Polygon.prototype.bottomLeftBound = function() {
      return new Posn(this.xRange().min, this.yRange().max);
    };

    Polygon.prototype.bounds = function() {
      var xr, yr;
      xr = this.xRange();
      yr = this.yRange();
      return new Bounds(xr.min, yr.min, xr.length(), yr.length());
    };

    Polygon.prototype.center = function() {
      return this.bounds().center();
    };

    Polygon.prototype.parsePoints = function() {
      var points,
        _this = this;
      if (this.data.points === '') {
        return [];
      }
      points = [];
      this.data.points = this.data.points.match(/[\d\,\. ]/gi).join('');
      this.data.points.split(' ').map(function(coords) {
        var p, x, y;
        coords = coords.split(',');
        if (coords.length === 2) {
          x = parseFloat(coords[0]);
          y = parseFloat(coords[1]);
          p = new Point(x, y, _this);
          return points.push(p);
        }
      });
      return points;
    };

    Polygon.prototype.clearCachedObjects = function() {};

    /*
      Transformations
        rotate
        nudge
    */


    Polygon.prototype.rotate = function(angle, center) {
      var _this = this;
      if (center == null) {
        center = this.center();
      }
      this.points.map(function(p) {
        return p.rotate(angle, center);
      });
      this.metadata.angle += angle;
      return this.metadata.angle %= 360;
    };

    Polygon.prototype.scale = function(x, y, origin) {
      if (origin == null) {
        origin = this.center();
      }
      this.points.map(function(p) {
        return p.scale(x, y, origin);
      });
      return this.commit();
    };

    Polygon.prototype.nudge = function(x, y) {
      this.points.map(function(p) {
        return p.nudge(x, y);
      });
      return this.commit();
    };

    Polygon.prototype.contains = function(posn) {
      return posn.insideOf(this.lineSegments());
    };

    Polygon.prototype.overlaps = function(other) {
      return this['overlaps' + other.type.capitalize()](other);
    };

    Polygon.prototype.overlapsPolygon = function(polygon) {
      var line, polyLine, _i, _j, _len, _len1, _ref2, _ref3;
      if (this.contains(polygon.center() || polygon.contains(this.center()))) {
        return true;
      }
      _ref2 = this.lineSegments();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        line = _ref2[_i];
        if (polygon.contains(line.a || polygon.contains(line.b))) {
          return true;
        }
        _ref3 = polygon.lineSegments();
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          polyLine = _ref3[_j];
          if (polyLine.intersects(line)) {
            return true;
          }
        }
      }
      return false;
    };

    Polygon.prototype.overlapsCircle = function(circle) {};

    Polygon.prototype.overlapsRect = function(rectangle) {
      return this.overlapsPolygon(rectangle);
    };

    Polygon.prototype.convertToPath = function() {
      var lt, old, p, path, _i, _len, _ref2;
      path = new Path({
        d: "M" + (this.points.at(0).x) + "," + (this.points.at(0).y)
      });
      path.eyedropper(this);
      old = path.points.at(0);
      _ref2 = this.points.all().slice(1);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        p = _ref2[_i];
        lt = new LineTo(p.x, p.y, path, old, false);
        path.points.push(lt);
        old = lt;
      }
      path.points.close();
      return path;
    };

    return Polygon;

  })(Monsvg);

  Polyline = (function(_super) {
    __extends(Polyline, _super);

    function Polyline() {
      _ref2 = Polyline.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    Polyline.prototype.convertToPath = function() {
      var lt, old, p, path, _i, _len, _ref3;
      path = new Path({
        d: "M" + (this.points.at(0).x) + "," + (this.points.at(0).y)
      });
      path.eyedropper(this);
      old = path.points.at(0);
      _ref3 = this.points.all().slice(1);
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        p = _ref3[_i];
        lt = new LineTo(p.x, p.y, path, old, false);
        path.points.push(lt);
        old = lt;
      }
      return path;
    };

    return Polyline;

  })(Polygon);

  /*
  
    Path
  
    Highest order of vector data. Lowest level of expression.
  */


  Path = (function(_super) {
    __extends(Path, _super);

    Path.prototype.type = 'path';

    function Path(data) {
      var _ref3, _ref4, _ref5;
      this.data = data;
      Path.__super__.constructor.call(this, this.data);
      if (((_ref3 = this.data) != null ? _ref3.d : void 0) != null) {
        this.importNewPoints(this.data.d);
      }
      this.antlerPoints = new PointsList([], this);
      if (((_ref4 = this.data) != null ? (_ref5 = _ref4.d) != null ? _ref5.match(/z$/gi) : void 0 : void 0) !== null) {
        this.points.closed = true;
      }
    }

    Path.prototype.caching = true;

    Path.prototype.commit = function() {
      this.data.d = this.points.toString();
      return Path.__super__.commit.apply(this, arguments);
    };

    Path.prototype.hover = function() {
      if (!ui.selection.elements.all.has(this)) {
        this.showPoints();
      }
      return ui.unhighlightHoverTargets();
    };

    Path.prototype.unhover = function() {
      return this.hidePoints();
    };

    Path.prototype.virgin = void 0;

    Path.prototype.virginMode = function() {
      this.virgin.eyedropper(this);
      return this.$rep.replaceWith(this.virgin.$rep);
    };

    Path.prototype.editMode = function() {
      return this.virgin.$rep.replaceWith(this.$rep);
    };

    Path.prototype.woohoo = function() {
      return this.virgin = void 0;
    };

    Path.prototype.importNewPoints = function(points) {
      if (points instanceof PointsList) {
        this.points = points;
      } else {
        this.points = new PointsList(points, this);
      }
      this.points = this.points.absolute();
      this.clearCachedObjects();
      return this;
    };

    Path.prototype.cleanUpPoints = function() {
      var p, _i, _len, _ref3;
      _ref3 = this.points.all();
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        p = _ref3[_i];
        p.cleanUp();
      }
      return this.commit();
    };

    Path.prototype.appendTo = function(selector, track) {
      if (track == null) {
        track = true;
      }
      Path.__super__.appendTo.call(this, selector, track);
      this.points.drawBasePoints().hide();
      if (track) {
        this.redrawHoverTargets();
      }
      return this;
    };

    Path.prototype.xRange = function() {
      var cached;
      cached = this.xRangeCached;
      if (cached !== null) {
        return cached;
      } else {
        return this.xRangeCached = new Range().fromRangeList(this.lineSegments().map(function(x) {
          return x.xRange();
        }));
      }
    };

    Path.prototype.xRangeCached = null;

    Path.prototype.yRange = function() {
      var cached;
      cached = this.yRangeCached;
      if (cached !== null) {
        return cached;
      } else {
        return this.yRangeCached = new Range().fromRangeList(this.lineSegments().map(function(x) {
          return x.yRange();
        }));
      }
    };

    Path.prototype.yRangeCached = null;

    Path.prototype.nudgeCachedObjects = function(x, y) {
      var _ref3, _ref4, _ref5, _ref6;
      if ((_ref3 = this.boundsCached) != null) {
        _ref3.nudge(x, y);
      }
      if ((_ref4 = this.xRangeCached) != null) {
        _ref4.nudge(x);
      }
      if ((_ref5 = this.yRangeCached) != null) {
        _ref5.nudge(y);
      }
      return (_ref6 = this.lineSegmentsCached) != null ? _ref6.map(function(ls) {
        return ls.nudge(x, y);
      }) : void 0;
    };

    Path.prototype.scaleCachedObjects = function(x, y, origin) {
      var _ref3, _ref4, _ref5;
      if ((_ref3 = this.boundsCached) != null) {
        _ref3.scale(x, y, origin);
      }
      if ((_ref4 = this.xRangeCached) != null) {
        _ref4.scale(x, origin.x);
      }
      if ((_ref5 = this.yRangeCached) != null) {
        _ref5.scale(y, origin.y);
      }
      return this.lineSegmentsCached = null;
      /*
      @lineSegmentsCached.map (ls) ->
        ls.scale(x, y, origin)
      */

    };

    Path.prototype.clearCachedObjects = function() {
      this.lineSegmentsCached = null;
      this.boundsCached = null;
      this.xRangeCached = null;
      this.yRangeCached = null;
      return this;
    };

    Path.prototype.lineSegments = function() {
      var cached, segments,
        _this = this;
      cached = this.lineSegmentsCached;
      if (cached !== null) {
        return cached;
      } else {
        segments = [];
        this.points.all().map(function(curr, ind) {
          return segments.push(_this.pathSegment(curr, curr.succ));
        });
        return this.lineSegmentsCached = segments;
      }
    };

    Path.prototype.lineSegmentsCached = null;

    Path.prototype.pathSegment = function(a, b) {
      if (b instanceof LineTo || b instanceof MoveTo || b instanceof HorizTo || b instanceof VertiTo) {
        return new LineSegment(new Posn(a.x, a.y), new Posn(b.x, b.y), b);
      } else if (b instanceof CurveTo) {
        return new CubicBezier(new Posn(a.x, a.y), new Posn(b.x2, b.y2), new Posn(b.x3, b.y3), new Posn(b.x, b.y), b);
      } else if (b instanceof SmoothTo) {
        return new CubicBezier(new Posn(a.x, a.y), new Posn(b.x2, b.y2), new Posn(b.x3, b.y3), new Posn(b.x, b.y), b);
      }
    };

    Path.prototype.scale = function(x, y, origin) {
      var angle, _ref3,
        _this = this;
      if (origin == null) {
        origin = this.center();
      }
      this.scaleCachedObjects(x, y, origin);
      angle = this.metadata.angle;
      if (angle !== 0) {
        this.rotate(360 - angle, origin);
      }
      this.points.map(function(a) {
        return a.scale(x, y, origin);
      });
      if (angle !== 0) {
        this.rotate(angle, origin);
      }
      this.commit();
      return (_ref3 = this.virgin) != null ? _ref3.scale(x, y, origin) : void 0;
    };

    Path.prototype.nudge = function(x, y) {
      var _ref3;
      this.points.map(function(p) {
        return p.nudge(x, y, false);
      });
      this.nudgeCachedObjects(x, y);
      this.commit();
      return (_ref3 = this.virgin) != null ? _ref3.nudge(x, y) : void 0;
    };

    Path.prototype.rotate = function(a, origin) {
      if (origin == null) {
        origin = this.center();
      }
      this.metadata.angle += a;
      this.metadata.angle %= 360;
      this.clearCachedObjects();
      this.points.map(function(p) {
        return p.rotate(a, origin);
      });
      this.commit();
      return this.woohoo();
    };

    Path.prototype.fitToBounds = function(bounds) {
      var mb, myHeight, myWidth, sx, sy;
      this.clearCachedObjects();
      mb = this.bounds();
      myWidth = mb.width;
      myHeight = mb.height;
      sx = bounds.width / mb.width;
      sy = bounds.height / mb.height;
      if ((isNaN(sx)) || (sx === Infinity) || (sx === -Infinity) || (sx === 0)) {
        sx = 1;
      }
      if ((isNaN(sy)) || (sy === Infinity) || (sy === -Infinity) || (sy === 0)) {
        sy = 1;
      }
      sx = Math.max(1e-5, sx);
      sy = Math.max(1e-5, sy);
      this.scale(sx, sy, new Posn(mb.x, mb.y));
      this.nudge(bounds.x - mb.x, mb.y - bounds.y);
      if (this.points.toString().indexOf("NaN") > -1) {
        debugger;
      }
    };

    Path.prototype.overlapsRect = function(rect) {
      var point, _i, _len, _ref3;
      if (this.bounds().overlapsBounds(rect.bounds())) {
        _ref3 = this.points.all();
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          point = _ref3[_i];
          if (point.insideOf(rect)) {
            return true;
          }
        }
        return this.lineSegmentsIntersect(rect);
      } else {
        return false;
      }
    };

    Path.prototype.drawToCanvas = function(context) {
      var point, _i, _len, _ref3;
      context = this.setupToCanvas(context);
      _ref3 = this.points.all();
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        point = _ref3[_i];
        switch (point.constructor) {
          case MoveTo:
            context.moveTo(point.x, point.y);
            break;
          case LineTo:
          case HorizTo:
          case VertiTo:
            context.lineTo(point.x, point.y);
            break;
          case CurveTo:
          case SmoothTo:
            context.bezierCurveTo(point.x2, point.y2, point.x3, point.y3, point.x, point.y);
        }
      }
      return this.finishToCanvas(context);
    };

    return Path;

  })(Monsvg);

  /*
  */


  Text = (function(_super) {
    __extends(Text, _super);

    Text.prototype.type = 'text';

    function Text(data, content) {
      this.data = data;
      this.content = content != null ? content : "";
      this.data = $.extend({
        x: 0,
        y: 0,
        'font-size': ui.utilities.typography.sizeControl.read(),
        'font-family': ui.utilities.typography.faceControl.selected.val
      }, this.data);
      this.data.x = float(this.data.x);
      this.data.y = float(this.data.y);
      Text.__super__.constructor.call(this, this.data);
      this.transformations = new Transformations(this, [new RotateTransformation(0), new ScaleTransformation(1, 1), new TranslateTransformation(0, 0)]);
      this.origin = new Posn(this.data.x, this.data.y);
      this.textEditable = new TextEditable(this);
      this;
    }

    Text.prototype.caching = false;

    Text.prototype.setContent = function(content) {
      this.content = content;
      return this.commit();
    };

    Text.prototype.setSize = function(size) {
      return this.data['font-size'] = size;
    };

    Text.prototype.setFace = function(face) {
      return this.data['font-family'] = face;
    };

    Text.prototype.commit = function() {
      this.data.x = this.origin.x;
      this.data.y = this.origin.y;
      this.rep.textContent = this.content;
      this.transformations.commit();
      return Text.__super__.commit.apply(this, arguments);
    };

    Text.prototype.editableMode = function() {
      this.textEditable.show();
      this.hide();
      ui.textEditing = this;
      return ui.selection.elements.deselectAll();
    };

    Text.prototype.displayMode = function() {
      this.textEditable.hide();
      this.show();
      ui.textEditing = void 0;
      return this.adjustForScale();
    };

    Text.prototype.show = function() {
      return this.rep.style.display = "block";
    };

    Text.prototype.hide = function() {
      return this.rep.style.display = "none";
    };

    Text.prototype.originRotated = function() {
      return this.origin.clone().rotate(this.metadata.angle, this.center());
    };

    Text.prototype.simulateInSandbox = function() {
      return $("#text-sandbox").text(this.content).css({
        'font-size': this.data['font-size'],
        'font-family': this.data['font-family']
      });
    };

    Text.prototype.selectAll = function() {
      this.editableMode();
      this.textEditable.focus();
      document.execCommand('selectAll', false, null);
    };

    Text.prototype["delete"] = function() {
      Text.__super__["delete"].apply(this, arguments);
      return this.textEditable.hide();
    };

    Text.prototype.toSVG = function() {
      var self;
      self = Text.__super__.toSVG.apply(this, arguments);
      self.textContent = this.content;
      return self;
    };

    Text.prototype.normalizedOrigin = function() {
      return this.origin.clone().rotate(-this.metadata.angle, this.center());
    };

    Text.prototype.nudge = function(x, y) {
      this.origin.nudge(x, y);
      this.adjustForScale();
      return this.commit();
    };

    Text.prototype.rotate = function(a, origin, adjust) {
      var nc, oc;
      if (origin == null) {
        origin = this.center();
      }
      if (adjust == null) {
        adjust = true;
      }
      this.metadata.angle += a;
      this.metadata.angle %= 360;
      oc = this.center();
      nc = this.center().rotate(a, origin);
      this.origin.nudge(nc.x - oc.x, oc.y - nc.y);
      this.transformations.get('rotate').rotate(a);
      if (adjust) {
        this.adjustForScale();
      }
      return this.commit();
    };

    Text.prototype.scale = function(x, y, origin) {
      var angle;
      angle = this.metadata.angle;
      if (angle !== 0) {
        this.rotate(360 - angle, origin);
      }
      this.origin.scale(x, y, origin);
      this.transformations.get('scale').scale(x, y);
      this.adjustForScale();
      if (angle !== 0) {
        this.rotate(angle, origin);
      }
      return this.commit();
    };

    Text.prototype.adjustForScale = function() {
      var a, scale, translate;
      scale = this.transformations.get('scale');
      translate = this.transformations.get('translate');
      a = this.metadata.angle;
      this.rotate(-a, this.center(), false);
      translate.y = ((scale.y - 1) / scale.y) * -this.origin.y;
      translate.x = ((scale.x - 1) / scale.x) * -this.origin.x;
      this.rotate(a, this.center(), false);
      return this.commit();
    };

    Text.prototype.hover = function() {
      if (ui.selection.elements.all.has(this)) {

      }
      /*
      $("#text-underline").show().css
        left: @origin.x * ui.canvas.zoom
        top:  @origin.y * ui.canvas.zoom
        width: "#{@width() * ui.canvas.zoom}px"
      */

    };

    Text.prototype.unhover = function() {
      return $("#text-underline").hide();
    };

    Text.prototype.drawToCanvas = function() {};

    Text.prototype.clone = function() {
      var cloned;
      cloned = Text.__super__.clone.apply(this, arguments);
      cloned.setContent(this.content);
      return cloned;
    };

    Text.prototype.width = function() {
      this.simulateInSandbox();
      return $("#text-sandbox")[0].clientWidth * this.transformations.get('scale').x;
    };

    Text.prototype.height = function() {
      return this.data['font-size'] * this.transformations.get('scale').y;
    };

    Text.prototype.xRange = function() {
      return new Range(this.origin.x, this.origin.x + this.width());
    };

    Text.prototype.yRange = function() {
      return new Range(this.origin.y - this.height(), this.origin.y);
    };

    Text.prototype.overlapsRect = function(rect) {
      return this.bounds().toRect().overlaps(rect);
    };

    Text.prototype.setupToCavnas = function(context) {
      var orr, scale;
      scale = this.transformations.get('scale');
      orr = this.originRotated();
      context.translate(orr.x, orr.y);
      context.rotate(this.metadata.angle * (Math.PI / 180));
      context.scale(scale.x, scale.y);
      context.font = "" + this.data['font-size'] + "px " + this.data['font-family'];
      return context;
    };

    Text.prototype.drawToCanvas = function(context) {
      var scale;
      scale = this.transformations.get('scale');
      context = this.setupToCavnas(context);
      context.fillText(this.content.strip(), 0, 0);
      return context = this.finishToCanvas(context);
    };

    Text.prototype.finishToCanvas = function(context) {
      var orr, scale;
      scale = this.transformations.get('scale');
      orr = this.originRotated();
      context.scale(1 / scale.x, 1 / scale.y);
      context.rotate(-this.metadata.angle * (Math.PI / 180));
      context.translate(-orr.x, -orr.y);
      return context;
    };

    return Text;

  })(Monsvg);

  /*
  
    TextEditable
  
    A content-editable <p> that lives in the #typography div
    Used to edit the contents of a Text object, each of which
    are tied to one of these.
  */


  TextEditable = (function() {
    function TextEditable(owner) {
      this.owner = owner;
    }

    TextEditable.prototype.refresh = function() {
      var left, myOffset, ownerOffset, resetToBlank, top, tr;
      this.$rep.text(this.owner.content);
      if (this.owner.data['font-size'] != null) {
        this.$rep.css({
          'font-size': float(this.owner.data['font-size']) * ui.canvas.zoom + 'px'
        });
      }
      if (this.owner.data['font-family'] != null) {
        this.$rep.css({
          'font-family': this.owner.data['font-family']
        });
      }
      tr = this.owner.transformations.get('translate');
      if (this.owner.rep.textContent === '') {
        resetToBlank = true;
        this.owner.rep.textContent = '[FILLER]';
        this.$rep.text('[FILLER]');
      }
      ownerOffset = this.owner.$rep.offset();
      left = ownerOffset.left - ui.canvas.normal.x;
      top = ownerOffset.top - ui.canvas.normal.y;
      this.$rep.css({
        left: left.px(),
        top: top.px(),
        color: this.owner.data.fill
      });
      /*
      @rep.style.textShadow = @owner.data.strokeWidth.px()
      @rep.style.webkitTextStrokeWidth = @owner.data.strokeWidth.px()
      */

      this.$rep.css;
      this.owner.transformations.applyAsCSS(this.rep);
      myOffset = this.$rep.offset();
      if (resetToBlank) {
        this.$rep.text('');
        this.owner.rep.textContent = '';
      }
      return this.$rep.css({
        left: (left + ownerOffset.left - myOffset.left).px(),
        top: (top + ownerOffset.top - myOffset.top).px()
      });
    };

    TextEditable.prototype.show = function() {
      var _this = this;
      this.$rep = $("<div class=\"text\" contenteditable=\"true\"\n   quarantine spellcheck=\"false\">" + this.owner.content + "</div>");
      this.rep = this.$rep[0];
      $('#typography').append(this.$rep);
      this.$rep.one('blur', function() {
        _this.commit();
        return _this.owner.displayMode();
      });
      this.rep.style.display = "block";
      return this.refresh();
    };

    TextEditable.prototype.hide = function() {
      if (this.rep == null) {
        return;
      }
      this.rep.remove();
      return this.rep = void 0;
    };

    TextEditable.prototype.focus = function() {
      return this.$rep.focus();
    };

    TextEditable.prototype.commit = function() {
      var newOr, oldOr;
      oldOr = this.owner.originRotated();
      this.owner.setContent(this.$rep.text().replace(/$\s+/g, ''));
      newOr = this.owner.originRotated();
      return this.owner.nudge(oldOr.x - newOr.x, oldOr.y - newOr.y);
    };

    return TextEditable;

  })();

  /*
  */


  Tspan = (function(_super) {
    __extends(Tspan, _super);

    Tspan.prototype.type = 'tspan';

    function Tspan(data) {
      this.data = data;
    }

    return Tspan;

  })(Monsvg);

  Test = (function() {
    function Test(expect, val, toEqual) {
      var begin, end;
      this.expect = expect;
      this.val = val;
      this.toEqual = toEqual;
      begin = new Date();
      this.result = this.val();
      end = new Date();
      this.runtime = end.valueOf() - begin.valueOf();
      if (this.result.toString() === this.toEqual.toString()) {
        this.printSuccess();
      } else {
        this.printFailure();
      }
    }

    Test.prototype.print = function(result, success) {
      return q("body").innerHTML += "<div class=\"" + (success ? "success" : "failed") + "\">" + result + "</div>";
    };

    Test.prototype.printSuccess = function() {
      return this.print("" + this.expect + " <b>success</b> in " + this.runtime + "ms", true);
    };

    Test.prototype.printFailure = function() {
      return this.print("" + this.expect + " <b>failed</b> in " + this.runtime + "ms\n  Expected: " + this.toEqual + "\n  Got:      " + this.result, false);
    };

    return Test;

  })();

  testData = '<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"\n   width="26px" height="28px" viewBox="0 0 26 26" enable-background="new 0 0 26 26" xml:space="preserve">\n<path fill="#454545" d="M8.125,17.874c0.447,0.447,1.201,0.425,1.674-0.048l8.027-8.027c0.474-0.474,0.495-1.227,0.048-1.674\n  c-0.446-0.447-1.199-0.425-1.675,0.049L8.175,16.2C7.7,16.675,7.678,17.428,8.125,17.874z M12.108,17.142\n  c0.116,0.228,0.177,0.487,0.177,0.755c0,0.446-0.171,0.863-0.482,1.175l-4.149,4.147C7.344,23.53,6.926,23.7,6.479,23.7\n  c-0.447,0-0.864-0.171-1.175-0.481L2.78,20.696c-0.311-0.312-0.482-0.729-0.482-1.178c0-0.447,0.172-0.863,0.482-1.174l4.148-4.149\n  c0.311-0.311,0.729-0.483,1.176-0.483c0.268,0,0.525,0.063,0.754,0.18l1.659-1.66c-0.708-0.543-1.56-0.816-2.413-0.816\n  c-1.015,0-2.03,0.385-2.799,1.156L1.155,16.72c-1.541,1.54-1.541,4.061,0,5.602l2.522,2.522C4.449,25.614,5.462,26,6.479,26\n  c1.015,0,2.031-0.386,2.801-1.156l4.147-4.146c1.418-1.418,1.53-3.664,0.338-5.215L12.108,17.142z M24.843,3.679l-2.521-2.523\n  C21.551,0.385,20.535,0,19.521,0c-1.016,0-2.031,0.385-2.802,1.155l-4.148,4.148c-1.417,1.417-1.529,3.664-0.339,5.214l1.66-1.659\n  c-0.116-0.229-0.179-0.486-0.179-0.754c0-0.447,0.172-0.865,0.481-1.176l4.149-4.148c0.311-0.311,0.728-0.482,1.177-0.482\n  c0.446,0,0.863,0.172,1.176,0.482l2.521,2.523C23.53,5.614,23.7,6.032,23.7,6.479c0,0.447-0.171,0.866-0.481,1.176l-4.147,4.147\n  c-0.312,0.312-0.729,0.482-1.175,0.482c-0.27,0-0.524-0.062-0.755-0.178l-1.659,1.659c0.708,0.544,1.561,0.816,2.414,0.816\n  c1.016,0,2.028-0.384,2.801-1.156l4.146-4.148C26.385,7.74,26.385,5.219,24.843,3.679z"/>\n</svg>';

  svgObject = new SVG(testData);

  window.png = pngObject = new PNG(svgObject);

  listOfElems = svgObject.elements;

  svgObjectFromElems = new SVG(listOfElems);

  new Test('SVG elem should parse its own width', (function() {
    return svgObject.metadata.width;
  }), 26);

  new Test('SVG elem should parse its own height', (function() {
    return svgObject.metadata.height;
  }), 28);

  new Test('SVG elem should have 1 element', (function() {
    return svgObject.elements.length;
  }), 1);

  new Test('SVG\'s elem should be a Path', (function() {
    return svgObject.elements[0].type;
  }), 'path');

  new Test('PNG.export', (function() {
    return pngObject["export"]();
  }), 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAcCAYAAAB/E6/TAAACD0lEQVRIS72V3W3CMBSFMYJ3Nmg2KGyQCnguTFA6QekE0AlKJyidoOEZUJMJygaFDeg7Ij0nspFjnBAnqJas/Nn387n3OBa1K7Rutzuo1+sThGqjb9Dny+XyTQ8tqnL6/f4cMR4scQh7VO8rgXRIHMcLBJ2hj4UQ9xJwgpUGGUo+sPqRWr3xLYGVAuVBbDCofXYGAcL0PMmAKSVmnXq9XiDTuHECAUJXfReBcIx04yfvnUBY4RQrnCAVu9Vq5TGA7/stXFphGG5zFEWlQAgYocA+FQL6RcDhcOjoML2Ox+Nx6AryEZN557VGCO5buP4C5AG053ubWZxAMlVes9lk8BOEYCjkH8EKya2RTIvaeBFqEspASbqUkiKQTJBhYaaIqWnblCAInUi70xSJQdDObH+WOuO3ssOK6aaxWRMqwQJauCZm0Nob0piM11sKlLXjlbts6YLlfQRkr+F7oGqVCXKBUImqmRkw6zlRlAXhZmw0Gj+6EgxnTd4Bu3OBCf03YRYRIA+gxLbKXVgUn28BegFoWliRNnGBiQNzImF4t1ebETXZAnpTBhRLR11MhZHiTlbhbSqFpiiAomFWKgyI1cJ5aRRIBY/eVzkodc6riUUOuku1srkuBbsGJDGTbdUodID3c/QR1CqD5J6mhRRlpEifWwmSUqSiypqNuFfQIxxas/V6TYWVmvN5VJb2b6A/ZmRufCqUZKUAAAAASUVORK5CYII=');

}).call(this);
