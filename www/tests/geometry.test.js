// Generated by CoffeeScript 1.6.3
/*

  Utils

  Random little snippets to make things easier.
  Default prototype extensions for String, Array, Math... everything

  Add miscellaneous helpers that can be useful in more than one file here, since
  this gets compiled before everything else.

         _____
        /__    \
        ___) E| -_
       \_____  -_  -_
                 -_  -_
                   -_  -_
                     -_ o |
                       -_ /     This is a wrench ok?
*/


(function() {
  var AntlerPoint, Antlers, Bounds, CONSTANTS, Circle, Color, CubicBezier, CurvePoint, CurveTo, DEBUGGING, Ellipse, Font, HorizTo, HoverTarget, Line, LineSegment, LineTo, Monsvg, MoveTo, Path, Point, PointsList, PointsSegment, Polygon, Polyline, Polynomial, Posn, Range, Ray, Rect, RotateTransformation, SETTINGS, ScaleTransformation, SmoothTo, Test, Text, TextEditable, Transformations, TranslateTransformation, Tspan, VertiTo, allowsHotkeys, async, blob1, blob2, bz, bz1, bz10, bz2, bz3, bz4, bz5, bz6, bz7, bz8, bz9, cleanUpNumber, cloneObject, ell1, float, hugepoly, int, isBezierControlHandle, isDefaultQuarantined, isHandle, isHoverTarget, isOnTopUI, isPointHandle, isSVGElement, isSVGElementInMain, isSwatch, isTextInput, isTransformerHandle, isUtilityWindow, ln1, ln110, ln2, ln3, ln4, ln5, ln6, ln7, ln8, objectValues, oots, p1, p2, p3, p4, pathfinder, pointsSegment, poly1, poly2, poly3, print, pth1, q, qa, queryElemByUUID, queryElemByZIndex, sortNumbers, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  print = function() {
    return console.log.apply(console, arguments);
  };

  async = function(fun) {
    return setTimeout(fun, 1);
  };

  q = function(query) {
    return document.querySelector.call(document, query);
  };

  qa = function(query) {
    return document.querySelectorAll.call(document, query);
  };

  window.uuid = function(len) {
    var chars, i, id, _i;
    if (len == null) {
      len = 20;
    }
    id = '';
    chars = ('abcdefghijklmnopqrstuvwxyz' + 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + '1234567890').split('');
    for (i = _i = 1; 1 <= len ? _i <= len : _i >= len; i = 1 <= len ? ++_i : --_i) {
      id += chars[parseInt(Math.random() * 62, 10)];
    }
    return id;
  };

  isSVGElement = function(target) {
    return target.namespaceURI === 'http://www.w3.org/2000/svg';
  };

  isSVGElementInMain = function(target) {
    return target.namespaceURI === 'http://www.w3.org/2000/svg' && $(target).closest("#main").length > 0 && target.id !== 'main';
  };

  isPointHandle = function(target) {
    return target.className === 'transform handle point';
  };

  isBezierControlHandle = function(target) {
    return target.className === 'transform handle point bz-ctrl';
  };

  isTransformerHandle = function(target) {
    return target.className.mentions('transform handle');
  };

  isHoverTarget = function(target) {
    var _ref;
    return ((_ref = target.parentNode) != null ? _ref.id : void 0) === 'hover-targets';
  };

  isHandle = function(target) {
    if (target.nodeName.toLowerCase() === 'div') {
      return target.className.mentions('handle');
    }
    return false;
  };

  isTextInput = function(target) {
    return target.nodeName.toLowerCase() === "input" && target.getAttribute("type") === "text";
  };

  isUtilityWindow = function(target) {
    return target.className.mentions("utility-window") || $(target).closest('.utility-window').length > 0;
  };

  isSwatch = function(target) {
    return target.className.mentions("swatch");
  };

  isOnTopUI = function(target) {
    var cl;
    if (typeof target.className === "string") {
      cl = target.className.split(" ");
      if (cl.has("disabled")) {
        return false;
      }
      if (cl.has("tool-button")) {
        return "tb";
      } else if (cl.has("menu")) {
        return "menu";
      } else if (cl.has("menu-item")) {
        return "menu-item";
      } else if (cl.has("menu-dropdown")) {
        return "dui";
      }
    }
    if (target.hasAttribute("buttontext")) {
      return true;
    }
    if (target.nodeName.toLowerCase() === "a") {
      return true;
    }
    if (target.id === "hd-file-loader") {
      return "file-loader";
    } else if (isTextInput(target)) {
      return "text-input";
    } else if (isUtilityWindow(target)) {
      return "utility-window";
    } else if (isSwatch(target)) {
      return "swatch";
    }
    return false;
  };

  allowsHotkeys = function(target) {
    return $(target).closest("[h]").length > 0;
  };

  isDefaultQuarantined = function(target) {
    if (target.hasAttribute("quarantine")) {
      return true;
    } else if ($(target).closest("[quarantine]").length > 0) {
      return true;
    } else {
      return false;
    }
  };

  queryElemByUUID = function(uuid) {
    return ui.queryElement(q('#main [uuid="' + uuid + '"]'));
  };

  queryElemByZIndex = function(zi) {
    return ui.queryElement(dom.$main.children()[zi]);
  };

  cleanUpNumber = function(n) {
    n = n.roundIfWithin(SETTINGS.MATH.POINT_ROUND_DGAF);
    n = n.places(SETTINGS.MATH.POINT_DECIMAL_PLACES);
    return n;
  };

  int = function(n) {
    return parseInt(n, 10);
  };

  float = function(n) {
    return parseFloat(n);
  };

  oots = Object.prototype.toString;

  Object.prototype.toString = function() {
    var e;
    if (this instanceof $) {
      return "$('" + this.selector + "') object";
    } else {
      try {
        return JSON.stringify(this);
      } catch (_error) {
        e = _error;
        return oots.call(this);
      }
    }
  };

  objectValues = function(obj) {
    var key, val, vals;
    vals = [];
    for (key in obj) {
      if (!__hasProp.call(obj, key)) continue;
      val = obj[key];
      vals.push(val);
    }
    return vals;
  };

  cloneObject = function(obj) {
    var key, newo, val;
    newo = new Object();
    for (key in obj) {
      if (!__hasProp.call(obj, key)) continue;
      val = obj[key];
      newo[key] = val;
    }
    return newo;
  };

  sortNumbers = function(a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else if (a === b) {
      return 0;
    }
  };

  CONSTANTS = {
    MATCHERS: {
      POINT: /[MLCSHV][\-\de\.\,\-\s]+/gi
    }
  };

  SETTINGS = {
    PRODUCTION: !(/localhost/.test(document.location.host)),
    MEOWSET: {
      AVAILABLE: true,
      ENDPOINT: this.PRODUCTION ? "http://localhost:8000" : "http://meowset.mondrian.io"
    },
    SVG_NAMESPACE: "http://www.w3.org/2000/svg",
    MATH: {
      POINT_DECIMAL_PLACES: 5,
      POINT_ROUND_DGAF: 1e-5
    },
    DOUBLE_CLICK_THRESHOLD: 600
  };

  /*
  
    Management class for fontfaces
  */


  Font = (function() {
    function Font(name) {
      this.name = name;
    }

    Font.prototype.toListItem = function() {
      return $("<div class=\"dropdown-item\" style=\"font-family: '" + this.name + "'\">\n  " + this.name + "\n</div>");
    };

    return Font;

  })();

  /*
  
    Color
  
    A nice lil' class for representing and manipulating colors.
  */


  Color = (function() {
    function Color(r, g, b, a) {
      var rgb, vals;
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a != null ? a : 1.0;
      if (this.r instanceof Color) {
        return this.r;
      }
      if (this.r === null) {
        this.hex = "none";
      } else if (this.r === "none") {
        this.hex = "none";
        this.r = null;
        this.g = null;
        this.b = null;
      } else {
        if (typeof this.r === "string") {
          if (this.r.charAt(0) === "#" || this.r.length === 6) {
            this.hex = this.r.toUpperCase().replace("#", "");
            rgb = this.hexToRGB(this.hex);
            this.r = rgb.r;
            this.g = rgb.g;
            this.b = rgb.b;
          } else if (this.r.match(/rgba?\(.*\)/gi) != null) {
            vals = this.r.match(/[\d\.]+/gi);
            this.r = vals[0];
            this.g = vals[1];
            this.b = vals[2];
            if (vals[3] != null) {
              this.a = parseFloat(vals[3]);
            }
            this.hex = this.rgbToHex(this.r, this.g, this.b);
          }
        } else {
          if ((this.g == null) && (this.b == null)) {
            this.g = this.r;
            this.b = this.r;
          }
          this.hex = this.rgbToHex(this.r, this.g, this.b);
        }
        this.r = Math.min(this.r, 255);
        this.g = Math.min(this.g, 255);
        this.b = Math.min(this.b, 255);
        this.r = Math.max(this.r, 0);
        this.g = Math.max(this.g, 0);
        this.b = Math.max(this.b, 0);
      }
      if (isNaN(this.r || isNaN(this.g || isNaN(this.b)))) {
        if (isNaN(this.r)) {
          this.r = 0;
        }
        if (isNaN(this.g)) {
          this.g = 0;
        }
        if (isNaN(this.b)) {
          this.b = 0;
        }
        debugger;
        this.updateHex();
      }
    }

    Color.prototype.clone = function() {
      return new Color(this.r, this.g, this.b);
    };

    Color.prototype.absorb = function(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      this.a = color.a;
      this.hex = color.hex;
      if (typeof this.refresh === "function") {
        this.refresh();
      }
      return this;
    };

    Color.prototype.min = function() {
      return [this.r, this.g, this.b].sort(function(a, b) {
        return a - b;
      })[0];
    };

    Color.prototype.mid = function() {
      return [this.r, this.g, this.b].sort(function(a, b) {
        return a - b;
      })[1];
    };

    Color.prototype.max = function() {
      return [this.r, this.g, this.b].sort(function(a, b) {
        return a - b;
      })[2];
    };

    Color.prototype.midpoint = function() {
      return this.max() / 2;
    };

    Color.prototype.valToHex = function(val) {
      var chars;
      chars = '0123456789ABCDEF';
      return chars.charAt((val - val % 16) / 16) + chars.charAt(val % 16);
    };

    Color.prototype.hexToVal = function(hex) {
      var chars;
      chars = '0123456789ABCDEF';
      return chars.indexOf(hex.charAt(0)) * 16 + chars.indexOf(hex.charAt(1));
    };

    Color.prototype.rgbToHex = function(r, g, b) {
      return "" + (this.valToHex(r)) + (this.valToHex(g)) + (this.valToHex(b));
    };

    Color.prototype.hexToRGB = function(hex) {
      var b, g, r;
      r = this.hexToVal(hex.substring(0, 2));
      g = this.hexToVal(hex.substring(2, 4));
      b = this.hexToVal(hex.substring(4, 6));
      return {
        r: r,
        g: g,
        b: b
      };
    };

    Color.prototype.recalculateHex = function() {
      return this.hex = this.rgbToHex(this.r, this.g, this.b);
    };

    Color.prototype.darken = function(amt) {
      var macro;
      macro = function(val) {
        return val / amt;
      };
      return new Color(macro(this.r), macro(this.g), macro(this.b));
    };

    Color.prototype.lightness = function() {
      return ((this.min() + this.max()) / 2) / 255;
    };

    Color.prototype.saturation = function() {
      var d, max, min, sat;
      max = this.max();
      min = this.min();
      d = max - min;
      sat = this.lightness() >= 0.5 ? d / (510 - max - min) : d / (max + min);
      if (isNaN(sat)) {
        sat = 1.0;
      }
      return sat;
    };

    Color.prototype.desaturate = function(amt) {
      var mpt;
      if (amt == null) {
        amt = 1.0;
      }
      mpt = this.midpoint();
      this.r -= (this.r - mpt) * amt;
      this.g -= (this.g - mpt) * amt;
      this.b -= (this.b - mpt) * amt;
      this.hex = this.rgbToHex(this.r, this.g, this.b);
      return this;
    };

    Color.prototype.lighten = function(amt) {
      if (amt == null) {
        amt = 0.5;
      }
      amt *= 255;
      this.r = Math.min(255, this.r + amt);
      this.g = Math.min(255, this.g + amt);
      this.b = Math.min(255, this.b + amt);
      this.hex = this.rgbToHex(this.r, this.g, this.b);
      return this;
    };

    Color.prototype.toRGBString = function() {
      if (this.r === null) {
        return "none";
      } else {
        return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.a + ")";
      }
    };

    Color.prototype.toHexString = function() {
      return "#" + this.hex;
    };

    Color.prototype.toString = function() {
      this.removeNaNs();
      return this.toRGBString();
    };

    Color.prototype.removeNaNs = function() {
      if (isNaN(this.r)) {
        this.r = 0;
      }
      if (isNaN(this.g)) {
        this.g = 0;
      }
      if (isNaN(this.b)) {
        return this.b = 0;
      }
    };

    Color.prototype.equal = function(c) {
      return this.toHexString() === c.toHexString();
    };

    Color.prototype.updateHex = function() {
      return this.hex = this.rgbToHex(this.r, this.g, this.b);
    };

    return Color;

  })();

  window.Color = Color;

  Transformations = (function() {
    function Transformations(owner, transformations) {
      var transform,
        _this = this;
      this.owner = owner;
      this.transformations = transformations;
      transform = this.owner.rep.getAttribute("transform");
      this.transformations.map(function(t) {
        return t.family = _this;
      });
      if (transform != null) {
        this.parseExisting(transform);
      }
    }

    Transformations.prototype.commit = function() {
      return this.owner.data.transform = this.toAttr();
    };

    Transformations.prototype.toAttr = function() {
      return this.transformations.map(function(t) {
        return t.toAttr();
      }).join(" ");
    };

    Transformations.prototype.toCSS = function() {
      return this.transformations.map(function(t) {
        return t.toCSS();
      }).join(" ");
    };

    Transformations.prototype.get = function(key) {
      var f;
      f = this.transformations.filter(function(t) {
        return t.key === key;
      });
      if (f.length > 0) {
        return f[0];
      }
    };

    Transformations.prototype.parseExisting = function(transform) {
      var alreadyDefined, keyword, newlyDefined, op, operations, _i, _len, _results;
      operations = transform.match(/\w+\([^\)]*\)/g);
      _results = [];
      for (_i = 0, _len = operations.length; _i < _len; _i++) {
        op = operations[_i];
        keyword = op.match(/^\w+/g)[0];
        alreadyDefined = this.get(keyword);
        if (alreadyDefined != null) {
          _results.push(alreadyDefined.parse(op));
        } else {
          newlyDefined = new {
            rotate: RotateTransformation,
            scale: ScaleTransformation
          }[keyword]().parse(op);
          newlyDefined.family = this;
          _results.push(this.transformations.push(newlyDefined));
        }
      }
      return _results;
    };

    Transformations.prototype.applyAsCSS = function(rep) {
      var og, tr;
      og = "-" + this.owner.origin.x + " -" + this.owner.origin.y;
      tr = this.toCSS();
      rep.style.transformOrigin = og;
      rep.style.webkitTransformOrigin = og;
      rep.style.mozTransformOrigin = og;
      rep.style.transform = tr;
      rep.style.webkitTransformOrigin = og;
      rep.style.webkitTransform = tr;
      rep.style.mozTransformOrigin = og;
      return rep.style.mozTransform = tr;
    };

    return Transformations;

  })();

  RotateTransformation = (function() {
    function RotateTransformation(deg, family) {
      this.deg = deg;
      this.family = family;
    }

    RotateTransformation.prototype.key = "rotate";

    RotateTransformation.prototype.toAttr = function() {
      return "rotate(" + (this.deg.places(3)) + " " + (this.family.owner.center().x.places(3)) + " " + (this.family.owner.center().y.places(3)) + ")";
    };

    RotateTransformation.prototype.toCSS = function() {
      return "rotate(" + (this.deg.places(3)) + "deg)";
    };

    RotateTransformation.prototype.rotate = function(a) {
      this.deg += a;
      this.deg %= 360;
      return this;
    };

    RotateTransformation.prototype.parse = function(op) {
      var x, y, _ref;
      return _ref = op.match(/[\d\.]+/g).map(parseFloat), this.deg = _ref[0], x = _ref[1], y = _ref[2], _ref;
    };

    return RotateTransformation;

  })();

  ScaleTransformation = (function() {
    function ScaleTransformation(x, y) {
      this.x = x != null ? x : 1;
      this.y = y != null ? y : 1;
    }

    ScaleTransformation.prototype.key = "scale";

    ScaleTransformation.prototype.toAttr = function() {
      return "scale(" + this.x + " " + this.y + ")";
    };

    ScaleTransformation.prototype.toCSS = function() {
      return "scale(" + this.x + ", " + this.y + ")";
    };

    ScaleTransformation.prototype.parse = function(op) {
      var _ref;
      return _ref = op.match(/[\d\.]+/g).map(parseFloat), this.x = _ref[0], this.y = _ref[1], _ref;
    };

    ScaleTransformation.prototype.scale = function(x, y) {
      if (x == null) {
        x = 1;
      }
      if (y == null) {
        y = 1;
      }
      this.x *= x;
      return this.y *= y;
    };

    return ScaleTransformation;

  })();

  TranslateTransformation = (function() {
    function TranslateTransformation(x, y) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 1;
    }

    TranslateTransformation.prototype.key = "translate";

    TranslateTransformation.prototype.toAttr = function() {
      return "translate(" + this.x + " " + this.y + ")";
    };

    TranslateTransformation.prototype.toCSS = function() {
      return "translate(" + this.x + "px, " + this.y + "px)";
    };

    TranslateTransformation.prototype.parse = function(op) {
      var _ref;
      return _ref = op.match(/[\-\d\.]+/g).map(parseFloat), this.x = _ref[0], this.y = _ref[1], _ref;
    };

    TranslateTransformation.prototype.nudge = function(x, y) {
      console.log(x, y);
      this.x += x;
      return this.y -= y;
    };

    return TranslateTransformation;

  })();

  /*
  
    Posn
  
      •
        (x, y)
  
  
    Lowest-level geometry class.
  
    Consists of x, y coordinates. Provides methods for manipulating or representing 
    the point in two-dimensional space.
  
    Superclass: Point
  */


  Posn = (function() {
    function Posn(x, y, zoomLevel) {
      var split;
      this.x = x;
      this.y = y;
      this.zoomLevel = zoomLevel != null ? zoomLevel : 1.0;
      if (this.x instanceof Object) {
        if ((this.x.clientX != null) && (this.x.clientY != null)) {
          this.y = this.x.clientY;
          this.x = this.x.clientX;
        } else if ((this.x.left != null) && (this.x.top != null)) {
          this.y = this.x.top;
          this.x = this.x.left;
        } else if ((this.x.x != null) && (this.x.y != null)) {
          this.y = this.x.y;
          this.x = this.x.x;
        }
      } else if ((typeof this.x === "string") && (this.x.mentions(","))) {
        split = this.x.split(",").map(parseFloat);
        x = split[0];
        y = split[1];
        this.x = x;
        this.y = y;
      }
      this;
    }

    Posn.prototype.cleanUp = function() {
      return;
      this.x = cleanUpNumber(this.x);
      return this.y = cleanUpNumber(this.y);
    };

    Posn.prototype.zoomed = function(level) {
      if (level == null) {
        level = ui.canvas.zoom;
      }
      if (this.zoomLevel === level) {
        return this;
      }
      this.unzoomed();
      this.alterValues(function(val) {
        return val *= level;
      });
      this.zoomLevel = level;
      return this;
    };

    Posn.prototype.unzoomed = function() {
      var _this = this;
      if (this.zoomLevel === 1.0) {
        return;
      }
      this.alterValues(function(val) {
        return val /= _this.zoomLevel;
      });
      this.zoomLevel = 1.0;
      return this;
    };

    Posn.prototype.setZoom = function(zoomLevel) {
      this.zoomLevel = zoomLevel;
      this.x /= this.zoomLevel;
      this.y /= this.zoomLevel;
      return this;
    };

    Posn.prototype.zoomedc = function() {
      return this.clone().zoomed();
    };

    Posn.prototype.unzoomedc = function() {
      return this.clone.unzoomed();
    };

    Posn.prototype.alterValues = function(fun) {
      var a, _i, _len, _ref;
      _ref = ["x", "y", "x2", "y2", "x3", "y3"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        this[a] = this[a] != null ? fun(this[a]) : this[a];
      }
      return this;
    };

    Posn.prototype.toString = function() {
      return "" + this.x + "," + this.y;
    };

    Posn.prototype.toConstructorString = function() {
      return "new Posn(" + this.x + "," + this.y + ")";
    };

    Posn.prototype.nudge = function(x, y) {
      this.x += x;
      this.y -= y;
      return this;
    };

    Posn.prototype.lerp = function(b, factor) {
      return new Posn(this.x + (b.x - this.x) * factor, this.y + (b.y - this.y) * factor);
    };

    Posn.prototype.gte = function(p) {
      return this.x >= p.x && this.y >= p.y;
    };

    Posn.prototype.lte = function(p) {
      return this.x <= p.x && this.y <= p.y;
    };

    Posn.prototype.directionRelativeTo = function(p) {
      return "" + (this.y < p.y ? "t" : (this.y > p.y ? "b" : "")) + (this.x < p.x ? "l" : (this.x > p.x ? "r" : ""));
    };

    Posn.prototype.squareUpAgainst = function(p) {
      var direction, xDiff, yDiff;
      xDiff = Math.abs(this.x - p.x);
      yDiff = Math.abs(this.y - p.y);
      direction = this.directionRelativeTo(p);
      if ((xDiff === 0) && (yDiff === 0)) {
        return p;
      }
      switch (direction) {
        case "tl":
          if (xDiff < yDiff) {
            this.nudge(xDiff - yDiff, 0);
          } else if (yDiff < xDiff) {
            this.nudge(0, xDiff - yDiff, 0);
          }
          break;
        case "tr":
          if (xDiff < yDiff) {
            this.nudge(yDiff - xDiff, 0);
          } else if (yDiff < xDiff) {
            this.nudge(0, xDiff - yDiff);
          }
          break;
        case "br":
          if (xDiff < yDiff) {
            this.nudge(yDiff - xDiff, 0);
          } else if (yDiff < xDiff) {
            this.nudge(0, yDiff - xDiff);
          }
          break;
        case "bl":
          if (xDiff < yDiff) {
            this.nudge(xDiff - yDiff, 0);
          } else if (yDiff < xDiff) {
            this.nudge(0, yDiff - xDiff);
          }
          break;
        case "t":
        case "b":
          this.nudge(yDiff, 0);
          break;
        case "r":
        case "l":
          this.nudge(0, xDiff);
      }
      return this;
    };

    Posn.prototype.equal = function(p) {
      return this.x === p.x && this.y === p.y;
    };

    Posn.prototype.min = function(p) {
      return new Posn(Math.min(this.x, p.x), Math.min(this.y, p.y));
    };

    Posn.prototype.max = function(p) {
      return new Posn(Math.max(this.x, p.x), Math.max(this.y, p.y));
    };

    Posn.prototype.angle360 = function(base) {
      var a;
      a = 90 - new LineSegment(base, this).angle;
      return a + (this.x < base.x ? 180 : 0);
    };

    Posn.prototype.rotate = function(angle, origin) {
      var x, y;
      if (origin == null) {
        origin = new Posn(0, 0);
      }
      if (origin.equal(this)) {
        return this;
      }
      angle *= Math.PI / 180;
      this.x -= origin.x;
      this.y -= origin.y;
      x = (this.x * (Math.cos(angle))) - (this.y * Math.sin(angle));
      y = (this.x * (Math.sin(angle))) + (this.y * Math.cos(angle));
      this.x = x + origin.x;
      this.y = y + origin.y;
      return this;
    };

    Posn.prototype.scale = function(x, y, origin) {
      if (origin == null) {
        origin = new Posn(0, 0);
      }
      this.x += (this.x - origin.x) * (x - 1);
      this.y += (this.y - origin.y) * (y - 1);
      return this;
    };

    Posn.prototype.copy = function(p) {
      this.x = p.x;
      return this.y = p.y;
    };

    Posn.prototype.clone = function() {
      return new Posn(this.x, this.y, this.zoomLevel);
    };

    Posn.prototype.snap = function(to, threshold) {
      var perpLine;
      if (threshold == null) {
        threshold = Math.INFINITY;
      }
      perpLine = this.verti(10000);
      perpLine.rotate(to.angle360() + 90, this);
      return perpLine.intersection(to);
    };

    Posn.prototype.reflect = function(posn) {
      /*
      
        Reflect the point over an x and/or y axis
      
        I/P:
          posn: Posn
      */

      var x, y;
      x = posn.x;
      y = posn.y;
      return new Posn(x + (x - this.x), y + (y - this.y));
    };

    Posn.prototype.distanceFrom = function(p) {
      return new LineSegment(this, p).length;
    };

    Posn.prototype.perpendicularDistanceFrom = function(ls) {
      var inter, len, ray;
      ray = this.verti(1e5);
      ray.rotate(ls.angle360() + 90, this);
      inter = ray.intersection(ls);
      if (inter != null) {
        ls = new LineSegment(this, inter);
        len = ls.length;
        return [len, inter, ls];
      } else {
        return null;
      }
    };

    Posn.prototype.multiplyBy = function(s) {
      var np;
      switch (typeof s) {
        case 'number':
          np = this.clone();
          np.x *= s;
          np.y *= s;
          return np;
        case 'object':
          np = this.clone();
          np.x *= s.x;
          np.y *= s.y;
          return np;
      }
    };

    Posn.prototype.multiplyByMutable = function(s) {
      this.x *= s;
      this.y *= s;
      if (this.x2 != null) {
        this.x2 *= s;
        this.y2 *= s;
      }
      if (this.x3 != null) {
        this.x3 *= s;
        return this.y3 *= s;
      }
    };

    Posn.prototype.add = function(s) {
      switch (typeof s) {
        case 'number':
          return new Posn(this.x + s, this.y + s);
        case 'object':
          return new Posn(this.x + s.x, this.y + s.y);
      }
    };

    Posn.prototype.subtract = function(s) {
      switch (typeof s) {
        case 'number':
          return new Posn(this.x - s, this.y - s);
        case 'object':
          return new Posn(this.x - s.x, this.y - s.y);
      }
    };

    Posn.prototype.setPrec = function(prec) {
      this.prec = prec;
    };

    Posn.prototype.setSucc = function(succ) {
      this.succ = succ;
    };

    /*
        I love you artur
        hackerkate nows the sick code
    */


    Posn.prototype.inRanges = function(xr, yr) {
      return xr.contains(this.x && yr.contains(this.y));
    };

    Posn.prototype.inRangesInclusive = function(xr, yr) {
      return xr.containsInclusive(this.x) && yr.containsInclusive(this.y);
    };

    Posn.prototype.verti = function(ln) {
      return new LineSegment(this.clone().nudge(0, -ln), this.clone().nudge(0, ln));
    };

    Posn.prototype.insideOf = function(shape) {
      var counter, ray;
      if (shape instanceof Polygon || shape instanceof Path) {
        ray = new LineSegment(this, new Posn(this.x + 1e+20, this.y));
        counter = 0;
        shape.lineSegments().map(function(a) {
          var inter;
          inter = a.intersection(ray);
          if (inter instanceof Posn) {
            return ++counter;
          } else if (inter instanceof Array) {
            return counter += inter.length;
          }
        });
        return counter % 2 === 1;
      }
      if (shape instanceof Rect) {
        return shape.contains(this);
      }
    };

    Posn.prototype.dot = function(v) {
      return this.x * v.x + this.y * v.y;
    };

    Posn.prototype.within = function(tolerance, posn) {
      return Math.abs(this.x - posn.x) < tolerance && Math.abs(this.y - posn.y) < tolerance;
    };

    Posn.prototype.parseInt = function() {
      this.x = parseInt(this.x, 10);
      return this.y = parseInt(this.y, 10);
    };

    return Posn;

  })();

  /*
  
    Point
  
  
  
       o -----------
      /
     /
    /
  
    Tangible body for posn.
    Stored in PointsList for every shape.
    Comes in many flavors for a Path:
      MoveTo
      LineTo
      HorizTo
      VertiTo
      CurvePoint
        CurveTo
        SmoothTo
  
    This is the most heavily sub-classed class, even heavier than Monsvg.
    It's also the most heavily used, since all shapes are made of many of these.
  
    Needless to say, this is a very important class.
    Its efficiency basically decides the entire application's speed.
    (Not sure it's as good as it could be right now)
  */


  Point = (function(_super) {
    __extends(Point, _super);

    function Point(x, y, owner) {
      var p, prec;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.constructArgs = arguments;
      if ((this.x == null) && (this.y == null)) {
        return;
      }
      if (this.x instanceof Posn) {
        this.owner = this.y;
        this.y = this.x.y;
        this.x = this.x.x;
      } else if (this.x instanceof Object) {
        this.owner = this.y;
        if (this.x.clientX != null) {
          this.y = this.x.clientY;
          this.x = this.x.clientX;
        } else if ((this.x.x != null) && (this.x.y != null)) {
          this.y = this.x.y;
          this.x = this.x.x;
        }
      } else if (typeof this.x === "string") {
        if (this.owner != null) {
          prec = this.owner;
        }
        if (this.y != null) {
          this.owner = this.y;
        }
        p = this.fromString(this.x, prec);
        return p;
      }
      if (isNaN(this.x)) {
        console.warn('NaN x');
      }
      if (isNaN(this.y)) {
        console.warn('NaN y');
      }
      this._flags = [];
      this.makeAntlers();
      Point.__super__.constructor.call(this, this.x, this.y);
    }

    Point.prototype.fromString = function(point, prec) {
      var classes, clen, constructed, coords, elen, i, key, lengths, matched, pairs, patterns, points, relative, set, sliceAt, val, values, _i, _ref;
      patterns = {
        moveTo: /M[^A-Za-z]+/gi,
        lineTo: /L[^A-Za-z]+/gi,
        curveTo: /C[^A-Za-z]+/gi,
        smoothTo: /S[^A-Za-z]+/gi,
        horizTo: /H[^A-Za-z]+/gi,
        vertiTo: /V[^A-Za-z]+/gi
      };
      classes = {
        moveTo: MoveTo,
        lineTo: LineTo,
        curveTo: CurveTo,
        smoothTo: SmoothTo,
        horizTo: HorizTo,
        vertiTo: VertiTo
      };
      lengths = {
        moveTo: 2,
        lineTo: 2,
        curveTo: 6,
        smoothTo: 4,
        horizTo: 1,
        vertiTo: 1
      };
      pairs = /[-+]?\d*\.?\d*(e\-)?\d*/g;
      points = [];
      for (key in patterns) {
        val = patterns[key];
        matched = point.match(val);
        if (matched !== null) {
          coords = (point.match(pairs)).filter(function(p) {
            return p.length > 0;
          }).map(parseFloat);
          relative = point.substring(0, 1).match(/[mlcshv]/) !== null;
          clen = coords.length;
          elen = lengths[key];
          if (clen % elen === 0) {
            sliceAt = 0;
            for (i = _i = 0, _ref = (clen / elen) - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
              set = coords.slice(sliceAt, sliceAt + elen);
              if (i > 0) {
                if (key === "moveTo") {
                  key = "lineTo";
                }
              }
              values = [null].concat(set);
              values.push(this.owner);
              values.push(prec);
              values.push(relative);
              if (values.join(' ').mentions("NaN")) {
                debugger;
              }
              constructed = new (Function.prototype.bind.apply(classes[key], values));
              points.push(constructed);
              sliceAt += elen;
            }
          } else {
            throw new Error("Wrong amount of coordinates: " + point + ". Expected " + elen + " and got " + clen + ".");
          }
          break;
        }
      }
      if (points.length === 0) {
        throw new Error("Unreadable path value: " + point);
      }
      if (points.length === 1) {
        return points[0];
      } else {
        return points;
      }
    };

    Point.prototype.select = function() {
      this.show();
      this.showHandles();
      this.antlers.refresh();
      this.baseHandle.setAttribute('selected', '');
      return this;
    };

    Point.prototype.deselect = function() {
      this.baseHandle.removeAttribute('selected');
      if (typeof this.hideHandles === "function") {
        this.hideHandles();
      }
      this.hide();
      return this;
    };

    Point.prototype.draw = function() {
      var _ref;
      this.$baseHandle = $('<div class="transform handle point"></div>');
      this.baseHandle = this.$baseHandle[0];
      if (this.at === void 0) {
        if (!(this instanceof AntlerPoint)) {
          debugger;
        }
      }
      this.baseHandle.setAttribute('at', this.at);
      if (this.owner != null) {
        this.baseHandle.setAttribute('owner', this.owner.metadata.uuid);
      }
      this.updateHandle(this.baseHandle, this.x, this.y);
      if ((_ref = dom.ui) != null) {
        _ref.appendChild(this.baseHandle);
      }
      return this;
    };

    Point.prototype.makeAntlers = function() {
      var p2, p3;
      if (this.succ != null) {
        p2 = this.succ.p2 != null ? this.succ.p2() : void 0;
      } else {
        p2 = null;
      }
      p3 = this.p3 != null ? this.p3() : null;
      this.antlers = new Antlers(this, p3, p2);
      return this;
    };

    Point.prototype.showHandles = function() {
      return this.antlers.show();
    };

    Point.prototype.hideHandles = function() {
      return this.antlers.hide();
    };

    Point.prototype.absoluteCached = void 0;

    Point.prototype.prec = null;

    Point.prototype.succ = null;

    Point.prototype.actionHint = function() {
      return this.baseHandle.setAttribute('action', '');
    };

    Point.prototype.hideActionHint = function() {
      return this.baseHandle.removeAttribute('action');
    };

    Point.prototype.updateHandle = function(handle, x, y) {
      if (handle == null) {
        handle = this.baseHandle;
      }
      if (x == null) {
        x = this.x;
      }
      if (y == null) {
        y = this.y;
      }
      if (handle === void 0) {
        return;
      }
      handle.style.left = x * ui.canvas.zoom;
      handle.style.top = y * ui.canvas.zoom;
      return this;
    };

    Point.prototype.inheritPosition = function(from) {
      this.at = from.at;
      this.prec = from.prec;
      this.succ = from.succ;
      this.prec.succ = this;
      this.succ.prec = this;
      this.owner = from.owner;
      if (from.baseHandle != null) {
        this.baseHandle = from.baseHandle;
      }
      return this;
    };

    Point.prototype.nudge = function(x, y, checkForFirstOrLast) {
      var old, _ref;
      if (checkForFirstOrLast == null) {
        checkForFirstOrLast = true;
      }
      old = this.clone();
      Point.__super__.nudge.call(this, x, y);
      if ((_ref = this.antlers) != null) {
        _ref.nudge(x, y);
      }
      this.updateHandle();
      if (this.owner.type === 'path') {
        if (checkForFirstOrLast && this.owner.points.closed) {
          if ((this === this.owner.points.first) && this.owner.points.last.equal(old)) {
            return this.owner.points.last.nudge(x, y, false);
          } else if ((this === this.owner.points.last) && this.owner.points.first.equal(old)) {
            return this.owner.points.first.nudge(x, y, false);
          }
        }
      }
    };

    Point.prototype.rotate = function(a, origin) {
      var _ref;
      Point.__super__.rotate.call(this, a, origin);
      if ((_ref = this.antlers) != null) {
        _ref.rotate(a, origin);
      }
      return this.updateHandle();
    };

    Point.prototype.scale = function(x, y, origin, angle) {
      var _ref;
      Point.__super__.scale.call(this, x, y, origin, angle);
      if ((_ref = this.antlers) != null) {
        _ref.scale(x, y, origin, angle);
      }
      this.updateHandle();
      return this;
    };

    Point.prototype.replaceWith = function(point) {
      return this.owner.points.replace(this, point);
    };

    Point.prototype.toPosn = function() {
      return new Posn(this.x, this.y);
    };

    Point.prototype.toLineSegment = function() {
      return new LineSegment(this.prec, this);
    };

    /*
    
      Linked list action
    */


    Point.prototype.setSucc = function(succ) {
      this.succ = succ;
      return succ.prec = this;
    };

    Point.prototype.setPrec = function(prec) {
      return prec.setSucc(this);
    };

    /*
    
     Visibility functions for the UI
    */


    Point.prototype.show = function() {
      if (this.baseHandle == null) {
        return;
      }
      if (!this.baseHandle) {
        this.draw();
      }
      this.baseHandle.style.display = 'block';
      return this.baseHandle.style.opacity = 1;
    };

    Point.prototype.hide = function(force) {
      if (force == null) {
        force = false;
      }
      if (this.baseHandle == null) {
        return;
      }
      if (!this.baseHandle.hasAttribute('selected') || force) {
        this.baseHandle.style.opacity = 0;
        this.baseHandle.removeAttribute('action');
        this.hideHandles();
        return this.unhover();
      }
    };

    Point.prototype.hover = function() {
      var _ref;
      if ((_ref = this.baseHandle) != null) {
        _ref.setAttribute('hover', '');
      }
      if (this.baseHandle == null) {
        console.log("base handle missing");
      }
      if (this.at === 0) {
        return this.owner.points.last.baseHandle.setAttribute('hover', '');
      } else if (this === this.owner.points.last) {
        return this.owner.points.first.baseHandle.setAttribute('hover', '');
      }
    };

    Point.prototype.unhover = function() {
      var _ref;
      return (_ref = this.baseHandle) != null ? _ref.removeAttribute('hover') : void 0;
    };

    Point.prototype.clear = function() {
      this.baseHandle.style.display = 'none';
      return this;
    };

    Point.prototype.unclear = function() {
      this.baseHandle.style.display = 'block';
      return this;
    };

    Point.prototype.remove = function() {
      var _ref, _ref1;
      if ((_ref = this.antlers) != null) {
        _ref.hide();
      }
      return (_ref1 = this.baseHandle) != null ? _ref1.remove() : void 0;
    };

    Point.prototype.toStringWithZoom = function() {
      var str;
      this.multiplyByMutable(ui.canvas.zoom);
      str = this.toString();
      this.multiplyByMutable(1 / ui.canvas.zoom);
      return str;
    };

    Point.prototype.flag = function(flag) {
      return this._flags.ensure(flag);
    };

    Point.prototype.unflag = function(flag) {
      return this._flags.remove(flag);
    };

    Point.prototype.flagged = function(flag) {
      return this._flags.has(flag);
    };

    Point.prototype.annotate = function(color, radius) {
      return ui.annotations.drawDot(this, color, radius);
    };

    return Point;

  })(Posn);

  /*
  
    Polynomial
  */


  Polynomial = (function() {
    function Polynomial(coefs) {
      var i, l, v, _ref;
      this.coefs = coefs;
      l = this.coefs.length;
      _ref = this.coefs;
      for (i in _ref) {
        if (!__hasProp.call(_ref, i)) continue;
        v = _ref[i];
        this["p" + (l - i - 1)] = v;
      }
      this.coefs = this.coefs.reverse();
      this;
    }

    Polynomial.prototype.tolerance = 1e-6;

    Polynomial.prototype.accuracy = 6;

    Polynomial.prototype.degrees = function() {
      return this.coefs.length - 1;
    };

    Polynomial.prototype.interpolate = function(xs, xy, n, offset, x) {
      var c, d, den, diff, dift, dy, ho, hp, i, ns, result, w, y, _i, _j, _k, _ref, _ref1, _ref2;
      y = 0;
      dy = 0;
      ns = 0;
      c = [n];
      d = [n];
      diff = Math.abs(x - xs[offset]);
      for (i = _i = 0, _ref = n + 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        dift = Math.abs(x - xs[offset + i]);
        if (dift < diff) {
          ns = i;
          diff = dift;
        }
        c[i] = d[i] = ys[offset + i];
      }
      y = ys[offset + ns];
      ns -= 1;
      for (i = _j = 1, _ref1 = m + 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
        for (i = _k = 0, _ref2 = n - m + 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
          ho = xs[offset + i] - x;
          hp = xs[offset + i + m] - x;
          w = c[i + 1] - d[i];
          den = ho - hp;
          if (den === 0.0) {
            result = {
              y: 0,
              dy: 0
            };
            break;
          }
          den = w / den;
          d[i] = hp * den;
          c[i] = ho * den;
        }
        dy = 2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns -= 1];
        y += dy;
      }
      return {
        y: y,
        dy: dy
      };
    };

    Polynomial.prototype["eval"] = function(x) {
      var i, result, _i, _ref;
      result = 0;
      for (i = _i = _ref = this.coefs.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        result = result * x + this.coefs[i];
      }
      return result;
    };

    Polynomial.prototype.add = function(that) {
      var d1, d2, dmax, i, newCoefs, v1, v2, _i;
      newCoefs = [];
      d1 = this.degrees();
      d2 = that.degrees();
      dmax = Math.max(d1, d2);
      for (i = _i = 0; 0 <= dmax ? _i <= dmax : _i >= dmax; i = 0 <= dmax ? ++_i : --_i) {
        v1 = i <= d1 ? this.coefs[i] : 0;
        v2 = i <= d2 ? that.coefs[i] : 0;
        newCoefs[i] = v1 + v2;
      }
      newCoefs = newCoefs.reverse();
      return new Polynomial(newCoefs);
    };

    Polynomial.prototype.roots = function() {
      switch (this.coefs.length - 1) {
        case 0:
          return [];
        case 1:
          return this.linearRoot();
        case 2:
          return this.quadraticRoots();
        case 3:
          return this.cubicRoots();
        case 4:
          return this.quarticRoots();
        default:
          return [];
      }
    };

    Polynomial.prototype.derivative = function() {
      var i, newCoefs, _i, _ref;
      newCoefs = [];
      for (i = _i = 1, _ref = this.degrees(); 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        newCoefs.push(i * this.coefs[i]);
      }
      return new Polynomial(newCoefs.reverse());
    };

    Polynomial.prototype.bisection = function(min, max) {
      var i, iters, maxValue, minValue, result, tmp1, tmp2, value, _i, _ref;
      minValue = this["eval"](min);
      maxValue = this["eval"](max);
      if (Math.abs(minValue) <= this.tolerance) {
        return min;
      } else if (Math.abs(maxValue) <= this.tolerance) {
        return max;
      } else if (minValue * maxValue <= 0) {
        tmp1 = Math.log(max - min);
        tmp2 = Math.LN10 * this.accuracy;
        iters = Math.ceil((tmp1 + tmp2) / Math.LN2);
        for (i = _i = 0, _ref = iters - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          result = 0.5 * (min + max);
          value = this["eval"](result);
          if (Math.abs(value) <= this.tolerance) {
            break;
          }
          if (value * minValue < 0) {
            max = result;
            maxValue = value;
          } else {
            min = result;
            minValue = value;
          }
        }
      }
      return result;
    };

    Polynomial.prototype.rootsInterval = function(min, max) {
      var deriv, dlen, droots, i, r, results, root, _i, _ref;
      results = [];
      if (this.degrees() === 1) {
        root = this.bisection(min, max);
        if (root != null) {
          results.push(root);
        }
      } else {
        deriv = this.derivative();
        droots = deriv.rootsInterval(min, max);
        dlen = droots.length;
        if (dlen > 0) {
          root = this.bisection(min, droots[0]);
          if (root != null) {
            results.push(root);
          }
          for (i = _i = 0, _ref = dlen - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            r = droots[i];
            root = this.bisection(r, droots[i + 1]);
            if (root != null) {
              results.push(root);
            }
          }
          root = this.bisection(droots[dlen - 1], max);
          if (root != null) {
            results.push(root);
          }
        } else {
          root = this.bisection(min, max);
          if (root != null) {
            results.push(root);
          }
        }
      }
      return results;
    };

    Polynomial.prototype.linearRoot = function() {
      var result;
      result = [];
      if (this.p1 !== 0) {
        result.push(-this.p0 / this.p1);
      }
      return result;
    };

    Polynomial.prototype.quadraticRoots = function() {
      var a, b, c, d, e, results;
      results = [];
      a = this.p2;
      b = this.p1 / a;
      c = this.p0 / a;
      d = b * b - 4 * c;
      if (d > 0) {
        e = Math.sqrt(d);
        results.push(0.5 * (-b + e));
        results.push(0.5 * (-b - e));
      } else if (d === 0) {
        results.push(0.5 * -b);
      }
      return results;
    };

    Polynomial.prototype.cubicRoots = function() {
      var a, angle, b, c0, c1, c2, c3, cos, discrim, distance, e, halfB, offset, results, root, sin, sqrt3, tmp;
      results = [];
      c3 = this.p3;
      c2 = this.p2 / c3;
      c1 = this.p1 / c3;
      c0 = this.p0 / c3;
      a = (3 * c1 - c2 * c2) / 3;
      b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;
      offset = c2 / 3;
      discrim = b * b / 4 + a * a * a / 27;
      halfB = b / 2;
      if ((Math.abs(discrim)) <= 1e-6) {
        discrim = 0;
      }
      if (discrim > 0) {
        e = Math.sqrt(discrim);
        tmp = -halfB + e;
        root = tmp >= 0 ? Math.pow(tmp, 1 / 3) : -Math.pow(-tmp, 1 / 3);
        tmp = -halfB - e;
        root += tmp >= 0 ? Math.pow(tmp, 1 / 3) : -Math.pow(-tmp, 1 / 3);
        results.push(root - offset);
      } else if (discrim < 0) {
        distance = Math.sqrt(-a / 3);
        angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        sqrt3 = Math.sqrt(3);
        results.push(2 * distance * cos - offset);
        results.push(-distance * (cos + sqrt3 * sin) - offset);
        results.push(-distance * (cos - sqrt3 * sin) - offset);
      } else {
        if (halfB >= 0) {
          tmp = -Math.pow(halfB, 1 / 3);
        } else {
          tmp = Math.pow(-halfB, 1 / 3);
        }
        results.push(2 * tmp - offset);
        results.push(-tmp - offset);
      }
      return results;
    };

    return Polynomial;

  })();

  Range = (function() {
    function Range(min, max) {
      this.min = min;
      this.max = max;
    }

    Range.prototype.length = function() {
      return this.max - this.min;
    };

    Range.prototype.contains = function(n) {
      return n > this.min && n < this.max;
    };

    Range.prototype.containsInclusive = function(n, tolerance) {
      if (tolerance == null) {
        tolerance = 0;
      }
      return n >= this.min - tolerance && n <= this.max + tolerance;
    };

    Range.prototype.intersects = function(n) {
      return n === this.min || n === this.max;
    };

    Range.prototype.fromList = function(alon) {
      this.min = Math.min.apply(this, alon);
      this.max = Math.max.apply(this, alon);
      return this;
    };

    Range.prototype.fromRangeList = function(alor) {
      var maxs, mins;
      mins = alor.map(function(r) {
        return r.min;
      });
      maxs = alor.map(function(r) {
        return r.max;
      });
      this.min = Math.min.apply(this, mins);
      this.max = Math.max.apply(this, maxs);
      return this;
    };

    Range.prototype.nudge = function(amt) {
      this.min += amt;
      return this.max += amt;
    };

    Range.prototype.scale = function(amt, origin) {
      this.min += (this.min - origin) * (amt - 1);
      return this.max += (this.max - origin) * (amt - 1);
    };

    Range.prototype.toString = function() {
      return "[" + (this.min.places(4)) + "," + (this.max.places(4)) + "]";
    };

    Range.prototype.percentageOfValue = function(v) {
      return (v - this.min) / this.length();
    };

    return Range;

  })();

  Bounds = (function() {
    function Bounds(x, y, width, height) {
      var minX;
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      if (this.x instanceof Array) {
        minX = Math.min.apply(this, this.x.map(function(b) {
          return b.x;
        }));
        this.y = Math.min.apply(this, this.x.map(function(b) {
          return b.y;
        }));
        this.x2 = Math.max.apply(this, this.x.map(function(b) {
          return b.x2;
        }));
        this.y2 = Math.max.apply(this, this.x.map(function(b) {
          return b.y2;
        }));
        this.x = minX;
        this.width = this.x2 - this.x;
        this.height = this.y2 - this.y;
      } else if (this.x instanceof Posn && this.y instanceof Posn) {
        x = Math.min(this.x.x, this.y.x);
        y = Math.min(this.x.y, this.y.y);
        this.x2 = Math.max(this.x.x, this.y.x);
        this.y2 = Math.max(this.x.y, this.y.y);
        this.x = x;
        this.y = y;
        this.width = this.x2 - this.x;
        this.height = this.y2 - this.y;
      } else {
        this.x2 = this.x + this.width;
        this.y2 = this.y + this.height;
      }
      this.xr = new Range(this.x, this.x + this.width);
      this.yr = new Range(this.y, this.y + this.height);
    }

    Bounds.prototype.tl = function() {
      return new Posn(this.x, this.y);
    };

    Bounds.prototype.tr = function() {
      return new Posn(this.x2, this.y);
    };

    Bounds.prototype.br = function() {
      return new Posn(this.x2, this.y2);
    };

    Bounds.prototype.bl = function() {
      return new Posn(this.x, this.y2);
    };

    Bounds.prototype.clone = function() {
      return new Bounds(this.x, this.y, this.width, this.height);
    };

    Bounds.prototype.toRect = function() {
      return new Rect({
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      });
    };

    Bounds.prototype.center = function() {
      return new Posn(this.x + (this.width / 2), this.y + (this.height / 2));
    };

    Bounds.prototype.points = function() {
      return [new Posn(this.x, this.y), new Posn(this.x2, this.y), new Posn(this.x2, this.y2), new Posn(this.x, this.y2)];
    };

    Bounds.prototype.contains = function(posn, tolerance) {
      return this.xr.containsInclusive(posn.x, tolerance) && this.yr.containsInclusive(posn.y, tolerance);
    };

    Bounds.prototype.overlapsBounds = function(other, recur) {
      if (recur == null) {
        recur = true;
      }
      return this.toRect().overlaps(other.toRect());
    };

    Bounds.prototype.nudge = function(x, y) {
      this.x += x;
      this.x2 += x;
      this.y += y;
      this.y2 += y;
      this.xr.nudge(x);
      return this.yr.nudge(y);
    };

    Bounds.prototype.scale = function(x, y, origin) {
      var br, tl;
      tl = new Posn(this.x, this.y);
      br = new Posn(this.x2, this.y2);
      tl.scale(x, y, origin);
      br.scale(x, y, origin);
      this.x = tl.x;
      this.y = tl.y;
      this.x2 = br.x;
      this.y2 = br.y;
      this.width *= x;
      this.height *= y;
      this.xr.scale(x, origin);
      this.yr.scale(y, origin);
      return this;
    };

    Bounds.prototype.squareSmaller = function(anchor) {
      if (this.width < this.height) {
        return this.height = this.width;
      } else {
        return this.width = this.height;
      }
    };

    Bounds.prototype.centerOn = function(posn) {
      var offset;
      offset = posn.subtract(this.center());
      return this.nudge(offset.x, offset.y);
    };

    Bounds.prototype.fitTo = function(bounds) {
      var sh, sm, sw;
      sw = this.width / bounds.width;
      sh = this.height / bounds.height;
      sm = Math.max(sw, sh);
      return new Bounds(0, 0, this.width / sm, this.height / sm);
    };

    Bounds.prototype.adjustElemsTo = function(bounds) {
      var offset, sh, sw;
      offset = this.tl().subtract(bounds.tl());
      sw = this.width / bounds.width;
      sh = this.height / bounds.height;
      return function(elem) {
        elem.scale(1 / sw, 1 / sh, bounds.tl());
        return elem.nudge(-offset.x, offset.y);
      };
    };

    Bounds.prototype.annotateCorners = function() {
      ui.annotations.drawDot(this.tl());
      ui.annotations.drawDot(this.tr());
      ui.annotations.drawDot(this.bl());
      return ui.annotations.drawDot(this.br());
    };

    return Bounds;

  })();

  /*
  
    Antlers
  
       \
          \ O  -  (succx, succy)
            \\
              \
               \
                o
                 \
                  \
                  \\
                  \ O  -  (basex, basey)
                  |
                  |
                 /
                /
  
  
    Control handles for any vector Point. Edits base's x3 and base's succ's p2
    Each CurvePoint gets one of these. It keeps track of coordinates locally so we can
    draw these pre-emptively. For example, if you take the Pen tool and just drag a curve point right away,
    those curves don't exist yet but they come into play as soon as you add another point
    (...which will have to be a CurvePoint even if it's a static click)
  
    This class handles the GUI and updating the base and its succ's x2 y2 x3 y3. :)
  */


  Antlers = (function() {
    function Antlers(base, basep3, succp2) {
      var diff;
      this.base = base;
      this.basep3 = basep3;
      this.succp2 = succp2;
      if ((this.basep3 != null) && (this.succp2 != null)) {
        diff = Math.abs(this.basep3.angle360(this.base) - this.succp2.angle360(this.base));
        this.lockAngle = diff.within(this.angleLockThreshold, 180);
      } else {
        this.lockAngle = false;
      }
      this;
    }

    Antlers.prototype.angleLockThreshold = 0.5;

    Antlers.prototype.commit = function() {
      if (this.basep3 != null) {
        this.base.x3 = this.basep3.x;
        this.base.y3 = this.basep3.y;
      }
      if ((this.succp2 != null) && this.succ()) {
        this.succ().x2 = this.succp2.x;
        this.succ().y2 = this.succp2.y;
      }
      return this;
    };

    Antlers.prototype.importNewSuccp2 = function(succp2) {
      this.succp2 = succp2;
      if (this.succp2 != null) {
        this.basep3 = this.succp2.reflect(this.base);
      }
      return this.commit().refresh();
    };

    Antlers.prototype.killSuccp2 = function() {
      this.succp2 = new Posn(this.base.x, this.base.y);
      return this.commit().refresh();
    };

    Antlers.prototype.succ = function() {
      return this.base.succ;
    };

    Antlers.prototype.refresh = function() {
      if (!this.visible) {
        return;
      }
      return this.hide().show();
    };

    Antlers.prototype.visible = false;

    Antlers.prototype.show = function() {
      var _this = this;
      this.hide();
      this.visible = true;
      if (this.basep3 != null) {
        this.basep = new AntlerPoint(this.basep3.x, this.basep3.y, this.base.owner, this, -1);
      }
      if (this.succp2 != null) {
        this.succp = new AntlerPoint(this.succp2.x, this.succp2.y, this.base.owner, this, 1);
      }
      return (function() {
        return _this.hide();
      });
    };

    Antlers.prototype.hide = function() {
      var _ref, _ref1, _ref2;
      this.visible = false;
      if ((_ref = this.basep) != null) {
        _ref.remove();
      }
      if ((_ref1 = this.succp) != null) {
        _ref1.remove();
      }
      if ((_ref2 = this.base.owner.antlerPoints) != null) {
        _ref2.remove([this.basep, this.succp]);
      }
      return this;
    };

    Antlers.prototype.redraw = function() {
      this.hide();
      this.show();
      return this;
    };

    Antlers.prototype.hideTemp = function(p) {
      var _ref;
      return (_ref = (p === 2 ? this.succp : this.basep)) != null ? _ref.hideTemp() : void 0;
    };

    Antlers.prototype.nudge = function(x, y) {
      var _ref, _ref1;
      if ((_ref = this.basep3) != null) {
        _ref.nudge(x, y);
      }
      if ((_ref1 = this.succp2) != null) {
        _ref1.nudge(x, y);
      }
      if (this.succ() instanceof CurvePoint) {
        this.succ().x2 += x;
        this.succ().y2 -= y;
      }
      return this.commit();
    };

    Antlers.prototype.scale = function(x, y, origin) {
      var _ref, _ref1;
      if ((_ref = this.basep3) != null) {
        _ref.scale(x, y, origin);
      }
      return (_ref1 = this.succp2) != null ? _ref1.scale(x, y, origin) : void 0;
    };

    Antlers.prototype.rotate = function(a, origin) {
      var _ref, _ref1;
      if ((_ref = this.basep3) != null) {
        _ref.rotate(a, origin);
      }
      if ((_ref1 = this.succp2) != null) {
        _ref1.rotate(a, origin);
      }
      return this;
    };

    Antlers.prototype.other = function(p) {
      if (p === this.succp) {
        return this.basep;
      } else {
        return this.succp;
      }
    };

    Antlers.prototype.angleDiff = function(a, b) {
      var x;
      x = a - b;
      if (x < 0) {
        x += 360;
      }
      return x;
    };

    Antlers.prototype.flatten = function() {
      var ahead, angleBasep3, angleSuccp2, compensate, p2p3d, p3p2d;
      if ((this.succp2 == null) || (this.basep3 == null)) {
        return;
      }
      angleSuccp2 = this.succp2.angle360(this.base);
      angleBasep3 = this.basep3.angle360(this.base);
      p2p3d = this.angleDiff(angleSuccp2, angleBasep3);
      p3p2d = this.angleDiff(angleBasep3, angleSuccp2);
      if (p2p3d < p3p2d) {
        ahead = "p2";
      } else {
        ahead = "p3";
      }
      if (ahead === "p2") {
        if (p2p3d < 180) {
          compensate = (180 - p2p3d) / 2;
          this.succp2 = this.succp2.rotate(compensate, this.base);
          return this.basep3 = this.basep3.rotate(-compensate, this.base);
        }
      } else {
        if (p3p2d < 180) {
          compensate = (180 - p3p2d) / 2;
          this.succp2 = this.succp2.rotate(-compensate, this.base);
          return this.basep3 = this.basep3.rotate(compensate, this.base);
        }
      }
    };

    return Antlers;

  })();

  AntlerPoint = (function(_super) {
    __extends(AntlerPoint, _super);

    function AntlerPoint(x, y, owner, family, role) {
      var _ref;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.family = family;
      this.role = role;
      AntlerPoint.__super__.constructor.call(this, this.x, this.y, this.owner);
      this.draw();
      this.baseHandle.className += ' bz-ctrl';
      this.line = ui.annotations.drawLine(this.zoomedc(), this.family.base.zoomedc());
      if ((_ref = this.owner.antlerPoints) != null) {
        _ref.push(this);
      }
    }

    AntlerPoint.prototype.succ = function() {
      return this.family.base.succ;
    };

    AntlerPoint.prototype.base = function() {
      return this.family.base;
    };

    AntlerPoint.prototype.hideTemp = function() {
      var _this = this;
      this.line.rep.style.display = 'none';
      this.baseHandle.style.display = 'none';
      return function() {
        _this.line.rep.style.display = 'block';
        return _this.baseHandle.style.display = 'block';
      };
    };

    AntlerPoint.prototype.remove = function() {
      this.line.remove();
      return AntlerPoint.__super__.remove.apply(this, arguments);
    };

    AntlerPoint.prototype.nudge = function(x, y) {
      var newangle, oldangle, s, _ref;
      if (!this.family.lockAngle) {
        AntlerPoint.__super__.nudge.call(this, x, y);
        this.persist();
      } else {
        oldangle = this.angle360(this.family.base);
        AntlerPoint.__super__.nudge.call(this, x, y);
        newangle = this.angle360(this.family.base);
        if ((_ref = this.family.other(this)) != null) {
          _ref.rotate(newangle - oldangle, this.family.base);
        }
        this.persist();
      }
      if (this.role === -1 && this.family.base.succ instanceof SmoothTo) {
        s = this.family.base.succ;
        return s.replaceWith(s.toCurveTo());
      }
    };

    AntlerPoint.prototype.scale = function(x, y, origin) {
      AntlerPoint.__super__.scale.call(this, x, y, origin);
      return this.persist();
    };

    AntlerPoint.prototype.rotate = function(a, origin) {
      AntlerPoint.__super__.rotate.call(this, a, origin);
      return this.persist();
    };

    AntlerPoint.prototype.persist = function() {
      var first;
      if (this.role === -1) {
        this.family.basep3.copy(this);
      }
      if (this.role === 1) {
        this.family.succp2.copy(this);
      }
      if (this.family.base === this.owner.points.last) {
        first = this.owner.points.first;
        if (this.family.base.equal(first)) {
          first.antlers.succp2 = this.family.succp2.clone();
          first.antlers.basep3 = this.family.basep3.clone();
          first.antlers.commit();
        }
      }
      this.line.absorbA(this.family.base.zoomedc());
      this.line.absorbB(this.zoomedc());
      this.line.commit();
      return this.family.commit();
    };

    return AntlerPoint;

  })(Point);

  /*
  
    Path points
    
    MoveTo
      Mx,y
      Begin a path at x,y
  
    LineTo
      Lx,y
      Draw straight line from pvx,pvy to x,y
  
    CurveTo
      Cx1,y1 x2,y2 x,y
      Draw a line to x,y.
      x1,y1 is the control point put on the previous point
      x2,y2 is the control point put on this point (x,y)
  
    SmoothTo
      Sx2,y2 x,y
      Shorthand for curveto. x1,y1 becomes x2,y2 from previous CurveTo.
  
    HorizTo
      Hx
      Draw a horizontal line inheriting the y-value from precessor
  
    VertiTo
      Vy
      Draw a vertical line inheriting the x-value from precessor
  */


  MoveTo = (function(_super) {
    __extends(MoveTo, _super);

    function MoveTo(x, y, owner, prec, rel) {
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      MoveTo.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    MoveTo.prototype.relative = function() {
      var m, precAbs, x, y;
      if (this.at === 0) {
        this.rel = false;
        return this;
      } else {
        if (this.rel) {
          return this;
        }
        precAbs = this.prec.absolute();
        x = precAbs.x;
        y = precAbs.y;
        m = new MoveTo(this.x - x, this.y - y, this.owner);
        m.rel = true;
        return m;
      }
    };

    MoveTo.prototype.absolute = function() {
      var m, point, precAbs, x, y, _i, _len, _ref, _results;
      if (this.at === 0) {
        this.rel = false;
        return this;
      } else {
        if (!this.rel) {
          return this;
        }
        precAbs = this.prec.absolute();
        x = precAbs.x;
        y = precAbs.y;
        m = new MoveTo(this.x + x, this.y + y, this.owner);
        m.rel = false;
        return m;
      }
      _ref = points.match(/[MLCSHV][\-\de\.\,\-\s]+/gi);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        _results.push(new Point(point, this.owner));
      }
      return _results;
    };

    MoveTo.prototype.p2 = function() {
      var _ref;
      if (((_ref = this.antlers) != null ? _ref.succp2 : void 0) != null) {
        return new Posn(this.antlers.succp2.x, this.antlers.succp2.y);
      } else {
        return null;
      }
    };

    MoveTo.prototype.toString = function() {
      return "" + (this.rel ? "m" : "M") + this.x + "," + this.y;
    };

    MoveTo.prototype.toLineSegment = function() {
      return this.prec.toLineSegment();
    };

    MoveTo.prototype.clone = function() {
      return new MoveTo(this.x, this.y, this.owner, this.prec, this.rel);
    };

    return MoveTo;

  })(Point);

  LineTo = (function(_super) {
    __extends(LineTo, _super);

    function LineTo(x, y, owner, prec, rel) {
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      LineTo.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    LineTo.prototype.relative = function() {
      var l, precAbs, x, y;
      if (this.rel) {
        return this;
      }
      precAbs = this.prec.absolute();
      x = precAbs.x;
      y = precAbs.y;
      l = new LineTo(this.x - x, this.y - y, this.owner);
      l.rel = true;
      return l;
    };

    LineTo.prototype.absolute = function() {
      var l, precAbs, x, y;
      if (!this.rel) {
        return this;
      }
      if (this.absoluteCached) {
        return this.absoluteCached;
      }
      precAbs = this.prec.absolute();
      x = precAbs.x;
      y = precAbs.y;
      l = new LineTo(this.x + x, this.y + y, this.owner);
      l.rel = false;
      this.absoluteCached = l;
      return l;
    };

    LineTo.prototype.toString = function() {
      return "" + (this.rel ? 'l' : 'L') + this.x + "," + this.y;
    };

    LineTo.prototype.clone = function() {
      return new LineTo(this.x, this.y, this.owner, this.prec, this.rel);
    };

    return LineTo;

  })(Point);

  HorizTo = (function(_super) {
    __extends(HorizTo, _super);

    function HorizTo(x, owner, prec, rel) {
      this.x = x;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      this.inheritFromPrec(this.prec);
      HorizTo.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    HorizTo.prototype.inheritFromPrec = function(prec) {
      this.prec = prec;
      return this.y = this.prec.absolute().y;
    };

    HorizTo.prototype.toString = function() {
      return "" + (this.rel ? 'h' : 'H') + this.x;
    };

    HorizTo.prototype.convertToLineTo = function() {
      var lineTo;
      lineTo = new LineTo(this.x, this.y);
      this.replaceWith(lineTo);
      return lineTo;
    };

    HorizTo.prototype.rotate = function(a, origin) {
      return this.convertToLineTo().rotate(a, origin);
    };

    HorizTo.prototype.absolute = function() {
      if (!this.rel) {
        return this;
      }
      if (this.absoluteCached) {
        return this.absoluteCached;
      }
      return this.absoluteCached = new HorizTo(this.x + this.prec.absolute().x, this.owner, this.prec, false);
    };

    HorizTo.prototype.relative = function() {
      if (this.rel) {
        return this;
      }
      return new HorizTo(this.x - this.prec.absolute().x, this.owner, this.prec, true);
    };

    HorizTo.prototype.clone = function() {
      return new HorizTo(this.x, this.owner, this.prec, this.rel);
    };

    return HorizTo;

  })(Point);

  VertiTo = (function(_super) {
    __extends(VertiTo, _super);

    function VertiTo(y, owner, prec, rel) {
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      this.inheritFromPrec(this.prec);
      VertiTo.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    VertiTo.prototype.inheritFromPrec = function(prec) {
      this.prec = prec;
      return this.x = this.prec.absolute().x;
    };

    VertiTo.prototype.toString = function() {
      return "" + (this.rel ? 'v' : 'V') + this.y;
    };

    VertiTo.prototype.convertToLineTo = function() {
      var lineTo;
      lineTo = new LineTo(this.x, this.y);
      this.replaceWith(lineTo);
      return lineTo;
    };

    VertiTo.prototype.rotate = function(a, origin) {
      return this.convertToLineTo().rotate(a, origin);
    };

    VertiTo.prototype.absolute = function() {
      if (!this.rel) {
        return this;
      }
      if (this.absoluteCached) {
        return this.absoluteCached;
      }
      return this.absoluteCached = new VertiTo(this.y + this.prec.absolute().y, this.owner, this.prec, false);
    };

    VertiTo.prototype.relative = function() {
      if (this.rel) {
        return this;
      }
      return new VertiTo(this.y - this.prec.absolute().y, this.owner, this.prec, true);
    };

    VertiTo.prototype.clone = function() {
      return new VertiTo(this.y, this.owner, this.prec, this.rel);
    };

    return VertiTo;

  })(Point);

  /*
  
    CurvePoint
  
    A Point that has handles. Builds the handles in its constructor.
  */


  CurvePoint = (function(_super) {
    __extends(CurvePoint, _super);

    function CurvePoint(x2, y2, x3, y3, x, y, owner, prec, rel) {
      this.x2 = x2;
      this.y2 = y2;
      this.x3 = x3;
      this.y3 = y3;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      /*
      
        This Class just extends into CurveTo and SmoothTo as a way of abstracting out the curve
        handling the control points. It has two control points in addition to the base point (handled by super)
      
        Each point has a predecessor and a successor (in terms of line segments).
      
        It has two control points:
          (@x2, @y2) is the first curve control point (p2), which becomes @p2h
          (@x3, @y3) is the second (p3), which becomes @p3h
        (Refer to ASCII art at top of cubic-bezier-line-segment.coffee for point name reference)
      
        Dragging these mofos will alter the correct control point(s), which will change the curve
      
        I/P:
          x2, y2: control point (p2)
          x3, y3: control point (p3)
          x, y:   next base point (like any other point)
          owner:  elem that owns this shape (supered into Point)
          prec:   point that comes before it
          rel:    bool - true if it's relative or false if it's absolute
      */

      CurvePoint.__super__.constructor.call(this, this.x, this.y, this.owner);
    }

    CurvePoint.prototype.p2 = function() {
      return new Posn(this.x2, this.y2);
    };

    CurvePoint.prototype.p3 = function() {
      return new Posn(this.x3, this.y3);
    };

    CurvePoint.prototype.p = function() {
      return new Posn(this.x, this.y);
    };

    CurvePoint.prototype.absorb = function(p, n) {
      this["x" + n] = p.x;
      return this["y" + n] = p.y;
    };

    CurvePoint.prototype.show = function() {
      if (!this.owner) {
        return this;
      }
      return CurvePoint.__super__.show.apply(this, arguments);
    };

    CurvePoint.prototype.cleanUp = function() {
      return;
      this.x2 = cleanUpNumber(this.x2);
      this.y2 = cleanUpNumber(this.y2);
      this.x3 = cleanUpNumber(this.x3);
      this.y3 = cleanUpNumber(this.y3);
      return CurvePoint.__super__.cleanUp.apply(this, arguments);
    };

    CurvePoint.prototype.scale = function(x, y, origin) {
      this.absorb(this.p2().scale(x, y, origin), 2);
      this.absorb(this.p3().scale(x, y, origin), 3);
      return CurvePoint.__super__.scale.call(this, x, y, origin);
    };

    CurvePoint.prototype.rotate = function(a, origin) {
      this.absorb(this.p2().rotate(a, origin), 2);
      this.absorb(this.p3().rotate(a, origin), 3);
      return CurvePoint.__super__.rotate.call(this, a, origin);
    };

    CurvePoint.prototype.relative = function() {
      var args, c, precAbs, x, y;
      if (this.rel) {
        return this;
      }
      precAbs = this.prec.absolute();
      x = precAbs.x;
      y = precAbs.y;
      args = [this.x2 - x, this.y2 - y, this.x3 - x, this.y3 - y, this.x - x, this.y - y, this.owner, this.prec];
      if (this.constructor === SmoothTo) {
        args = args.slice(2);
      }
      args.unshift(null);
      c = new (Function.prototype.bind.apply(this.constructor, args));
      c.rel = true;
      return c;
    };

    CurvePoint.prototype.absolute = function() {
      var args, c, precAbs, x, y;
      if (!this.rel) {
        return this;
      }
      precAbs = this.prec.absolute();
      x = precAbs.x;
      y = precAbs.y;
      args = [this.x2 + x, this.y2 + y, this.x3 + x, this.y3 + y, this.x + x, this.y + y, this.owner, this.prec];
      if (this.constructor === SmoothTo) {
        args = args.slice(2);
      }
      args.unshift(null);
      c = new (Function.prototype.bind.apply(this.constructor, args));
      c.rel = false;
      return c;
    };

    return CurvePoint;

  })(Point);

  CurveTo = (function(_super) {
    __extends(CurveTo, _super);

    function CurveTo(x2, y2, x3, y3, x, y, owner, prec, rel) {
      this.x2 = x2;
      this.y2 = y2;
      this.x3 = x3;
      this.y3 = y3;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      CurveTo.__super__.constructor.call(this, this.x2, this.y2, this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
    }

    CurveTo.prototype.toString = function() {
      return "" + (this.rel ? 'c' : 'C') + this.x2 + "," + this.y2 + " " + this.x3 + "," + this.y3 + " " + this.x + "," + this.y;
    };

    CurveTo.prototype.reverse = function() {
      return new CurveTo(this.x3, this.y3, this.x2, this.y2, this.x, this.y, this.owner, this.prec, this.rel).inheritPosition(this);
    };

    CurveTo.prototype.clone = function() {
      return new CurveTo(this.x2, this.y2, this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
    };

    return CurveTo;

  })(CurvePoint);

  SmoothTo = (function(_super) {
    __extends(SmoothTo, _super);

    function SmoothTo(x3, y3, x, y, owner, prec, rel) {
      this.x3 = x3;
      this.y3 = y3;
      this.x = x;
      this.y = y;
      this.owner = owner;
      this.prec = prec;
      this.rel = rel;
      this.inheritFromPrec(this.prec);
      SmoothTo.__super__.constructor.call(this, this.x2, this.y2, this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
    }

    SmoothTo.prototype.inheritFromPrec = function(prec) {
      var p2, precAbs;
      this.prec = prec;
      if (this.prec instanceof CurvePoint) {
        precAbs = this.prec.absolute();
        p2 = new Posn(precAbs.x3, precAbs.y3).reflect(precAbs);
      } else {
        p2 = new Posn(this.x, this.y);
      }
      this.x2 = p2.x;
      return this.y2 = p2.y;
    };

    SmoothTo.prototype.toCurveTo = function(p2) {
      var ct;
      if (p2 == null) {
        p2 = null;
      }
      if (p2 === null) {
        if (this.prec instanceof CurvePoint) {
          p2 = this.prec.p3().reflect(this.prec.p());
        } else {
          p2 = new Posn(this.x, this.y);
        }
      }
      ct = new CurveTo(p2.x, p2.y, this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
      ct.at = this.at;
      return ct;
    };

    SmoothTo.prototype.replaceWithCurveTo = function(p2) {
      if (p2 == null) {
        p2 = null;
      }
      return this.replaceWith(this.toCurveTo(p2));
    };

    SmoothTo.prototype.toString = function() {
      return "" + (this.rel ? 's' : 'S') + this.x3 + "," + this.y3 + " " + this.x + "," + this.y;
    };

    SmoothTo.prototype.reverse = function() {
      return new CurveTo(this.x3, this.y3, this.x2, this.y2, this.x, this.y, this.owner, this.prec, this.rel);
    };

    SmoothTo.prototype.clone = function() {
      return new SmoothTo(this.x3, this.y3, this.x, this.y, this.owner, this.prec, this.rel);
    };

    return SmoothTo;

  })(CurvePoint);

  /*
  
    PointsList
  
    Stores points, keeps them in order, lets you do shit
    Basically a linked-list.
  */


  PointsList = (function() {
    function PointsList(alop, owner, segments) {
      var accumulatedSegment, commitSegment, ind, lastPoint, point,
        _this = this;
      this.owner = owner;
      this.segments = segments != null ? segments : [];
      if (typeof alop === "string") {
        alop = this.stringToAlop(alop);
      }
      accumulatedSegment = [];
      lastPoint = void 0;
      commitSegment = function() {
        var sgmt;
        if (accumulatedSegment.length === 0) {
          return;
        }
        sgmt = new PointsSegment(accumulatedSegment, _this);
        _this.lastSegment = sgmt;
        if (_this.firstSegment === null) {
          _this.firstSegment = sgmt;
        }
        _this.segments.push(sgmt);
        return accumulatedSegment = [];
      };
      if (this.segments.length !== 0) {
        this.firstSegment = this.segments[0];
        this.lastSegment = this.segments[this.segments.length - 1];
      }
      if (alop.length === 0) {
        return;
      }
      for (ind in alop) {
        if (!__hasProp.call(alop, ind)) continue;
        point = alop[ind];
        ind = parseInt(ind, 10);
        point.at = ind;
        if (ind === 0) {
          this.first = point;
        }
        if (ind === alop.length - 1) {
          this.last = point;
        }
        point.setPrec((lastPoint != null ? lastPoint : alop[alop.length - 1]));
        if (lastPoint != null) {
          lastPoint.setSucc(point);
        }
        if (point instanceof MoveTo) {
          commitSegment();
        }
        accumulatedSegment.push(point);
        lastPoint = point;
      }
      commitSegment();
      lastPoint.setSucc(this.first);
    }

    PointsList.prototype.first = null;

    PointsList.prototype.last = null;

    PointsList.prototype.firstSegment = null;

    PointsList.prototype.lastSegment = null;

    PointsList.prototype.closed = false;

    PointsList.prototype.moveSegmentToFront = function(segment) {
      if (!(this.segments.has(segment))) {
        return;
      }
      return this.segments = this.segments.cannibalizeUntil(segment);
    };

    PointsList.prototype.movePointToFront = function(point) {
      this.moveSegmentToFront(point.segment);
      return point.segment.movePointToFront(point);
    };

    PointsList.prototype.stringToAlop = function(points) {
      var all_matches, p, point, previous, results, _i, _len;
      results = [];
      all_matches = points.match(CONSTANTS.MATCHERS.POINT);
      for (_i = 0, _len = all_matches.length; _i < _len; _i++) {
        point = all_matches[_i];
        p = new Point(point, this.owner, previous);
        if (p instanceof Point) {
          if (typeof previous !== "undefined" && previous !== null) {
            p.setPrec(previous);
          }
          previous = p;
          if ((p instanceof SmoothTo) && (this.owner instanceof Point)) {
            p.setPrec(this.owner);
          }
          results.push(p);
        } else if (p instanceof Array) {
          if (previous != null) {
            p[0].setPrec(previous);
            p.reduce(function(a, b) {
              return b.setPrec(a);
            });
          }
          results = results.concat(p);
        }
      }
      return results;
    };

    PointsList.prototype.firstPointThatEquals = function(point) {
      return this.filter(function(p) {
        return p.equal(point);
      })[0];
    };

    PointsList.prototype.closedOnSameSpot = function() {
      return this.closed && (this.last.equal(this.first));
    };

    PointsList.prototype.length = function() {
      return this.segments.reduce(function(a, b) {
        return a + b.points.length;
      }, 0);
    };

    PointsList.prototype.all = function() {
      var pts, s, _i, _len, _ref;
      pts = [];
      _ref = this.segments;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        s = _ref[_i];
        pts = pts.concat(s.points);
      }
      return pts;
    };

    PointsList.prototype.renumber = function() {
      return this.all().map(function(p, i) {
        p.at = i;
        return p;
      });
    };

    PointsList.prototype.pushSegment = function(sgmt) {
      this.lastSegment = sgmt;
      return this.segments.push(sgmt);
    };

    PointsList.prototype.push = function(point, after) {
      if (this.segments.length === 0) {
        this.pushSegment(new PointsSegment([], this));
      }
      point.owner = this.owner;
      if (after == null) {
        point.at = this.lastSegment.points.length;
        this.lastSegment.points.push(point);
        if (this.last != null) {
          this.last.setSucc(point);
          point.setPrec(this.last);
        } else {
          point.setPrec(point);
        }
        if (this.first != null) {
          this.first.setPrec(point);
          point.setSucc(this.first);
        } else {
          point.setSucc(point);
        }
        this.last = point;
        return this;
      }
    };

    PointsList.prototype.replace = function(old, replacement) {
      return this.segmentContaining(old).replace(old, replacement);
    };

    PointsList.prototype.reverse = function() {
      return new PointsList([], this.owner, this.segments.map(function(s) {
        return s.reverse();
      }));
    };

    PointsList.prototype.at = function(n) {
      return this.segmentContaining(parseInt(n, 10)).at(n);
    };

    PointsList.prototype.close = function() {
      this.closed = true;
      return this;
    };

    PointsList.prototype.relative = function() {
      this.segments = this.segments.map(function(s) {
        s.points = s.points.map(function(p) {
          var abs;
          abs = p.relative();
          abs.inheritPosition(p);
          return abs;
        });
        return s;
      });
      return this;
    };

    PointsList.prototype.absolute = function() {
      this.segments = this.segments.map(function(s) {
        s.points = s.points.map(function(p) {
          var abs;
          abs = p.absolute();
          abs.inheritPosition(p);
          return abs;
        });
        return s;
      });
      return this;
    };

    PointsList.prototype.drawBasePoints = function() {
      this.map(function(p) {
        var _ref;
        if ((_ref = p.baseHandle) != null) {
          _ref.remove();
        }
        p.draw();
        return p.makeAntlers();
      });
      return this;
    };

    PointsList.prototype.removeBasePoints = function() {
      this.map(function(p) {
        var _ref;
        return (_ref = p.baseHandle) != null ? _ref.remove() : void 0;
      });
      return this;
    };

    PointsList.prototype.hide = function() {
      return this.map(function(p) {
        return p.hide();
      });
    };

    PointsList.prototype.unhover = function() {
      return this.map(function(p) {
        return p.unhover();
      });
    };

    PointsList.prototype.join = function(x) {
      return this.all().join(x);
    };

    PointsList.prototype.segmentContaining = function(a) {
      var s, segm, segments, _i, _len, _ref;
      if (typeof a === "number") {
        _ref = this.segments;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          s = _ref[_i];
          if (s.startsAt <= a) {
            segm = s;
          } else {
            break;
          }
        }
        return segm;
      } else {
        segments = this.segments.filter(function(s) {
          return s.points.indexOf(a) > -1;
        });
        if (segments.length === 1) {
          return segments[0];
        }
      }
      return [];
    };

    PointsList.prototype.hasPointWithin = function(tolerance, point) {
      return this.filter(function(p) {
        return p.within(tolerance, point);
      }).length > 0;
    };

    PointsList.prototype.remove = function(x) {
      var p, _i, _len, _results;
      if (typeof x === "number") {
        x = this.at(x);
      }
      if (x instanceof Array) {
        _results = [];
        for (_i = 0, _len = x.length; _i < _len; _i++) {
          p = x[_i];
          _results.push(this.remove(p));
        }
        return _results;
      } else if (x instanceof Point) {
        return this.segmentContaining(x).remove(x);
      }
    };

    PointsList.prototype.filter = function(fun) {
      return this.all().filter(fun);
    };

    PointsList.prototype.filterSegments = function(fun) {
      return this.segments.map(function(segment) {
        return new PointsSegment(segment.points.filter(fun));
      });
    };

    PointsList.prototype.fetch = function(cl) {
      return this.all().filter(function(p) {
        return p instanceof cl;
      });
    };

    PointsList.prototype.map = function(fun) {
      return this.segments.map(function(s) {
        return s.points.map(fun);
      });
    };

    PointsList.prototype.forEach = function(fun) {
      return this.segments.forEach(function(s) {
        return s.points.forEach(fun);
      });
    };

    PointsList.prototype.mapApply = function(fun) {
      return this.segments.map(function(s) {
        return s.points = s.points.map(fun);
      });
    };

    PointsList.prototype.xRange = function() {
      var xs;
      xs = this.all().map(function(p) {
        return p.x;
      });
      return new Range(Math.min.apply(this, xs), Math.max.apply(this, xs));
    };

    PointsList.prototype.yRange = function() {
      var ys;
      ys = this.all().map(function(p) {
        return p.y;
      });
      return new Range(Math.min.apply(this, ys), Math.max.apply(this, ys));
    };

    PointsList.prototype.toString = function() {
      return this.segments.join(' ') + (this.closed ? "z" : "");
    };

    PointsList.prototype.insideOf = function(other) {
      return this.all().filter(function(p) {
        return p.insideOf(other);
      });
    };

    PointsList.prototype.notInsideOf = function(other) {
      return this.all().filter(function(p) {
        return !p.insideOf(other);
      });
    };

    PointsList.prototype.withoutMoveTos = function() {
      return new PointsList([], this.owner, this.filterSegments(function(p) {
        return !(p instanceof MoveTo);
      }));
    };

    return PointsList;

  })();

  /*
  
    PointsSegment
  
    A segment of points that starts with a MoveTo.
    A PointsList is composed of a list of these.
  */


  PointsSegment = (function() {
    function PointsSegment(points, list) {
      var _this = this;
      this.points = points;
      this.list = list;
      this.startsAt = this.points.length !== 0 ? this.points[0].at : 0;
      if (this.list != null) {
        this.owner = this.list.owner;
      }
      if (this.points[0] instanceof MoveTo) {
        this.moveTo = this.points[0];
      }
      this.points.forEach(function(p) {
        return p.segment = _this;
      });
      this;
    }

    PointsSegment.prototype.insert = function(point, at) {
      var head, tail;
      head = this.points.slice(0, at);
      tail = this.points.slice(at);
      if (point instanceof Array) {
        tail.forEach(function(p) {
          return p.at += point.length;
        });
        return head = head.concat(point);
      } else if (point instanceof Point) {
        tail.forEach(function(p) {
          return p.at += 1;
        });
        head[head.length - 1].setSucc(point);
        tail[0].setPrec(point);
        return head.push(point);
      } else {
        throw new Error("PointsList: don't know how to insert " + point + ".");
      }
    };

    PointsSegment.prototype.toString = function() {
      return this.points.join(' ');
    };

    PointsSegment.prototype.at = function(n) {
      return this.points[n - this.startsAt];
    };

    PointsSegment.prototype.remove = function(x) {
      x.prec.succ = x.succ;
      x.succ.prec = x.prec;
      if (x === this.list.last) {
        this.list.last = x.prec;
      }
      if (x === this.list.first) {
        this.list.first = x.succ;
      }
      this.points = this.points.remove(x);
      return x.remove();
    };

    PointsSegment.prototype.movePointToFront = function(point) {
      if (!(this.points.has(point))) {
        return;
      }
      this.removeMoveTo();
      this.points = this.points.cannibalizeUntil(point);
      return this;
    };

    PointsSegment.prototype.moveMoveTo = function(otherPoint) {
      var i, segment, tail, _i, _ref;
      tail = this.points.slice(1);
      for (i = _i = 0, _ref = otherPoint.at - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        segment = segment.cannibalize();
      }
      this.moveTo.copy(otherPoint);
      return this.points = [this.moveTo].concat(segment);
    };

    PointsSegment.prototype.replace = function(old, replacement) {
      var at, np, p, prec, replen, succ, _i, _j, _len, _len1, _ref;
      if (replacement instanceof Point) {
        replacement.inheritPosition(old);
        this.points = this.points.replace(old, replacement);
      } else if (replacement instanceof Array) {
        replen = replacement.length;
        at = old.at;
        prec = old.prec;
        succ = old.succ;
        old.succ.prec = replacement[replen - 1];
        for (_i = 0, _len = replacement.length; _i < _len; _i++) {
          np = replacement[_i];
          np.owner = this.owner;
          np.at = at;
          np.prec = prec;
          np.succ = succ;
          prec.succ = np;
          prec = np;
          at += 1;
        }
        this.points = this.points.replace(old, replacement);
        _ref = this.points.slice(at);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          p = _ref[_j];
          p.at += replen - 1;
        }
      }
      return replacement;
    };

    PointsSegment.prototype.validateLinks = function() {
      var i, p, prev, succ, _ref;
      console.log(this.points.map(function(p) {
        return "" + p.prec.at + " " + p.at + " " + p.succ.at;
      }));
      prev = this.points.length - 1;
      _ref = this.points;
      for (i in _ref) {
        if (!__hasProp.call(_ref, i)) continue;
        p = _ref[i];
        i = parseInt(i, 10);
        if (!(p.prec === this.points[prev])) {
          console.log(p, "prec wrong. Expecting", prev);
          debugger;
          return false;
          break;
        }
        succ = i === this.points.length - 1 ? 0 : i + 1;
        if (!(p.succ === this.points[succ])) {
          console.log(p, "succ wrong");
          return false;
          break;
        }
        prev = i;
      }
      return true;
    };

    PointsSegment.prototype.reverse = function() {
      var index, point, positions, stack, tailRev, _ref;
      this.removeMoveTo();
      positions = [];
      stack = [];
      _ref = this.points;
      for (index in _ref) {
        if (!__hasProp.call(_ref, index)) continue;
        point = _ref[index];
        stack.push(point);
        positions.push({
          x: point.x,
          y: point.y
        });
      }
      tailRev = stack.slice(1).reverse().map(function(p) {
        if (p instanceof CurvePoint) {
          return p.reverse();
        } else {
          return p;
        }
      });
      positions = positions.reverse();
      stack = stack.slice(0, 1).concat(tailRev);
      stack = stack.map(function(p, i) {
        var c, succ;
        c = positions[0];
        p.x = c.x;
        p.y = c.y;
        succ = p.succ;
        p.succ = p.prec;
        p.prec = succ;
        p.at = i;
        positions = positions.slice(1);
        return p;
      });
      return new PointsSegment(stack, this.list);
    };

    PointsSegment.prototype.removeMoveTo = function() {
      return this.points = this.points.filter(function(p) {
        return !(p instanceof MoveTo);
      });
    };

    PointsSegment.prototype.ensureMoveTo = function() {
      var firstPoint, lastPoint, moveTo;
      lastPoint = this.points.last();
      firstPoint = this.points.first();
      moveTo = new MoveTo(lastPoint.x, lastPoint.y, lastPoint.owner, lastPoint);
      moveTo.at = 0;
      lastPoint.succ = firstPoint.prec = moveTo;
      moveTo.succ = firstPoint;
      this.points.unshift(moveTo);
      return this;
    };

    return PointsSegment;

  })();

  /*
    Internal representation of a straight line segment
  
    a
     \
      \
       \
        \
         \
          \
           \
            b
  
    I/P:
      a: First point
      b: Second point
  */


  LineSegment = (function() {
    function LineSegment(a, b, source) {
      this.a = a;
      this.b = b;
      this.source = source != null ? source : this.toLineTo();
      this.calculate();
    }

    LineSegment.prototype.calculate = function() {
      this.slope = (this.a.y - this.b.y) / (this.b.x - this.a.x);
      this.angle = Math.atan(this.slope) / (Math.PI / 180);
      this.length = Math.sqrt(Math.pow(this.b.x - this.a.x, 2) + Math.pow(this.b.y - this.a.y, 2));
      return this;
    };

    LineSegment.prototype.beginning = function() {
      return this.a;
    };

    LineSegment.prototype.end = function() {
      return this.a;
    };

    LineSegment.prototype.toString = function() {
      return "(Line segment: " + (this.a.toString()) + " " + (this.b.toString()) + ")";
    };

    LineSegment.prototype.constructorString = function() {
      return "new LineSegment(" + (this.a.constructorString()) + ", " + (this.b.constructorString()) + ")";
    };

    LineSegment.prototype.angle360 = function() {
      return this.b.angle360(this.a);
    };

    LineSegment.prototype.toLineTo = function() {
      return new LineTo(this.b.x, this.b.y);
    };

    LineSegment.prototype.toSVGPoint = function() {
      return this.toLineTo();
    };

    LineSegment.prototype.reverse = function() {
      return new LineSegment(this.b, this.a);
    };

    LineSegment.prototype.bounds = function(useCached) {
      var height, maxx, maxy, minx, miny, width;
      if (useCached == null) {
        useCached = false;
      }
      if ((this.boundsCached != null) && useCached) {
        return this.boundsCached;
      }
      minx = Math.min(this.a.x, this.b.x);
      maxx = Math.max(this.a.x, this.b.x);
      miny = Math.min(this.a.y, this.b.y);
      maxy = Math.max(this.a.y, this.b.y);
      width = this.width();
      height = this.height();
      return this.boundsCached = new Bounds(minx, miny, width, height);
    };

    LineSegment.prototype.boundsCached = void 0;

    LineSegment.prototype.rotate = function(angle, origin) {
      return new LineSegment(this.a.rotate(angle, origin), this.b.rotate(angle, origin));
    };

    LineSegment.prototype.width = function() {
      return Math.abs(this.a.x - this.b.x);
    };

    LineSegment.prototype.height = function() {
      return Math.abs(this.a.y - this.b.y);
    };

    LineSegment.prototype.xRange = function() {
      return new Range(Math.min(this.a.x, this.b.x), Math.max(this.a.x, this.b.x));
    };

    LineSegment.prototype.yRange = function() {
      return new Range(Math.min(this.a.y, this.b.y), Math.max(this.a.y, this.b.y));
    };

    LineSegment.prototype.xDiff = function() {
      return Math.max(this.b.x, this.a.x) - Math.min(this.b.x, this.a.x);
    };

    LineSegment.prototype.xbaDiff = function() {
      return this.b.x - this.a.x;
    };

    LineSegment.prototype.yDiff = function() {
      return Math.max(this.b.y, this.a.y) - Math.min(this.b.y, this.a.y);
    };

    LineSegment.prototype.ybaDiff = function() {
      return this.b.y - this.a.y;
    };

    LineSegment.prototype.yAtX = function(x, extrapolate) {
      if (extrapolate == null) {
        extrapolate = true;
      }
      if (!extrapolate && !this.xRange().containsInclusive(x)) {
        return null;
      }
      return this.a.y + ((x - this.a.x) * this.slope);
    };

    LineSegment.prototype.xAtY = function(y, extrapolate) {
      if (extrapolate == null) {
        extrapolate = true;
      }
      if (!extrapolate && !this.yRange().containsInclusive(y)) {
        return null;
      }
      return this.a.x + ((y - this.a.y) / this.slope);
    };

    LineSegment.prototype.ends = function() {
      return [a, b];
    };

    LineSegment.prototype.posnAtPercent = function(p) {
      return new Posn(this.a.x + (this.b.x - this.a.x) * p, this.a.y + (this.b.y - this.a.y) * p);
    };

    LineSegment.prototype.findPercentageOfPoint = function(p) {
      var distanceA;
      distanceA = p.distanceFrom(this.a);
      return distanceA / (distanceA + p.distanceFrom(this.b));
    };

    LineSegment.prototype.splitAt = function(p, forced) {
      var distances, distancesSorted, key, nextA, posn, segments, split, _i, _j, _len, _len1;
      if (forced == null) {
        forced = null;
      }
      if (typeof p === "number") {
        split = forced ? forced : this.posnAtPercent(p);
        return [new LineSegment(this.a, split), new LineSegment(split, this.b)];
      } else if (p instanceof Array) {
        segments = [];
        distances = {};
        for (_i = 0, _len = p.length; _i < _len; _i++) {
          posn = p[_i];
          distances[posn.distanceFrom(this.a)] = posn;
        }
        distancesSorted = Object.keys(distances).map(parseFloat).sort(sortNumbers);
        nextA = this.a;
        for (_j = 0, _len1 = distancesSorted.length; _j < _len1; _j++) {
          key = distancesSorted[_j];
          posn = distances[key];
          segments.push(new LineSegment(nextA, posn));
          nextA = posn;
        }
        segments.push(new LineSegment(nextA, this.b));
        return segments;
      } else if (p instanceof Posn) {
        return [new LineSegment(this.a, p), new LineSegment(p, this.b)];
      }
    };

    LineSegment.prototype.midPoint = function() {
      return this.splitAt(0.5)[0].b;
    };

    LineSegment.prototype.nudge = function(x, y) {
      this.a.nudge(x, y);
      return this.b.nudge(x, y);
    };

    LineSegment.prototype.scale = function(x, y, origin) {
      this.a.scale(x, y, origin);
      return this.b.scale(x, y, origin);
    };

    LineSegment.prototype.equal = function(ls) {
      if (ls instanceof CubicBezier) {
        return false;
      }
      return ((this.a.equal(ls.a)) && (this.b.equal(ls.b))) || ((this.a.equal(ls.b)) && (this.b.equal(ls.a)));
    };

    LineSegment.prototype.intersects = function(s) {
      var inter;
      inter = this.intersection(s);
      return inter instanceof Posn || inter instanceof Array;
    };

    LineSegment.prototype.intersection = function(s) {
      if (s instanceof LineSegment) {
        return this.intersectionWithLineSegment(s);
      } else if (s instanceof Circle) {
        return this.intersectionWithCircle(s);
      } else if (s instanceof CubicBezier) {
        return s.intersectionWithLineSegment(this);
      }
    };

    LineSegment.prototype.intersectionWithLineSegment = function(s) {
      /*
        Get intersection with another LineSegment
      
        I/P : LineSegment
      
        O/P : If intersection exists, [x, y] coords of intersection
              If none exists, null
              If they're parallel, 0
              If they're coincident, Infinity
      
        Source: http://www.kevlindev.com/gui/math/intersection/Intersection.js
      */

      var ana_m, ana_s, anam, anas, crossDiff;
      ana_s = s.xbaDiff() * (this.a.y - s.a.y) - s.ybaDiff() * (this.a.x - s.a.x);
      ana_m = this.xbaDiff() * (this.a.y - s.a.y) - this.ybaDiff() * (this.a.x - s.a.x);
      crossDiff = s.ybaDiff() * this.xbaDiff() - s.xbaDiff() * this.ybaDiff();
      if (crossDiff !== 0) {
        anas = ana_s / crossDiff;
        anam = ana_m / crossDiff;
        if (0 <= anas && anas <= 1 && 0 <= anam && anam <= 1) {
          return new Posn(this.a.x + anas * (this.b.x - this.a.x), this.a.y + anas * (this.b.y - this.a.y));
        } else {
          return null;
        }
      } else {
        if (ana_s === 0 || ana_m === 0) {
          return Infinity;
        } else {
          return 0;
        }
      }
    };

    LineSegment.prototype.intersectionWithEllipse = function(s) {
      /*
       Get intersection with an ellipse
      
       I/P: Ellipse
      
       O/P: null if no intersections, or Array of Posn(s) if there are
      
        Source: http://www.kevlindev.com/gui/math/intersection/Intersection.js
      */

      var a, b, c, center, cx, cy, d, diff, dir, mDiff, mDir, origin, results, root, rx, ry, t, t_a, t_b;
      rx = s.data.rx;
      ry = s.data.ry;
      cx = s.data.cx;
      cy = s.data.cy;
      origin = new Posn(this.a.x, this.a.y);
      dir = new Posn(this.b.x - this.a.x, this.b.y - this.a.y);
      center = new Posn(cx, cy);
      diff = origin.subtract(center);
      mDir = new Posn(dir.x / (rx * rx), dir.y / (ry * ry));
      mDiff = new Posn(diff.x / (rx * rx), diff.y / (ry * ry));
      results = [];
      a = dir.dot(mDir);
      b = dir.dot(mDiff);
      c = diff.dot(mDiff) - 1.0;
      d = b * b - a * c;
      if (d < 0) {
        return null;
      } else if (d > 0) {
        root = Math.sqrt(d);
        t_a = (-b - root) / a;
        t_b = (-b + root) / a;
        if ((t_a < 0 || 1 < t_a) && (t_b < 0 || 1 < t_b)) {
          if ((t_a < 0 && t_b < 0) && (t_a > 1 && t_b > 1)) {
            return null;
          } else {
            return null;
          }
        } else {
          if (0 <= t_a && t_a <= 1) {
            results.push(this.a.lerp(this.b, t_a));
          }
          if (0 <= t_b && t_b <= 1) {
            results.push(this.a.lerp(this.b, t_b));
          }
        }
      } else {
        t = -b / a;
        if (0 <= t && t <= 1) {
          results.push(this.a.lerp(this.b, t));
        } else {
          return null;
        }
      }
      return results;
    };

    LineSegment.prototype.intersectionWithCircle = function(s) {
      /*
        Get intersection with a circle
      
        I/P : Circle
      
        O/P : If intersection exists, [x, y] coords of intersection
              If none exists, null
              If they're parallel, 0
              If they're coincident, Infinity
      
        Source: http://www.kevlindev.com/gui/math/intersection/Intersection.js
      */

      var a, b, cc, deter, e, ints, u1, u2;
      a = Math.pow(this.xDiff(), 2) + Math.pow(this.yDiff(), 2);
      b = 2 * ((this.b.x - this.a.x) * (this.a.x - s.data.cx) + (this.b.y - this.a.y) * (this.a.y - s.data.cy));
      cc = Math.pow(s.data.cx, 2) + Math.pow(s.data.cy, 2) + Math.pow(this.a.x, 2) + Math.pow(this.a.y, 2) - 2 * (s.data.cx * this.a.x + s.data.cy * this.a.y) - Math.pow(s.data.r, 2);
      deter = b * b - 4 * a * cc;
      if (deter < 0) {
        return null;
      } else if (deter === 0) {
        return 0;
      } else {
        e = Math.sqrt(deter);
        u1 = (-b + e) / (2 * a);
        u2 = (-b - e) / (2 * a);
        if ((u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1)) {
          if ((u1 < 0 && u2 < 0) || (u1 > 1 && u2 > 1)) {
            return null;
          } else {
            return true;
          }
        } else {
          ints = [];
          if (0 <= u1 && u1 <= 1) {
            ints.push(this.a.lerp(this.b, u1));
          }
          if (0 <= u2 && u2 <= 1) {
            ints.push(this.a.lerp(this.b, u2));
          }
          return ints;
        }
      }
    };

    return LineSegment;

  })();

  Ray = (function(_super) {
    __extends(Ray, _super);

    function Ray(a, angle) {
      this.a = a;
      this.angle = angle;
      Ray.__super__.constructor.call(this, this.a, this.a.clone().nudge(0, -1e5).rotate(this.angle, this.a));
    }

    return Ray;

  })(LineSegment);

  /*
    Internal representation of a cubic bezier line segment
  
    p1                                     p4
     o                                     o
      \\                                 //
       \\                               //
        \ \                           / /
         \   \                     /   /
          \     _               _     /
           \      __         __      /
            °       --_____--       °
             p2                    p3
  
    I/P:
      p1: First absolute point, the moveto
      p2: The first point's curve handle
      p3: The second point's curve handle
      p4: The second absolute point
  
      In context with syntax: M[p1]C[p2] [p3] [p4]
  */


  CubicBezier = (function() {
    function CubicBezier(p1, p2, p3, p4, source) {
      this.p1 = p1;
      this.p2 = p2;
      this.p3 = p3;
      this.p4 = p4;
      this.source = source != null ? source : this.toCurveTo();
    }

    /*
    toString: ->
      "(Cubic bezier: #{@p1},#{@p2},#{@p3},#{@p4})"
    */


    CubicBezier.prototype.toString = function() {
      return "new CubicBezier(" + this.p1 + ", " + this.p2 + ", " + this.p3 + ", " + this.p4 + ")";
    };

    CubicBezier.prototype.toCurveTo = function() {
      return new CurveTo(this.p2.x, this.p2.y, this.p3.x, this.p3.y, this.p4.x, this.p4.y);
    };

    CubicBezier.prototype.toSVGPoint = function() {
      return this.toCurveTo();
    };

    CubicBezier.prototype.length = function() {
      return this.intoLineSegments(4).reduce(function(a, b) {
        return a + b.length;
      });
    };

    CubicBezier.prototype.beginning = function() {
      return this.p1;
    };

    CubicBezier.prototype.end = function() {
      return this.p4;
    };

    CubicBezier.prototype.nudge = function(x, y) {
      this.p1.nudge(x, y);
      this.p2.nudge(x, y);
      this.p3.nudge(x, y);
      this.p4.nudge(x, y);
      return this;
    };

    CubicBezier.prototype.scale = function(x, y, origin) {
      this.p1.scale(x, y, origin);
      this.p2.scale(x, y, origin);
      this.p3.scale(x, y, origin);
      this.p4.scale(x, y, origin);
      return this;
    };

    CubicBezier.prototype.rotate = function(angle, origin) {
      this.p1.rotate(angle, origin);
      this.p2.rotate(angle, origin);
      this.p3.rotate(angle, origin);
      this.p4.rotate(angle, origin);
      return this;
    };

    CubicBezier.prototype.reverse = function() {
      return new CubicBezier(this.p4, this.p3, this.p2, this.p1);
    };

    CubicBezier.prototype.equal = function(cbls) {
      if (cbls instanceof LineSegment) {
        return false;
      }
      return ((this.p1.equal(cbls.p1)) && (this.p2.equal(cbls.p2)) && (this.p3.equal(cbls.p3)) && (this.p4.equal(cbls.p4))) || ((this.p1.equal(cbls.p4)) && (this.p2.equal(cbls.p3)) && (this.p3.equal(cbls.p2)) && (this.p4.equal(cbls.p1)));
    };

    CubicBezier.prototype.intersects = function(other) {
      var inter;
      inter = this.intersection(other);
      return inter instanceof Posn || (inter instanceof Array && inter.length > 0);
    };

    CubicBezier.prototype.intersection = function(other) {
      switch (other.constructor) {
        case LineSegment:
          return this.intersectionWithLineSegment(other);
        case CubicBezier:
          return this.intersectionWithCubicBezier(other);
      }
    };

    CubicBezier.prototype.xRange = function() {
      return this.bounds().xr;
    };

    CubicBezier.prototype.yRange = function() {
      return this.bounds().yr;
    };

    CubicBezier.prototype.ends = function() {
      return [this.p1, this.p4];
    };

    CubicBezier.prototype.midPoint = function() {
      return this.splitAt(0.5)[0].p4;
    };

    CubicBezier.prototype.bounds = function(useCached) {
      var d, height, i, maxx, maxy, minx, miny, px, py, qx, qy, rx, ry, sx, sy, top2x, top2y, top3x, top3y, top4x, top4y, toqx, toqy, torx, tory, totx, toty, tx, ty, width, x, y, _i;
      if (useCached == null) {
        useCached = false;
      }
      if ((this.boundsCached != null) && useCached) {
        return this.boundsCached;
      }
      minx = miny = Infinity;
      maxx = maxy = -Infinity;
      top2x = this.p2.x - this.p1.x;
      top2y = this.p2.y - this.p1.y;
      top3x = this.p3.x - this.p2.x;
      top3y = this.p3.y - this.p2.y;
      top4x = this.p4.x - this.p3.x;
      top4y = this.p4.y - this.p3.y;
      for (i = _i = 0; _i <= 40; i = ++_i) {
        d = i / 40;
        px = this.p1.x + d * top2x;
        py = this.p1.y + d * top2y;
        qx = this.p2.x + d * top3x;
        qy = this.p2.y + d * top3y;
        rx = this.p3.x + d * top4x;
        ry = this.p3.y + d * top4y;
        toqx = qx - px;
        toqy = qy - py;
        torx = rx - qx;
        tory = ry - qy;
        sx = px + d * toqx;
        sy = py + d * toqy;
        tx = qx + d * torx;
        ty = qy + d * tory;
        totx = tx - sx;
        toty = ty - sy;
        x = sx + d * totx;
        y = sy + d * toty;
        minx = Math.min(minx, x);
        miny = Math.min(miny, y);
        maxx = Math.max(maxx, x);
        maxy = Math.max(maxy, y);
        width = maxx - minx;
        height = maxy - miny;
      }
      return this.boundsCached = new Bounds(minx, miny, width, height);
    };

    CubicBezier.prototype.boundsCached = void 0;

    CubicBezier.prototype.intoLineSegments = function(n) {
      var i, last, m, segments, x, y, _i;
      segments = [];
      for (m = _i = 0; 0 <= n ? _i <= n : _i >= n; m = 0 <= n ? ++_i : --_i) {
        i = 1 / m;
        x = Math.pow(1 - i, 3) * this.p1.x + 3 * Math.pow(1 - i, 2) * i * this.p2.x + 3 * (1 - i) * Math.pow(i, 2) * this.p3.x + Math.pow(i, 3) * this.p4.x;
        y = Math.pow(1 - i, 3) * this.p1.y + 3 * Math.pow(1 - i, 2) * i * this.p2.y + 3 * (1 - i) * Math.pow(i, 2) * this.p3.y + Math.pow(i, 3) * this.p4.y;
        if (m % 2 === 0) {
          last = new Posn(x, y);
        } else {
          segments.push(new LineSegment(last, new Posn(x, y)));
        }
      }
      return segments.splice(1);
    };

    CubicBezier.prototype.splitAt = function(t, force) {
      var p10, p5, p6, p7, p8, p9, pair, perc, percent, percentages, posn, segments, sortedPosns, tail, _i, _j, _len, _len1;
      if (force == null) {
        force = null;
      }
      if (typeof t === "number") {
        p5 = new LineSegment(this.p1, this.p2).posnAtPercent(t);
        p6 = new LineSegment(this.p2, this.p3).posnAtPercent(t);
        p7 = new LineSegment(this.p3, this.p4).posnAtPercent(t);
        p8 = new LineSegment(p5, p6).posnAtPercent(t);
        p9 = new LineSegment(p6, p7).posnAtPercent(t);
        p10 = force ? force : new LineSegment(p8, p9).posnAtPercent(t);
        return [new CubicBezier(this.p1, p5, p8, p10), new CubicBezier(p10, p9, p7, this.p4)];
      } else if (t instanceof Posn) {
        return this.splitAt(this.findPercentageOfPoint(t), t);
      } else if (t instanceof Array) {
        sortedPosns = {};
        segments = [];
        for (_i = 0, _len = t.length; _i < _len; _i++) {
          posn = t[_i];
          percent = this.findPercentageOfPoint(posn);
          sortedPosns[percent] = posn;
        }
        percentages = Object.keys(sortedPosns).map(parseFloat).sort(sortNumbers);
        tail = this;
        for (_j = 0, _len1 = percentages.length; _j < _len1; _j++) {
          perc = percentages[_j];
          pair = tail.splitAt(sortedPosns[perc]);
          segments.push(pair[0]);
          tail = pair[1];
        }
        segments.push(tail);
        return segments;
      }
    };

    CubicBezier.prototype.findPercentageOfPoint = function(posn, tolerance, accumulated, nextstep) {
      var a, ab, ac, b, bb, bc, split;
      if (tolerance == null) {
        tolerance = 1e-3;
      }
      if (accumulated == null) {
        accumulated = 0.0;
      }
      if (nextstep == null) {
        nextstep = 0.5;
      }
      split = this.splitAt(0.5);
      a = split[0];
      b = split[1];
      if (a.p4.within(tolerance, posn) || nextstep < 1e-4) {
        return accumulated;
      }
      ab = a.bounds();
      bb = b.bounds();
      if (ab.xr.containsInclusive(posn.x, 0.2) && ab.yr.containsInclusive(posn.y, 0.2)) {
        ac = a.findPercentageOfPoint(posn, tolerance, accumulated, nextstep / 2);
      }
      if (bb.xr.containsInclusive(posn.x, 0.2) && bb.yr.containsInclusive(posn.y, 0.2)) {
        bc = b.findPercentageOfPoint(posn, tolerance, accumulated + nextstep, nextstep / 2);
      }
      if (ac != null) {
        return ac;
      } else if (bc != null) {
        return bc;
      } else {
        return accumulated;
      }
    };

    /*
    
      Intersection methods
    */


    CubicBezier.prototype.intersectionWithLineSegment = function(l) {
      /*
      
        Given a LineSegment, lists intersection point(s).
      
        I/P: LineSegment
        O/P: Array of Posns
        
        I am a cute sick Kate Whiper Snapper
        i love monodebe and I learn all about the flexible scemless data base
      
        Disclaimer: I don't really understand this but it passes my tests.
      */

      var a, b, c, c0, c1, c2, c3, cl, d, i, max, min, n, p10, p5, p6, p7, p8, p9, results, roots, t;
      min = l.a.min(l.b);
      max = l.a.max(l.b);
      results = [];
      a = this.p1.multiplyBy(-1);
      b = this.p2.multiplyBy(3);
      c = this.p3.multiplyBy(-3);
      d = a.add(b.add(c.add(this.p4)));
      c3 = new Posn(d.x, d.y);
      a = this.p1.multiplyBy(3);
      b = this.p2.multiplyBy(-6);
      c = this.p3.multiplyBy(3);
      d = a.add(b.add(c));
      c2 = new Posn(d.x, d.y);
      a = this.p1.multiplyBy(-3);
      b = this.p2.multiplyBy(3);
      c = a.add(b);
      c1 = new Posn(c.x, c.y);
      c0 = new Posn(this.p1.x, this.p1.y);
      n = new Posn(l.a.y - l.b.y, l.b.x - l.a.x);
      cl = l.a.x * l.b.y - l.b.x * l.a.y;
      roots = new Polynomial([n.dot(c3), n.dot(c2), n.dot(c1), n.dot(c0) + cl]).roots();
      for (i in roots) {
        t = roots[i];
        if (0 <= t && t <= 1) {
          p5 = this.p1.lerp(this.p2, t);
          p6 = this.p2.lerp(this.p3, t);
          p7 = this.p3.lerp(this.p4, t);
          p8 = p5.lerp(p6, t);
          p9 = p6.lerp(p7, t);
          p10 = p8.lerp(p9, t);
          if (l.a.x === l.b.x) {
            if ((min.y <= p10.y) && (p10.y <= max.y)) {
              results.push(p10);
            }
          } else if (l.a.y === l.b.y) {
            if (min.x <= p10.x && p10.x <= max.x) {
              results.push(p10);
            }
          } else if (p10.gte(min) && p10.lte(max)) {
            results.push(p10);
          }
        }
      }
      return results;
    };

    CubicBezier.prototype.intersectionWithCubicBezier = function(other) {
      var a, b, c, c10, c10x2, c10x3, c10y2, c10y3, c11, c11x2, c11x3, c11y2, c11y3, c12, c12x2, c12x3, c12y2, c12y3, c13, c13x2, c13x3, c13y2, c13y3, c20, c20x2, c20x3, c20y2, c20y3, c21, c21x2, c21x3, c21y2, c22, c22x2, c22x3, c22y2, c23, c23x2, c23x3, c23y2, c23y3, d, i, j, k, poly, results, roots, s, tolerance, xRoot, xRoots, yRoot, yRoots;
      results = [];
      a = this.p1.multiplyBy(-1);
      b = this.p2.multiplyBy(3);
      c = this.p3.multiplyBy(-3);
      d = a.add(b.add(c.add(this.p4)));
      c13 = new Posn(d.x, d.y);
      a = this.p1.multiplyBy(3);
      b = this.p2.multiplyBy(-6);
      c = this.p3.multiplyBy(3);
      d = a.add(b.add(c));
      c12 = new Posn(d.x, d.y);
      a = this.p1.multiplyBy(-3);
      b = this.p2.multiplyBy(3);
      c = a.add(b);
      c11 = new Posn(c.x, c.y);
      c10 = new Posn(this.p1.x, this.p1.y);
      a = other.p1.multiplyBy(-1);
      b = other.p2.multiplyBy(3);
      c = other.p3.multiplyBy(-3);
      d = a.add(b.add(c.add(other.p4)));
      c23 = new Posn(d.x, d.y);
      a = other.p1.multiplyBy(3);
      b = other.p2.multiplyBy(-6);
      c = other.p3.multiplyBy(3);
      d = a.add(b.add(c));
      c22 = new Posn(d.x, d.y);
      a = other.p1.multiplyBy(-3);
      b = other.p2.multiplyBy(3);
      c = a.add(b);
      c21 = new Posn(c.x, c.y);
      c20 = new Posn(other.p1.x, other.p1.y);
      c10x2 = c10.x * c10.x;
      c10x3 = c10.x * c10.x * c10.x;
      c10y2 = c10.y * c10.y;
      c10y3 = c10.y * c10.y * c10.y;
      c11x2 = c11.x * c11.x;
      c11x3 = c11.x * c11.x * c11.x;
      c11y2 = c11.y * c11.y;
      c11y3 = c11.y * c11.y * c11.y;
      c12x2 = c12.x * c12.x;
      c12x3 = c12.x * c12.x * c12.x;
      c12y2 = c12.y * c12.y;
      c12y3 = c12.y * c12.y * c12.y;
      c13x2 = c13.x * c13.x;
      c13x3 = c13.x * c13.x * c13.x;
      c13y2 = c13.y * c13.y;
      c13y3 = c13.y * c13.y * c13.y;
      c20x2 = c20.x * c20.x;
      c20x3 = c20.x * c20.x * c20.x;
      c20y2 = c20.y * c20.y;
      c20y3 = c20.y * c20.y * c20.y;
      c21x2 = c21.x * c21.x;
      c21x3 = c21.x * c21.x * c21.x;
      c21y2 = c21.y * c21.y;
      c22x2 = c22.x * c22.x;
      c22x3 = c22.x * c22.x * c22.x;
      c22y2 = c22.y * c22.y;
      c23x2 = c23.x * c23.x;
      c23x3 = c23.x * c23.x * c23.x;
      c23y2 = c23.y * c23.y;
      c23y3 = c23.y * c23.y * c23.y;
      poly = new Polynomial([-c13x3 * c23y3 + c13y3 * c23x3 - 3 * c13.x * c13y2 * c23x2 * c23.y + 3 * c13x2 * c13.y * c23.x * c23y2, -6 * c13.x * c22.x * c13y2 * c23.x * c23.y + 6 * c13x2 * c13.y * c22.y * c23.x * c23.y + 3 * c22.x * c13y3 * c23x2 - 3 * c13x3 * c22.y * c23y2 - 3 * c13.x * c13y2 * c22.y * c23x2 + 3 * c13x2 * c22.x * c13.y * c23y2, -6 * c21.x * c13.x * c13y2 * c23.x * c23.y - 6 * c13.x * c22.x * c13y2 * c22.y * c23.x + 6 * c13x2 * c22.x * c13.y * c22.y * c23.y + 3 * c21.x * c13y3 * c23x2 + 3 * c22x2 * c13y3 * c23.x + 3 * c21.x * c13x2 * c13.y * c23y2 - 3 * c13.x * c21.y * c13y2 * c23x2 - 3 * c13.x * c22x2 * c13y2 * c23.y + c13x2 * c13.y * c23.x * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-c21.y * c23y2 - 2 * c22y2 * c23.y - c23.y * (2 * c21.y * c23.y + c22y2)), c11.x * c12.y * c13.x * c13.y * c23.x * c23.y - c11.y * c12.x * c13.x * c13.y * c23.x * c23.y + 6 * c21.x * c22.x * c13y3 * c23.x + 3 * c11.x * c12.x * c13.x * c13.y * c23y2 + 6 * c10.x * c13.x * c13y2 * c23.x * c23.y - 3 * c11.x * c12.x * c13y2 * c23.x * c23.y - 3 * c11.y * c12.y * c13.x * c13.y * c23x2 - 6 * c10.y * c13x2 * c13.y * c23.x * c23.y - 6 * c20.x * c13.x * c13y2 * c23.x * c23.y + 3 * c11.y * c12.y * c13x2 * c23.x * c23.y - 2 * c12.x * c12y2 * c13.x * c23.x * c23.y - 6 * c21.x * c13.x * c22.x * c13y2 * c23.y - 6 * c21.x * c13.x * c13y2 * c22.y * c23.x - 6 * c13.x * c21.y * c22.x * c13y2 * c23.x + 6 * c21.x * c13x2 * c13.y * c22.y * c23.y + 2 * c12x2 * c12.y * c13.y * c23.x * c23.y + c22x3 * c13y3 - 3 * c10.x * c13y3 * c23x2 + 3 * c10.y * c13x3 * c23y2 + 3 * c20.x * c13y3 * c23x2 + c12y3 * c13.x * c23x2 - c12x3 * c13.y * c23y2 - 3 * c10.x * c13x2 * c13.y * c23y2 + 3 * c10.y * c13.x * c13y2 * c23x2 - 2 * c11.x * c12.y * c13x2 * c23y2 + c11.x * c12.y * c13y2 * c23x2 - c11.y * c12.x * c13x2 * c23y2 + 2 * c11.y * c12.x * c13y2 * c23x2 + 3 * c20.x * c13x2 * c13.y * c23y2 - c12.x * c12y2 * c13.y * c23x2 - 3 * c20.y * c13.x * c13y2 * c23x2 + c12x2 * c12.y * c13.x * c23y2 - 3 * c13.x * c22x2 * c13y2 * c22.y + c13x2 * c13.y * c23.x * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c13x2 * c22.x * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c21.y * c22.y * c23.y - c20.y * c23y2 - c22.y * (2 * c21.y * c23.y + c22y2) - c23.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), 6 * c11.x * c12.x * c13.x * c13.y * c22.y * c23.y + c11.x * c12.y * c13.x * c22.x * c13.y * c23.y + c11.x * c12.y * c13.x * c13.y * c22.y * c23.x - c11.y * c12.x * c13.x * c22.x * c13.y * c23.y - c11.y * c12.x * c13.x * c13.y * c22.y * c23.x - 6 * c11.y * c12.y * c13.x * c22.x * c13.y * c23.x - 6 * c10.x * c22.x * c13y3 * c23.x + 6 * c20.x * c22.x * c13y3 * c23.x + 6 * c10.y * c13x3 * c22.y * c23.y + 2 * c12y3 * c13.x * c22.x * c23.x - 2 * c12x3 * c13.y * c22.y * c23.y + 6 * c10.x * c13.x * c22.x * c13y2 * c23.y + 6 * c10.x * c13.x * c13y2 * c22.y * c23.x + 6 * c10.y * c13.x * c22.x * c13y2 * c23.x - 3 * c11.x * c12.x * c22.x * c13y2 * c23.y - 3 * c11.x * c12.x * c13y2 * c22.y * c23.x + 2 * c11.x * c12.y * c22.x * c13y2 * c23.x + 4 * c11.y * c12.x * c22.x * c13y2 * c23.x - 6 * c10.x * c13x2 * c13.y * c22.y * c23.y - 6 * c10.y * c13x2 * c22.x * c13.y * c23.y - 6 * c10.y * c13x2 * c13.y * c22.y * c23.x - 4 * c11.x * c12.y * c13x2 * c22.y * c23.y - 6 * c20.x * c13.x * c22.x * c13y2 * c23.y - 6 * c20.x * c13.x * c13y2 * c22.y * c23.x - 2 * c11.y * c12.x * c13x2 * c22.y * c23.y + 3 * c11.y * c12.y * c13x2 * c22.x * c23.y + 3 * c11.y * c12.y * c13x2 * c22.y * c23.x - 2 * c12.x * c12y2 * c13.x * c22.x * c23.y - 2 * c12.x * c12y2 * c13.x * c22.y * c23.x - 2 * c12.x * c12y2 * c22.x * c13.y * c23.x - 6 * c20.y * c13.x * c22.x * c13y2 * c23.x - 6 * c21.x * c13.x * c21.y * c13y2 * c23.x - 6 * c21.x * c13.x * c22.x * c13y2 * c22.y + 6 * c20.x * c13x2 * c13.y * c22.y * c23.y + 2 * c12x2 * c12.y * c13.x * c22.y * c23.y + 2 * c12x2 * c12.y * c22.x * c13.y * c23.y + 2 * c12x2 * c12.y * c13.y * c22.y * c23.x + 3 * c21.x * c22x2 * c13y3 + 3 * c21x2 * c13y3 * c23.x - 3 * c13.x * c21.y * c22x2 * c13y2 - 3 * c21x2 * c13.x * c13y2 * c23.y + c13x2 * c22.x * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c13x2 * c13.y * c23.x * (6 * c20.y * c22.y + 3 * c21y2) + c21.x * c13x2 * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c20.y * c22.y * c23.y - c23.y * (2 * c20.y * c22.y + c21y2) - c21.y * (2 * c21.y * c23.y + c22y2) - c22.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), c11.x * c21.x * c12.y * c13.x * c13.y * c23.y + c11.x * c12.y * c13.x * c21.y * c13.y * c23.x + c11.x * c12.y * c13.x * c22.x * c13.y * c22.y - c11.y * c12.x * c21.x * c13.x * c13.y * c23.y - c11.y * c12.x * c13.x * c21.y * c13.y * c23.x - c11.y * c12.x * c13.x * c22.x * c13.y * c22.y - 6 * c11.y * c21.x * c12.y * c13.x * c13.y * c23.x - 6 * c10.x * c21.x * c13y3 * c23.x + 6 * c20.x * c21.x * c13y3 * c23.x + 2 * c21.x * c12y3 * c13.x * c23.x + 6 * c10.x * c21.x * c13.x * c13y2 * c23.y + 6 * c10.x * c13.x * c21.y * c13y2 * c23.x + 6 * c10.x * c13.x * c22.x * c13y2 * c22.y + 6 * c10.y * c21.x * c13.x * c13y2 * c23.x - 3 * c11.x * c12.x * c21.x * c13y2 * c23.y - 3 * c11.x * c12.x * c21.y * c13y2 * c23.x - 3 * c11.x * c12.x * c22.x * c13y2 * c22.y + 2 * c11.x * c21.x * c12.y * c13y2 * c23.x + 4 * c11.y * c12.x * c21.x * c13y2 * c23.x - 6 * c10.y * c21.x * c13x2 * c13.y * c23.y - 6 * c10.y * c13x2 * c21.y * c13.y * c23.x - 6 * c10.y * c13x2 * c22.x * c13.y * c22.y - 6 * c20.x * c21.x * c13.x * c13y2 * c23.y - 6 * c20.x * c13.x * c21.y * c13y2 * c23.x - 6 * c20.x * c13.x * c22.x * c13y2 * c22.y + 3 * c11.y * c21.x * c12.y * c13x2 * c23.y - 3 * c11.y * c12.y * c13.x * c22x2 * c13.y + 3 * c11.y * c12.y * c13x2 * c21.y * c23.x + 3 * c11.y * c12.y * c13x2 * c22.x * c22.y - 2 * c12.x * c21.x * c12y2 * c13.x * c23.y - 2 * c12.x * c21.x * c12y2 * c13.y * c23.x - 2 * c12.x * c12y2 * c13.x * c21.y * c23.x - 2 * c12.x * c12y2 * c13.x * c22.x * c22.y - 6 * c20.y * c21.x * c13.x * c13y2 * c23.x - 6 * c21.x * c13.x * c21.y * c22.x * c13y2 + 6 * c20.y * c13x2 * c21.y * c13.y * c23.x + 2 * c12x2 * c21.x * c12.y * c13.y * c23.y + 2 * c12x2 * c12.y * c21.y * c13.y * c23.x + 2 * c12x2 * c12.y * c22.x * c13.y * c22.y - 3 * c10.x * c22x2 * c13y3 + 3 * c20.x * c22x2 * c13y3 + 3 * c21x2 * c22.x * c13y3 + c12y3 * c13.x * c22x2 + 3 * c10.y * c13.x * c22x2 * c13y2 + c11.x * c12.y * c22x2 * c13y2 + 2 * c11.y * c12.x * c22x2 * c13y2 - c12.x * c12y2 * c22x2 * c13.y - 3 * c20.y * c13.x * c22x2 * c13y2 - 3 * c21x2 * c13.x * c13y2 * c22.y + c12x2 * c12.y * c13.x * (2 * c21.y * c23.y + c22y2) + c11.x * c12.x * c13.x * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c21.x * c13x2 * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c12x3 * c13.y * (-2 * c21.y * c23.y - c22y2) + c10.y * c13x3 * (6 * c21.y * c23.y + 3 * c22y2) + c11.y * c12.x * c13x2 * (-2 * c21.y * c23.y - c22y2) + c11.x * c12.y * c13x2 * (-4 * c21.y * c23.y - 2 * c22y2) + c10.x * c13x2 * c13.y * (-6 * c21.y * c23.y - 3 * c22y2) + c13x2 * c22.x * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c20.x * c13x2 * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c20.y * c21.y * c23.y - c22.y * (2 * c20.y * c22.y + c21y2) - c20.y * (2 * c21.y * c23.y + c22y2) - c21.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), -c10.x * c11.x * c12.y * c13.x * c13.y * c23.y + c10.x * c11.y * c12.x * c13.x * c13.y * c23.y + 6 * c10.x * c11.y * c12.y * c13.x * c13.y * c23.x - 6 * c10.y * c11.x * c12.x * c13.x * c13.y * c23.y - c10.y * c11.x * c12.y * c13.x * c13.y * c23.x + c10.y * c11.y * c12.x * c13.x * c13.y * c23.x + c11.x * c11.y * c12.x * c12.y * c13.x * c23.y - c11.x * c11.y * c12.x * c12.y * c13.y * c23.x + c11.x * c20.x * c12.y * c13.x * c13.y * c23.y + c11.x * c20.y * c12.y * c13.x * c13.y * c23.x + c11.x * c21.x * c12.y * c13.x * c13.y * c22.y + c11.x * c12.y * c13.x * c21.y * c22.x * c13.y - c20.x * c11.y * c12.x * c13.x * c13.y * c23.y - 6 * c20.x * c11.y * c12.y * c13.x * c13.y * c23.x - c11.y * c12.x * c20.y * c13.x * c13.y * c23.x - c11.y * c12.x * c21.x * c13.x * c13.y * c22.y - c11.y * c12.x * c13.x * c21.y * c22.x * c13.y - 6 * c11.y * c21.x * c12.y * c13.x * c22.x * c13.y - 6 * c10.x * c20.x * c13y3 * c23.x - 6 * c10.x * c21.x * c22.x * c13y3 - 2 * c10.x * c12y3 * c13.x * c23.x + 6 * c20.x * c21.x * c22.x * c13y3 + 2 * c20.x * c12y3 * c13.x * c23.x + 2 * c21.x * c12y3 * c13.x * c22.x + 2 * c10.y * c12x3 * c13.y * c23.y - 6 * c10.x * c10.y * c13.x * c13y2 * c23.x + 3 * c10.x * c11.x * c12.x * c13y2 * c23.y - 2 * c10.x * c11.x * c12.y * c13y2 * c23.x - 4 * c10.x * c11.y * c12.x * c13y2 * c23.x + 3 * c10.y * c11.x * c12.x * c13y2 * c23.x + 6 * c10.x * c10.y * c13x2 * c13.y * c23.y + 6 * c10.x * c20.x * c13.x * c13y2 * c23.y - 3 * c10.x * c11.y * c12.y * c13x2 * c23.y + 2 * c10.x * c12.x * c12y2 * c13.x * c23.y + 2 * c10.x * c12.x * c12y2 * c13.y * c23.x + 6 * c10.x * c20.y * c13.x * c13y2 * c23.x + 6 * c10.x * c21.x * c13.x * c13y2 * c22.y + 6 * c10.x * c13.x * c21.y * c22.x * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c23.y + 6 * c10.y * c20.x * c13.x * c13y2 * c23.x + 2 * c10.y * c11.y * c12.x * c13x2 * c23.y - 3 * c10.y * c11.y * c12.y * c13x2 * c23.x + 2 * c10.y * c12.x * c12y2 * c13.x * c23.x + 6 * c10.y * c21.x * c13.x * c22.x * c13y2 - 3 * c11.x * c20.x * c12.x * c13y2 * c23.y + 2 * c11.x * c20.x * c12.y * c13y2 * c23.x + c11.x * c11.y * c12y2 * c13.x * c23.x - 3 * c11.x * c12.x * c20.y * c13y2 * c23.x - 3 * c11.x * c12.x * c21.x * c13y2 * c22.y - 3 * c11.x * c12.x * c21.y * c22.x * c13y2 + 2 * c11.x * c21.x * c12.y * c22.x * c13y2 + 4 * c20.x * c11.y * c12.x * c13y2 * c23.x + 4 * c11.y * c12.x * c21.x * c22.x * c13y2 - 2 * c10.x * c12x2 * c12.y * c13.y * c23.y - 6 * c10.y * c20.x * c13x2 * c13.y * c23.y - 6 * c10.y * c20.y * c13x2 * c13.y * c23.x - 6 * c10.y * c21.x * c13x2 * c13.y * c22.y - 2 * c10.y * c12x2 * c12.y * c13.x * c23.y - 2 * c10.y * c12x2 * c12.y * c13.y * c23.x - 6 * c10.y * c13x2 * c21.y * c22.x * c13.y - c11.x * c11.y * c12x2 * c13.y * c23.y - 2 * c11.x * c11y2 * c13.x * c13.y * c23.x + 3 * c20.x * c11.y * c12.y * c13x2 * c23.y - 2 * c20.x * c12.x * c12y2 * c13.x * c23.y - 2 * c20.x * c12.x * c12y2 * c13.y * c23.x - 6 * c20.x * c20.y * c13.x * c13y2 * c23.x - 6 * c20.x * c21.x * c13.x * c13y2 * c22.y - 6 * c20.x * c13.x * c21.y * c22.x * c13y2 + 3 * c11.y * c20.y * c12.y * c13x2 * c23.x + 3 * c11.y * c21.x * c12.y * c13x2 * c22.y + 3 * c11.y * c12.y * c13x2 * c21.y * c22.x - 2 * c12.x * c20.y * c12y2 * c13.x * c23.x - 2 * c12.x * c21.x * c12y2 * c13.x * c22.y - 2 * c12.x * c21.x * c12y2 * c22.x * c13.y - 2 * c12.x * c12y2 * c13.x * c21.y * c22.x - 6 * c20.y * c21.x * c13.x * c22.x * c13y2 - c11y2 * c12.x * c12.y * c13.x * c23.x + 2 * c20.x * c12x2 * c12.y * c13.y * c23.y + 6 * c20.y * c13x2 * c21.y * c22.x * c13.y + 2 * c11x2 * c11.y * c13.x * c13.y * c23.y + c11x2 * c12.x * c12.y * c13.y * c23.y + 2 * c12x2 * c20.y * c12.y * c13.y * c23.x + 2 * c12x2 * c21.x * c12.y * c13.y * c22.y + 2 * c12x2 * c12.y * c21.y * c22.x * c13.y + c21x3 * c13y3 + 3 * c10x2 * c13y3 * c23.x - 3 * c10y2 * c13x3 * c23.y + 3 * c20x2 * c13y3 * c23.x + c11y3 * c13x2 * c23.x - c11x3 * c13y2 * c23.y - c11.x * c11y2 * c13x2 * c23.y + c11x2 * c11.y * c13y2 * c23.x - 3 * c10x2 * c13.x * c13y2 * c23.y + 3 * c10y2 * c13x2 * c13.y * c23.x - c11x2 * c12y2 * c13.x * c23.y + c11y2 * c12x2 * c13.y * c23.x - 3 * c21x2 * c13.x * c21.y * c13y2 - 3 * c20x2 * c13.x * c13y2 * c23.y + 3 * c20y2 * c13x2 * c13.y * c23.x + c11.x * c12.x * c13.x * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c12x3 * c13.y * (-2 * c20.y * c23.y - 2 * c21.y * c22.y) + c10.y * c13x3 * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c11.y * c12.x * c13x2 * (-2 * c20.y * c23.y - 2 * c21.y * c22.y) + c12x2 * c12.y * c13.x * (2 * c20.y * c23.y + 2 * c21.y * c22.y) + c11.x * c12.y * c13x2 * (-4 * c20.y * c23.y - 4 * c21.y * c22.y) + c10.x * c13x2 * c13.y * (-6 * c20.y * c23.y - 6 * c21.y * c22.y) + c20.x * c13x2 * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c21.x * c13x2 * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c13x3 * (-2 * c20.y * c21.y * c22.y - c20y2 * c23.y - c21.y * (2 * c20.y * c22.y + c21y2) - c20.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), -c10.x * c11.x * c12.y * c13.x * c13.y * c22.y + c10.x * c11.y * c12.x * c13.x * c13.y * c22.y + 6 * c10.x * c11.y * c12.y * c13.x * c22.x * c13.y - 6 * c10.y * c11.x * c12.x * c13.x * c13.y * c22.y - c10.y * c11.x * c12.y * c13.x * c22.x * c13.y + c10.y * c11.y * c12.x * c13.x * c22.x * c13.y + c11.x * c11.y * c12.x * c12.y * c13.x * c22.y - c11.x * c11.y * c12.x * c12.y * c22.x * c13.y + c11.x * c20.x * c12.y * c13.x * c13.y * c22.y + c11.x * c20.y * c12.y * c13.x * c22.x * c13.y + c11.x * c21.x * c12.y * c13.x * c21.y * c13.y - c20.x * c11.y * c12.x * c13.x * c13.y * c22.y - 6 * c20.x * c11.y * c12.y * c13.x * c22.x * c13.y - c11.y * c12.x * c20.y * c13.x * c22.x * c13.y - c11.y * c12.x * c21.x * c13.x * c21.y * c13.y - 6 * c10.x * c20.x * c22.x * c13y3 - 2 * c10.x * c12y3 * c13.x * c22.x + 2 * c20.x * c12y3 * c13.x * c22.x + 2 * c10.y * c12x3 * c13.y * c22.y - 6 * c10.x * c10.y * c13.x * c22.x * c13y2 + 3 * c10.x * c11.x * c12.x * c13y2 * c22.y - 2 * c10.x * c11.x * c12.y * c22.x * c13y2 - 4 * c10.x * c11.y * c12.x * c22.x * c13y2 + 3 * c10.y * c11.x * c12.x * c22.x * c13y2 + 6 * c10.x * c10.y * c13x2 * c13.y * c22.y + 6 * c10.x * c20.x * c13.x * c13y2 * c22.y - 3 * c10.x * c11.y * c12.y * c13x2 * c22.y + 2 * c10.x * c12.x * c12y2 * c13.x * c22.y + 2 * c10.x * c12.x * c12y2 * c22.x * c13.y + 6 * c10.x * c20.y * c13.x * c22.x * c13y2 + 6 * c10.x * c21.x * c13.x * c21.y * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c22.y + 6 * c10.y * c20.x * c13.x * c22.x * c13y2 + 2 * c10.y * c11.y * c12.x * c13x2 * c22.y - 3 * c10.y * c11.y * c12.y * c13x2 * c22.x + 2 * c10.y * c12.x * c12y2 * c13.x * c22.x - 3 * c11.x * c20.x * c12.x * c13y2 * c22.y + 2 * c11.x * c20.x * c12.y * c22.x * c13y2 + c11.x * c11.y * c12y2 * c13.x * c22.x - 3 * c11.x * c12.x * c20.y * c22.x * c13y2 - 3 * c11.x * c12.x * c21.x * c21.y * c13y2 + 4 * c20.x * c11.y * c12.x * c22.x * c13y2 - 2 * c10.x * c12x2 * c12.y * c13.y * c22.y - 6 * c10.y * c20.x * c13x2 * c13.y * c22.y - 6 * c10.y * c20.y * c13x2 * c22.x * c13.y - 6 * c10.y * c21.x * c13x2 * c21.y * c13.y - 2 * c10.y * c12x2 * c12.y * c13.x * c22.y - 2 * c10.y * c12x2 * c12.y * c22.x * c13.y - c11.x * c11.y * c12x2 * c13.y * c22.y - 2 * c11.x * c11y2 * c13.x * c22.x * c13.y + 3 * c20.x * c11.y * c12.y * c13x2 * c22.y - 2 * c20.x * c12.x * c12y2 * c13.x * c22.y - 2 * c20.x * c12.x * c12y2 * c22.x * c13.y - 6 * c20.x * c20.y * c13.x * c22.x * c13y2 - 6 * c20.x * c21.x * c13.x * c21.y * c13y2 + 3 * c11.y * c20.y * c12.y * c13x2 * c22.x + 3 * c11.y * c21.x * c12.y * c13x2 * c21.y - 2 * c12.x * c20.y * c12y2 * c13.x * c22.x - 2 * c12.x * c21.x * c12y2 * c13.x * c21.y - c11y2 * c12.x * c12.y * c13.x * c22.x + 2 * c20.x * c12x2 * c12.y * c13.y * c22.y - 3 * c11.y * c21x2 * c12.y * c13.x * c13.y + 6 * c20.y * c21.x * c13x2 * c21.y * c13.y + 2 * c11x2 * c11.y * c13.x * c13.y * c22.y + c11x2 * c12.x * c12.y * c13.y * c22.y + 2 * c12x2 * c20.y * c12.y * c22.x * c13.y + 2 * c12x2 * c21.x * c12.y * c21.y * c13.y - 3 * c10.x * c21x2 * c13y3 + 3 * c20.x * c21x2 * c13y3 + 3 * c10x2 * c22.x * c13y3 - 3 * c10y2 * c13x3 * c22.y + 3 * c20x2 * c22.x * c13y3 + c21x2 * c12y3 * c13.x + c11y3 * c13x2 * c22.x - c11x3 * c13y2 * c22.y + 3 * c10.y * c21x2 * c13.x * c13y2 - c11.x * c11y2 * c13x2 * c22.y + c11.x * c21x2 * c12.y * c13y2 + 2 * c11.y * c12.x * c21x2 * c13y2 + c11x2 * c11.y * c22.x * c13y2 - c12.x * c21x2 * c12y2 * c13.y - 3 * c20.y * c21x2 * c13.x * c13y2 - 3 * c10x2 * c13.x * c13y2 * c22.y + 3 * c10y2 * c13x2 * c22.x * c13.y - c11x2 * c12y2 * c13.x * c22.y + c11y2 * c12x2 * c22.x * c13.y - 3 * c20x2 * c13.x * c13y2 * c22.y + 3 * c20y2 * c13x2 * c22.x * c13.y + c12x2 * c12.y * c13.x * (2 * c20.y * c22.y + c21y2) + c11.x * c12.x * c13.x * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c12x3 * c13.y * (-2 * c20.y * c22.y - c21y2) + c10.y * c13x3 * (6 * c20.y * c22.y + 3 * c21y2) + c11.y * c12.x * c13x2 * (-2 * c20.y * c22.y - c21y2) + c11.x * c12.y * c13x2 * (-4 * c20.y * c22.y - 2 * c21y2) + c10.x * c13x2 * c13.y * (-6 * c20.y * c22.y - 3 * c21y2) + c20.x * c13x2 * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c13x3 * (-2 * c20.y * c21y2 - c20y2 * c22.y - c20.y * (2 * c20.y * c22.y + c21y2)), -c10.x * c11.x * c12.y * c13.x * c21.y * c13.y + c10.x * c11.y * c12.x * c13.x * c21.y * c13.y + 6 * c10.x * c11.y * c21.x * c12.y * c13.x * c13.y - 6 * c10.y * c11.x * c12.x * c13.x * c21.y * c13.y - c10.y * c11.x * c21.x * c12.y * c13.x * c13.y + c10.y * c11.y * c12.x * c21.x * c13.x * c13.y - c11.x * c11.y * c12.x * c21.x * c12.y * c13.y + c11.x * c11.y * c12.x * c12.y * c13.x * c21.y + c11.x * c20.x * c12.y * c13.x * c21.y * c13.y + 6 * c11.x * c12.x * c20.y * c13.x * c21.y * c13.y + c11.x * c20.y * c21.x * c12.y * c13.x * c13.y - c20.x * c11.y * c12.x * c13.x * c21.y * c13.y - 6 * c20.x * c11.y * c21.x * c12.y * c13.x * c13.y - c11.y * c12.x * c20.y * c21.x * c13.x * c13.y - 6 * c10.x * c20.x * c21.x * c13y3 - 2 * c10.x * c21.x * c12y3 * c13.x + 6 * c10.y * c20.y * c13x3 * c21.y + 2 * c20.x * c21.x * c12y3 * c13.x + 2 * c10.y * c12x3 * c21.y * c13.y - 2 * c12x3 * c20.y * c21.y * c13.y - 6 * c10.x * c10.y * c21.x * c13.x * c13y2 + 3 * c10.x * c11.x * c12.x * c21.y * c13y2 - 2 * c10.x * c11.x * c21.x * c12.y * c13y2 - 4 * c10.x * c11.y * c12.x * c21.x * c13y2 + 3 * c10.y * c11.x * c12.x * c21.x * c13y2 + 6 * c10.x * c10.y * c13x2 * c21.y * c13.y + 6 * c10.x * c20.x * c13.x * c21.y * c13y2 - 3 * c10.x * c11.y * c12.y * c13x2 * c21.y + 2 * c10.x * c12.x * c21.x * c12y2 * c13.y + 2 * c10.x * c12.x * c12y2 * c13.x * c21.y + 6 * c10.x * c20.y * c21.x * c13.x * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c21.y + 6 * c10.y * c20.x * c21.x * c13.x * c13y2 + 2 * c10.y * c11.y * c12.x * c13x2 * c21.y - 3 * c10.y * c11.y * c21.x * c12.y * c13x2 + 2 * c10.y * c12.x * c21.x * c12y2 * c13.x - 3 * c11.x * c20.x * c12.x * c21.y * c13y2 + 2 * c11.x * c20.x * c21.x * c12.y * c13y2 + c11.x * c11.y * c21.x * c12y2 * c13.x - 3 * c11.x * c12.x * c20.y * c21.x * c13y2 + 4 * c20.x * c11.y * c12.x * c21.x * c13y2 - 6 * c10.x * c20.y * c13x2 * c21.y * c13.y - 2 * c10.x * c12x2 * c12.y * c21.y * c13.y - 6 * c10.y * c20.x * c13x2 * c21.y * c13.y - 6 * c10.y * c20.y * c21.x * c13x2 * c13.y - 2 * c10.y * c12x2 * c21.x * c12.y * c13.y - 2 * c10.y * c12x2 * c12.y * c13.x * c21.y - c11.x * c11.y * c12x2 * c21.y * c13.y - 4 * c11.x * c20.y * c12.y * c13x2 * c21.y - 2 * c11.x * c11y2 * c21.x * c13.x * c13.y + 3 * c20.x * c11.y * c12.y * c13x2 * c21.y - 2 * c20.x * c12.x * c21.x * c12y2 * c13.y - 2 * c20.x * c12.x * c12y2 * c13.x * c21.y - 6 * c20.x * c20.y * c21.x * c13.x * c13y2 - 2 * c11.y * c12.x * c20.y * c13x2 * c21.y + 3 * c11.y * c20.y * c21.x * c12.y * c13x2 - 2 * c12.x * c20.y * c21.x * c12y2 * c13.x - c11y2 * c12.x * c21.x * c12.y * c13.x + 6 * c20.x * c20.y * c13x2 * c21.y * c13.y + 2 * c20.x * c12x2 * c12.y * c21.y * c13.y + 2 * c11x2 * c11.y * c13.x * c21.y * c13.y + c11x2 * c12.x * c12.y * c21.y * c13.y + 2 * c12x2 * c20.y * c21.x * c12.y * c13.y + 2 * c12x2 * c20.y * c12.y * c13.x * c21.y + 3 * c10x2 * c21.x * c13y3 - 3 * c10y2 * c13x3 * c21.y + 3 * c20x2 * c21.x * c13y3 + c11y3 * c21.x * c13x2 - c11x3 * c21.y * c13y2 - 3 * c20y2 * c13x3 * c21.y - c11.x * c11y2 * c13x2 * c21.y + c11x2 * c11.y * c21.x * c13y2 - 3 * c10x2 * c13.x * c21.y * c13y2 + 3 * c10y2 * c21.x * c13x2 * c13.y - c11x2 * c12y2 * c13.x * c21.y + c11y2 * c12x2 * c21.x * c13.y - 3 * c20x2 * c13.x * c21.y * c13y2 + 3 * c20y2 * c21.x * c13x2 * c13.y, c10.x * c10.y * c11.x * c12.y * c13.x * c13.y - c10.x * c10.y * c11.y * c12.x * c13.x * c13.y + c10.x * c11.x * c11.y * c12.x * c12.y * c13.y - c10.y * c11.x * c11.y * c12.x * c12.y * c13.x - c10.x * c11.x * c20.y * c12.y * c13.x * c13.y + 6 * c10.x * c20.x * c11.y * c12.y * c13.x * c13.y + c10.x * c11.y * c12.x * c20.y * c13.x * c13.y - c10.y * c11.x * c20.x * c12.y * c13.x * c13.y - 6 * c10.y * c11.x * c12.x * c20.y * c13.x * c13.y + c10.y * c20.x * c11.y * c12.x * c13.x * c13.y - c11.x * c20.x * c11.y * c12.x * c12.y * c13.y + c11.x * c11.y * c12.x * c20.y * c12.y * c13.x + c11.x * c20.x * c20.y * c12.y * c13.x * c13.y - c20.x * c11.y * c12.x * c20.y * c13.x * c13.y - 2 * c10.x * c20.x * c12y3 * c13.x + 2 * c10.y * c12x3 * c20.y * c13.y - 3 * c10.x * c10.y * c11.x * c12.x * c13y2 - 6 * c10.x * c10.y * c20.x * c13.x * c13y2 + 3 * c10.x * c10.y * c11.y * c12.y * c13x2 - 2 * c10.x * c10.y * c12.x * c12y2 * c13.x - 2 * c10.x * c11.x * c20.x * c12.y * c13y2 - c10.x * c11.x * c11.y * c12y2 * c13.x + 3 * c10.x * c11.x * c12.x * c20.y * c13y2 - 4 * c10.x * c20.x * c11.y * c12.x * c13y2 + 3 * c10.y * c11.x * c20.x * c12.x * c13y2 + 6 * c10.x * c10.y * c20.y * c13x2 * c13.y + 2 * c10.x * c10.y * c12x2 * c12.y * c13.y + 2 * c10.x * c11.x * c11y2 * c13.x * c13.y + 2 * c10.x * c20.x * c12.x * c12y2 * c13.y + 6 * c10.x * c20.x * c20.y * c13.x * c13y2 - 3 * c10.x * c11.y * c20.y * c12.y * c13x2 + 2 * c10.x * c12.x * c20.y * c12y2 * c13.x + c10.x * c11y2 * c12.x * c12.y * c13.x + c10.y * c11.x * c11.y * c12x2 * c13.y + 4 * c10.y * c11.x * c20.y * c12.y * c13x2 - 3 * c10.y * c20.x * c11.y * c12.y * c13x2 + 2 * c10.y * c20.x * c12.x * c12y2 * c13.x + 2 * c10.y * c11.y * c12.x * c20.y * c13x2 + c11.x * c20.x * c11.y * c12y2 * c13.x - 3 * c11.x * c20.x * c12.x * c20.y * c13y2 - 2 * c10.x * c12x2 * c20.y * c12.y * c13.y - 6 * c10.y * c20.x * c20.y * c13x2 * c13.y - 2 * c10.y * c20.x * c12x2 * c12.y * c13.y - 2 * c10.y * c11x2 * c11.y * c13.x * c13.y - c10.y * c11x2 * c12.x * c12.y * c13.y - 2 * c10.y * c12x2 * c20.y * c12.y * c13.x - 2 * c11.x * c20.x * c11y2 * c13.x * c13.y - c11.x * c11.y * c12x2 * c20.y * c13.y + 3 * c20.x * c11.y * c20.y * c12.y * c13x2 - 2 * c20.x * c12.x * c20.y * c12y2 * c13.x - c20.x * c11y2 * c12.x * c12.y * c13.x + 3 * c10y2 * c11.x * c12.x * c13.x * c13.y + 3 * c11.x * c12.x * c20y2 * c13.x * c13.y + 2 * c20.x * c12x2 * c20.y * c12.y * c13.y - 3 * c10x2 * c11.y * c12.y * c13.x * c13.y + 2 * c11x2 * c11.y * c20.y * c13.x * c13.y + c11x2 * c12.x * c20.y * c12.y * c13.y - 3 * c20x2 * c11.y * c12.y * c13.x * c13.y - c10x3 * c13y3 + c10y3 * c13x3 + c20x3 * c13y3 - c20y3 * c13x3 - 3 * c10.x * c20x2 * c13y3 - c10.x * c11y3 * c13x2 + 3 * c10x2 * c20.x * c13y3 + c10.y * c11x3 * c13y2 + 3 * c10.y * c20y2 * c13x3 + c20.x * c11y3 * c13x2 + c10x2 * c12y3 * c13.x - 3 * c10y2 * c20.y * c13x3 - c10y2 * c12x3 * c13.y + c20x2 * c12y3 * c13.x - c11x3 * c20.y * c13y2 - c12x3 * c20y2 * c13.y - c10.x * c11x2 * c11.y * c13y2 + c10.y * c11.x * c11y2 * c13x2 - 3 * c10.x * c10y2 * c13x2 * c13.y - c10.x * c11y2 * c12x2 * c13.y + c10.y * c11x2 * c12y2 * c13.x - c11.x * c11y2 * c20.y * c13x2 + 3 * c10x2 * c10.y * c13.x * c13y2 + c10x2 * c11.x * c12.y * c13y2 + 2 * c10x2 * c11.y * c12.x * c13y2 - 2 * c10y2 * c11.x * c12.y * c13x2 - c10y2 * c11.y * c12.x * c13x2 + c11x2 * c20.x * c11.y * c13y2 - 3 * c10.x * c20y2 * c13x2 * c13.y + 3 * c10.y * c20x2 * c13.x * c13y2 + c11.x * c20x2 * c12.y * c13y2 - 2 * c11.x * c20y2 * c12.y * c13x2 + c20.x * c11y2 * c12x2 * c13.y - c11.y * c12.x * c20y2 * c13x2 - c10x2 * c12.x * c12y2 * c13.y - 3 * c10x2 * c20.y * c13.x * c13y2 + 3 * c10y2 * c20.x * c13x2 * c13.y + c10y2 * c12x2 * c12.y * c13.x - c11x2 * c20.y * c12y2 * c13.x + 2 * c20x2 * c11.y * c12.x * c13y2 + 3 * c20.x * c20y2 * c13x2 * c13.y - c20x2 * c12.x * c12y2 * c13.y - 3 * c20x2 * c20.y * c13.x * c13y2 + c12x2 * c20y2 * c12.y * c13.x]);
      roots = poly.rootsInterval(0, 1);
      for (i in roots) {
        if (!__hasProp.call(roots, i)) continue;
        s = roots[i];
        xRoots = new Polynomial([c13.x, c12.x, c11.x, c10.x - c20.x - s * c21.x - s * s * c22.x - s * s * s * c23.x]).roots();
        yRoots = new Polynomial([c13.y, c12.y, c11.y, c10.y - c20.y - s * c21.y - s * s * c22.y - s * s * s * c23.y]).roots();
        if (xRoots.length > 0 && yRoots.length > 0) {
          tolerance = 1e-2;
          for (j in xRoots) {
            if (!__hasProp.call(xRoots, j)) continue;
            xRoot = xRoots[j];
            if (0 <= xRoot && xRoot <= 1) {
              for (k in yRoots) {
                if (!__hasProp.call(yRoots, k)) continue;
                yRoot = yRoots[k];
                if (Math.abs(xRoot - yRoot) < tolerance) {
                  results.push(c23.multiplyBy(s * s * s).add(c22.multiplyBy(s * s).add(c21.multiplyBy(s).add(c20))));
                }
              }
            }
          }
        }
      }
      return results;
    };

    return CubicBezier;

  })();

  /*
  
      Mondrian SVG library
  
      Artur Sapek 2012 - 2013
  */


  Monsvg = (function() {
    function Monsvg(data) {
      this.data = data != null ? data : {};
      this.rep = this.toSVG();
      this.$rep = $(this.rep);
      this.metadata = {
        angle: 0,
        locked: false
      };
      if (!this.data.dontTrack) {
        this.metadata.uuid = uuid();
      }
      this.rep.setAttribute('uuid', this.metadata.uuid);
      this.validateColors();
      if (this.type !== "text") {
        this.data = $.extend({
          fill: new Color("none"),
          stroke: new Color("none")
        }, this.data);
      }
      this.updateDataArchived();
      if (this.data["mondrian:angle"] != null) {
        this.metadata.angle = parseFloat(this.data["mondrian:angle"], 10);
      }
      /*
      if @data.transform?
        attrs = @data.transform.split(" ")
        for attr in attrs
          key = attr.match(/[a-z]+/gi)?[0]
          val = attr.match(/\([\-\d\,\.]*\)/gi)?[0].replace(/[\(\)]/gi, "")
        @transform[key] = val.replace(/[\(\)]/gi, "")
        #console.log "saved #{attr} as #{key} #{val}"
      */

    }

    Monsvg.prototype.commit = function() {
      /*
      newTransform = []
      
      for own key, val of @transform
        if key is "translate"
          newTransform.push "#{key}(#{val.x},#{val.y})"
        else
          newTransform.push "#{key}(#{val})"
      
      @data.transform = newTransform.join(" ")
      */

      var key, val, _ref;
      _ref = this.data;
      for (key in _ref) {
        val = _ref[key];
        if (key === "") {
          delete this.data[""];
        } else {
          if (("" + val).mentions("NaN")) {
            throw new Error("NaN! Ack. Attribute = " + key + ", Value = " + val);
          }
          this.rep.setAttribute(key, val);
        }
      }
      if (this.metadata.angle === 0) {
        this.rep.removeAttribute('mondrian:angle');
      } else {
        if (this.metadata.angle < 0) {
          this.metadata.angle += 360;
        }
        this.rep.setAttribute('mondrian:angle', this.metadata.angle);
      }
      return this;
    };

    Monsvg.prototype.updateDataArchived = function(attr) {
      if (attr != null) {
        return this.dataArchived[attr] = this.data[attr];
      } else {
        return this.dataArchived = cloneObject(this.data);
      }
    };

    Monsvg.prototype.toSVG = function() {
      var key, self, val, _ref;
      self = document.createElementNS('http://www.w3.org/2000/svg', this.type);
      _ref = this.data;
      for (key in _ref) {
        val = _ref[key];
        if (key !== "") {
          self.setAttribute(key, val);
        }
      }
      return self;
    };

    Monsvg.prototype.validateColors = function() {
      if ((this.data.fill != null) && !(this.data.fill instanceof Color)) {
        this.data.fill = new Color(this.data.fill);
      }
      if ((this.data.stroke != null) && !(this.data.stroke instanceof Color)) {
        this.data.stroke = new Color(this.data.stroke);
      }
      if (this.data["stroke-width"] == null) {
        return this.data["stroke-width"] = 1;
      }
    };

    Monsvg.prototype.points = [];

    Monsvg.prototype.center = function() {
      var xr, yr;
      xr = this.xRange();
      yr = this.yRange();
      return new Posn(xr.min + (xr.max - xr.min) / 2, yr.min + (yr.max - yr.min) / 2);
    };

    Monsvg.prototype.queryPoint = function(rep) {
      return this.points.filter(function(a) {
        return a.baseHandle === rep;
      })[0];
    };

    Monsvg.prototype.queryAntlerPoint = function(rep) {
      return this.antlerPoints.filter(function(a) {
        return a.baseHandle === rep;
      })[0];
    };

    Monsvg.prototype.show = function() {
      return this.rep.style.display = "block";
    };

    Monsvg.prototype.hide = function() {
      return this.rep.style.display = "none";
    };

    Monsvg.prototype.showPoints = function() {
      this.points.map(function(point) {
        return point.show();
      });
      return this;
    };

    Monsvg.prototype.hidePoints = function() {
      this.points.map(function(point) {
        return point.hide();
      });
      return this;
    };

    Monsvg.prototype.unhoverPoints = function() {
      this.points.map(function(point) {
        return point.unhover();
      });
      return this;
    };

    Monsvg.prototype.removePoints = function() {
      this.points.map(function(point) {
        return point.clear();
      });
      return this;
    };

    Monsvg.prototype.unremovePoints = function() {
      this.points.map(function(point) {
        return point.unclear();
      });
      return this;
    };

    Monsvg.prototype.destroyPoints = function() {
      return this.points.map(function(p) {
        return p.remove();
      });
    };

    Monsvg.prototype.removeHoverTargets = function() {
      var existent, ht, _i, _len, _results;
      existent = qa("svg#hover-targets [owner='" + this.metadata.uuid + "']");
      _results = [];
      for (_i = 0, _len = existent.length; _i < _len; _i++) {
        ht = existent[_i];
        _results.push(ht.remove());
      }
      return _results;
    };

    Monsvg.prototype.redrawHoverTargets = function() {
      var _this = this;
      this.removeHoverTargets();
      this.points.map(function(p) {
        return new HoverTarget(p.prec, p);
      });
      return this;
    };

    Monsvg.prototype.topLeftBound = function() {
      return new Posn(this.xRange().min, this.yRange().min);
    };

    Monsvg.prototype.topRightBound = function() {
      return new Posn(this.xRange().max, this.yRange().min);
    };

    Monsvg.prototype.bottomRightBound = function() {
      return new Posn(this.xRange().max, this.yRange().max);
    };

    Monsvg.prototype.bottomLeftBound = function() {
      return new Posn(this.xRange().min, this.yRange().max);
    };

    Monsvg.prototype.attr = function(data) {
      var key, val, _results;
      _results = [];
      for (key in data) {
        val = data[key];
        if (typeof val === 'function') {
          _results.push(this.data[key] = val(this.data[key]));
        } else {
          _results.push(this.data[key] = val);
        }
      }
      return _results;
    };

    Monsvg.prototype.appendTo = function(selector, track) {
      var target;
      if (track == null) {
        track = true;
      }
      if (typeof selector === "string") {
        target = q(selector);
      } else {
        target = selector;
      }
      target.appendChild(this.rep);
      if (track) {
        if (!ui.elements.has(this)) {
          ui.elements.push(this);
        }
      }
      return this;
    };

    Monsvg.prototype.clone = function() {
      var clone, cloneData, cloneTransform;
      cloneData = cloneObject(this.data);
      cloneTransform = cloneObject(this.transform);
      delete cloneData.id;
      clone = new this.constructor(cloneData);
      clone.transform = cloneTransform;
      return clone;
    };

    Monsvg.prototype["delete"] = function() {
      var _this = this;
      this.rep.remove();
      ui.elements = ui.elements.remove(this);
      return async(function() {
        _this.destroyPoints();
        _this.removeHoverTargets();
        if (_this.group) {
          return _this.group["delete"]();
        }
      });
    };

    Monsvg.prototype.zIndex = function() {
      var zi,
        _this = this;
      zi = 0;
      dom.$main.children().each(function(ind, elem) {
        if (elem.getAttribute("uuid") === _this.metadata.uuid) {
          zi = ind;
          return false;
        }
      });
      return zi;
    };

    Monsvg.prototype.moveForward = function(n) {
      var next, x, _i;
      if (n == null) {
        n = 1;
      }
      for (x = _i = 1; 1 <= n ? _i <= n : _i >= n; x = 1 <= n ? ++_i : --_i) {
        next = this.$rep.next();
        if (next.length === 0) {
          break;
        }
        next.after(this.$rep);
      }
      return this;
    };

    Monsvg.prototype.moveBack = function(n) {
      var prev, x, _i;
      if (n == null) {
        n = 1;
      }
      for (x = _i = 1; 1 <= n ? _i <= n : _i >= n; x = 1 <= n ? ++_i : --_i) {
        prev = this.$rep.prev();
        if (prev.length === 0) {
          break;
        }
        prev.before(this.$rep);
      }
      return this;
    };

    Monsvg.prototype.bringToFront = function() {
      return dom.$main.append(this.$rep);
    };

    Monsvg.prototype.sendToBack = function() {
      return dom.$main.prepend(this.$rep);
    };

    Monsvg.prototype.transform = {};

    Monsvg.prototype.swapFillAndStroke = function() {
      var swap;
      swap = this.data.stroke;
      this.attr({
        'stroke': this.data.fill,
        'fill': swap
      });
      return this.commit();
    };

    Monsvg.prototype.eyedropper = function(sample) {
      this.data.fill = sample.data.fill;
      this.data.stroke = sample.data.stroke;
      this.data['stroke-width'] = sample.data['stroke-width'];
      return this.commit();
    };

    Monsvg.prototype.bounds = function() {
      var cached, xr, yr;
      cached = this.boundsCached;
      if (cached !== null && this.caching) {
        return cached;
      } else {
        xr = this.xRange();
        yr = this.yRange();
        return this.boundsCached = new Bounds(xr.min, yr.min, xr.length(), yr.length());
      }
    };

    Monsvg.prototype.boundsCached = null;

    Monsvg.prototype.hideUI = function() {
      return ui.removePointHandles();
    };

    Monsvg.prototype.refreshUI = function() {
      this.points.map(function(p) {
        return p.updateHandle();
      });
      return this.redrawHoverTargets();
    };

    Monsvg.prototype.overlaps = function(other) {
      return this['overlaps' + other.type.capitalize()](other);
    };

    Monsvg.prototype.lineSegmentsIntersect = function(other) {
      var a, b, continueChecking, mbounds, mline, ms, obounds, oline, os, _i, _j, _len, _len1;
      ms = this.lineSegments();
      os = other.lineSegments();
      for (_i = 0, _len = ms.length; _i < _len; _i++) {
        mline = ms[_i];
        if (mline instanceof CubicBezier) {
          mbounds = mline.bounds(true);
        }
        a = mline instanceof LineSegment ? mline.a : mline.p1;
        b = mline instanceof LineSegment ? mline.b : mline.p2;
        if ((other.contains(a)) || (other.contains(b))) {
          return true;
        }
        for (_j = 0, _len1 = os.length; _j < _len1; _j++) {
          oline = os[_j];
          if (mline instanceof CubicBezier || oline instanceof CubicBezier) {
            obounds = oline.bounds(true);
            continueChecking = mbounds.overlapsBounds(obounds);
          } else {
            continueChecking = true;
          }
          if (continueChecking) {
            if (mline.intersects(oline)) {
              return true;
            }
          }
        }
      }
      return false;
    };

    Monsvg.prototype.lineSegmentIntersections = function(other) {
      var inter, intersections, mbounds, mline, ms, obounds, oline, os, _i, _j, _len, _len1;
      intersections = [];
      ms = this.lineSegments();
      os = other.lineSegments();
      for (_i = 0, _len = ms.length; _i < _len; _i++) {
        mline = ms[_i];
        mbounds = mline.bounds(true);
        for (_j = 0, _len1 = os.length; _j < _len1; _j++) {
          oline = os[_j];
          obounds = oline.bounds(true);
          inter = mline.intersection(oline);
          if (inter instanceof Posn) {
            intersections.push({
              intersection: [inter],
              aline: mline,
              bline: oline,
              a: mline.source,
              b: oline.source
            });
          } else if (inter instanceof Array && inter.length > 0) {
            intersections.push({
              intersection: inter,
              aline: mline,
              bline: oline,
              a: mline.source,
              b: oline.source
            });
          }
        }
      }
      return intersections;
    };

    Monsvg.prototype.remove = function() {
      this.rep.remove();
      if (this.points !== []) {
        return this.points.map(function(p) {
          var _ref;
          return (_ref = p.baseHandle) != null ? _ref.remove() : void 0;
        });
      }
    };

    Monsvg.prototype.convertTo = function(type) {
      var result;
      result = this["convertTo" + type]();
      result.eyedropper(this);
      return result;
    };

    Monsvg.prototype.toString = function() {
      return "(" + this.type + " Monsvg object)";
    };

    Monsvg.prototype.repToString = function() {
      return new XMLSerializer().serializeToString(this.rep);
    };

    Monsvg.prototype.carryOutTransformations = function(transform, center) {
      var attr, attrs, factor, key, val, x, y, _i, _len, _ref, _ref1, _results;
      if (transform == null) {
        transform = this.data.transform;
      }
      if (center == null) {
        center = new Posn(0, 0);
      }
      /*
        We do things this way because fuck the transform attribute.
      
        Basically, when we commit shapes for the first time from some other file,
        if they have a transform attribute we effectively just alter the data
        that makes those shapes up so that they still look the same, but they no longer
        have a transform attr.
      */

      attrs = transform.replace(", ", ",").split(" ").reverse();
      _results = [];
      for (_i = 0, _len = attrs.length; _i < _len; _i++) {
        attr = attrs[_i];
        key = (_ref = attr.match(/[a-z]+/gi)) != null ? _ref[0] : void 0;
        val = (_ref1 = attr.match(/\([\-\d\,\.]*\)/gi)) != null ? _ref1[0].replace(/[\(\)]/gi, "") : void 0;
        switch (key) {
          case "scale":
            factor = parseFloat(val);
            this.scale(factor, factor, center);
            _results.push(this.data["stroke-width"] *= factor);
            break;
          case "translate":
            val = val.split(",");
            x = parseFloat(val[0]);
            y = val[1] != null ? parseFloat(val[1]) : 0;
            _results.push(this.nudge(x, -y));
            break;
          case "rotate":
            this.rotate(parseFloat(val), center);
            _results.push(this.metadata.angle = 0);
            break;
          default:
            _results.push(void 0);
        }
      }
      return _results;
    };

    Monsvg.prototype.applyTransform = function(transform) {
      var attr, key, val, x, y, _i, _len, _ref, _ref1, _ref2;
      console.log("apply transform");
      _ref = transform.split(" ");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        attr = _ref[_i];
        key = (_ref1 = attr.match(/[a-z]+/gi)) != null ? _ref1[0] : void 0;
        val = (_ref2 = attr.match(/\([\-\d\,\.]*\)/gi)) != null ? _ref2[0].replace(/[\(\)]/gi, "") : void 0;
        switch (key) {
          case "scale":
            val = parseFloat(val);
            if (this.transform.scale != null) {
              this.transform.scale *= val;
            } else {
              this.transform.scale = val;
            }
            break;
          case "translate":
            val = val.split(",");
            x = parseFloat(val[0]);
            y = parseFloat(val[1]);
            x = parseFloat(x);
            y = parseFloat(y);
            if (this.transform.translate != null) {
              this.transform.translate.x += x;
              this.transform.translate.y += y;
            } else {
              this.transform.translate = {
                x: x,
                y: y
              };
            }
            break;
          case "rotate":
            val = parseFloat(val);
            if (this.transform.rotate != null) {
              this.transform.rotate += val;
              this.transform.rotate %= 360;
            } else {
              this.transform.rotate = val;
            }
        }
      }
      return this.commit();
    };

    Monsvg.prototype.setFill = function(val) {
      return this.data.fill = new Color(val);
    };

    Monsvg.prototype.setStroke = function(val) {
      return this.data.stroke = new Color(val);
    };

    Monsvg.prototype.setStrokeWidth = function(val) {
      return this.data['stroke-width'] = val;
    };

    Monsvg.prototype.setupToCanvas = function(context) {
      var _ref;
      context.beginPath();
      context.fillStyle = "" + this.data.fill;
      if (((this.data['stroke-width'] != null) > 0) && (((_ref = this.data.stroke) != null ? _ref.hex : void 0) !== "none")) {
        context.strokeStyle = "" + this.data.stroke;
        context.lineWidth = parseFloat(this.data['stroke-width']);
      } else {
        context.strokeStyle = "none";
        context.lineWidth = "0";
      }
      return context;
    };

    Monsvg.prototype.finishToCanvas = function(context) {
      var _ref, _ref1;
      if ((_ref = this.points) != null ? _ref.closed : void 0) {
        context.closePath();
      }
      context.fill();
      if ((this.data['stroke-width'] > 0) && (((_ref1 = this.data.stroke) != null ? _ref1.hex : void 0) !== "none")) {
        context.stroke();
      }
      return context;
    };

    Monsvg.prototype.clearCachedObjects = function() {};

    Monsvg.prototype.lineSegments = function() {};

    return Monsvg;

  })();

  /*
  
    HoverTarget
  */


  HoverTarget = (function(_super) {
    __extends(HoverTarget, _super);

    HoverTarget.prototype.type = 'path';

    function HoverTarget(a, b, width) {
      this.a = a;
      this.b = b;
      this.width = width;
      if (this.width == null) {
        this.width = 1;
      }
      this.owner = this.b.owner;
      b = this.b instanceof SmoothTo ? this.b.toCurveTo() : this.b;
      this.d = "M" + (this.a.x * ui.canvas.zoom) + "," + (this.a.y * ui.canvas.zoom) + " " + (b.toStringWithZoom());
      this.data = {
        fill: "none",
        stroke: "rgba(75, 175, 255, 0.0)",
        "stroke-width": 4 / ui.canvas.zoom,
        d: this.d
      };
      this.b.hoverTarget = this;
      HoverTarget.__super__.constructor.call(this, this.data);
      this.appendTo('#hover-targets', false);
      this.rep.setAttribute('a', this.a.at);
      this.rep.setAttribute('b', this.b.at);
      this.rep.setAttribute('owner', this.owner.metadata.uuid);
    }

    HoverTarget.prototype.highlight = function() {
      ui.unhighlightHoverTargets();
      this.a.hover();
      this.b.hover();
      this.attr({
        "stroke-width": 5,
        stroke: "#4981e0"
      });
      ui.hoverTargetsHighlighted.push(this);
      return this.commit();
    };

    HoverTarget.prototype.unhighlight = function() {
      this.attr({
        "stroke-width": 5,
        stroke: "rgba(75, 175, 255, 0.0)"
      });
      return this.commit();
    };

    HoverTarget.prototype.active = function() {
      this.a.baseHandle.setAttribute('active', '');
      return this.b.baseHandle.setAttribute('active', '');
    };

    HoverTarget.prototype.nudge = function(x, y) {
      this.a.nudge(x, y);
      this.b.nudge(x, y);
      this.owner.commit();
      this.unhighlight();
      return this.constructor(this.a, this.b, this.width);
    };

    return HoverTarget;

  })(Monsvg);

  /*
  
    Line
  */


  Line = (function(_super) {
    __extends(Line, _super);

    function Line() {
      _ref = Line.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Line.prototype.type = 'line';

    Line.prototype.a = function() {
      return new Posn(this.data.x1, this.data.y1);
    };

    Line.prototype.b = function() {
      return new Posn(this.data.x2, this.data.y2);
    };

    Line.prototype.absorbA = function(a) {
      this.data.x1 = a.x;
      return this.data.y1 = a.y;
    };

    Line.prototype.absorbB = function(b) {
      this.data.x2 = b.x;
      return this.data.y2 = b.y;
    };

    Line.prototype.asLineSegment = function() {
      return new LineSegment(this.a(), this.b());
    };

    Line.prototype.fromLineSegment = function(ls) {
      this.absorbA(ls.a);
      return this.absorbB(ls.b);
    };

    Line.prototype.xRange = function() {
      return this.asLineSegment().xRange();
    };

    Line.prototype.yRange = function() {
      return this.asLineSegment().yRange();
    };

    Line.prototype.nudge = function(x, y) {
      this.data.x1 += x;
      this.data.x2 += x;
      this.data.y1 -= y;
      this.data.y2 -= y;
      return this.commit();
    };

    Line.prototype.scale = function(x, y, origin) {
      this.absorbA(this.a().scale(x, y, origin));
      this.absorbB(this.b().scale(x, y, origin));
      return this.commit();
    };

    Line.prototype.overlapsRect = function(rect) {
      var l, ls, _i, _len, _ref1;
      ls = this.asLineSegment();
      if (this.a().insideOf(rect)) {
        return true;
      }
      if (this.b().insideOf(rect)) {
        return true;
      }
      _ref1 = rect.lineSegments();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        l = _ref1[_i];
        if (l.intersects(ls)) {
          return true;
        }
      }
      return false;
    };

    return Line;

  })(Monsvg);

  Rect = (function(_super) {
    __extends(Rect, _super);

    Rect.prototype.type = 'rect';

    function Rect(data) {
      this.data = data;
      Rect.__super__.constructor.call(this, this.data);
      if (this.data.x == null) {
        this.data.x = 0;
      }
      if (this.data.y == null) {
        this.data.y = 0;
      }
      this.data.x = parseFloat(this.data.x);
      this.data.y = parseFloat(this.data.y);
      this.data.width = parseFloat(this.data.width);
      this.data.height = parseFloat(this.data.height);
    }

    Rect.prototype.commit = function() {
      this._validateDimensions();
      return Rect.__super__.commit.apply(this, arguments);
    };

    Rect.prototype.points = function() {
      return [new Point(this.data.x, this.data.y), new Point(this.data.x + this.data.width, this.data.y), new Point(this.data.x + this.data.width, this.data.y + this.data.height), new Point(this.data.x, this.data.y + this.data.height)];
    };

    /*
    
      Geometric data
    
        points()
        lineSegments()
        center()
        xRange()
        yRange()
    */


    Rect.prototype.lineSegments = function() {
      var p;
      p = this.points();
      return [new LineSegment(p[0], p[1], p[1]), new LineSegment(p[1], p[2], p[2]), new LineSegment(p[2], p[3], p[3]), new LineSegment(p[3], p[0], p[0])];
    };

    Rect.prototype.center = function() {
      return new Posn(this.data.x + (this.data.width / 2), this.data.y + (this.data.height / 2));
    };

    Rect.prototype.xRange = function() {
      return new Range(this.data.x, this.data.x + this.data.width);
    };

    Rect.prototype.yRange = function() {
      return new Range(this.data.y, this.data.y + this.data.height);
    };

    Rect.prototype.clearCachedObjects = function() {};

    /*
    
      Relationship analysis
    
        contains()
        overlaps()
        intersections()
        containments()
        containmentsBothWays()
    */


    Rect.prototype.contains = function(posn) {
      return this.xRange().contains(posn.x) && this.yRange().contains(posn.y);
    };

    Rect.prototype.overlaps = function(other) {
      /*
        Fuck you whore
        Redirects to appropriate method.
      
        I/P: Polygon/Circle/Rect
        O/P: true or false
      */

      return this['overlaps' + other.type.capitalize()](other);
    };

    Rect.prototype.overlapsPolygon = function(polygon) {
      if (this.contains(polygon.center() || polygon.contains(this.center()))) {
        return true;
      }
      return this.lineSegmentsIntersect(polygon);
    };

    Rect.prototype.overlapsCircle = function(circle) {};

    Rect.prototype.overlapsRect = function(rectangle) {
      return this.overlapsPolygon(rectangle);
    };

    Rect.prototype.intersections = function(obj) {
      var inter, intersections, s1, s2, _i, _j, _len, _len1, _ref1, _ref2;
      intersections = [];
      _ref1 = this.lineSegments();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        s1 = _ref1[_i];
        _ref2 = obj.lineSegments();
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          s2 = _ref2[_j];
          inter = s1.intersection(s2);
          if (inter instanceof Posn) {
            intersections.push(inter);
          }
        }
      }
      return intersections;
    };

    Rect.prototype.containments = function(obj) {
      var containments, point, points, xr, yr, _i, _len;
      containments = [];
      points = obj.points;
      xr = this.xRange();
      yr = this.yRange();
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        point = points[_i];
        if (xr.contains(point.x) && yr.contains(point.y)) {
          containments.push(point);
        }
      }
      return containments;
    };

    Rect.prototype.containmentsBothWays = function(obj) {
      return this.containments(obj).concat(obj.containments(this));
    };

    Rect.prototype.scale = function(factorX, factorY, origin) {
      var _this = this;
      if (origin == null) {
        origin = this.center();
      }
      this.attr({
        x: function(x) {
          return (x - origin.x) * factorX + origin.x;
        },
        y: function(y) {
          return (y - origin.y) * factorY + origin.y;
        },
        width: function(w) {
          return w * factorX;
        },
        height: function(h) {
          return h * factorY;
        }
      });
      return this.commit();
    };

    Rect.prototype.nudge = function(x, y) {
      this.data.x += x;
      this.data.y -= y;
      return this.commit();
    };

    Rect.prototype.convertToPath = function() {
      var path, pts;
      pts = this.points();
      path = new Path({
        d: "M" + pts[0] + " L" + pts[1] + " L" + pts[2] + " L" + pts[3] + " L" + pts[0]
      });
      path.eyedropper(this);
      path.updateDataArchived();
      return path;
    };

    Rect.prototype.drawToCanvas = function(context) {
      context = this.setupToCanvas(context);
      context.rect(this.data.x, this.data.y, this.data.width, this.data.height);
      return context = this.finishToCanvas(context);
    };

    Rect.prototype._validateDimensions = function() {
      if (this.data.height < 0) {
        this.data.height *= -1;
      }
      if (this.data.width < 0) {
        return this.data.width *= -1;
      }
    };

    return Rect;

  })(Monsvg);

  Circle = (function(_super) {
    __extends(Circle, _super);

    function Circle() {
      _ref1 = Circle.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Circle.prototype.type = 'circle';

    Circle.prototype.scale = function(factor, origin) {
      this.attr({
        'r': function(r) {
          return r * factor;
        }
      });
      return this.commit();
    };

    Circle.prototype.scaleXY = function(x, y, origin) {};

    Circle.prototype.points = [];

    Circle.prototype.center = function() {
      return new Posn(this.data.cx, this.data.cy);
    };

    Circle.prototype.xRange = function() {
      return new Range(this.data.cx - this.data.r, this.data.cx + this.data.r);
    };

    Circle.prototype.yRange = function() {
      return new Range(this.data.cy - this.data.r, this.data.cy + this.data.r);
    };

    Circle.prototype.overlaps = function(other) {
      /*
        Checks for overlap with another shape.
        Redirects to appropriate method.
      
        I/P: Polygon/Circle/Rect
        O/P: true or false
      */

      return this['overlaps' + other.type.capitalize()](other);
    };

    Circle.prototype.overlapsPolygon = function(polygon) {
      var line, _i, _len, _ref2;
      if (polygon.contains(this.center())) {
        return true;
      }
      _ref2 = polygon.lineSegments();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        line = _ref2[_i];
        if (line.intersects(this)) {
          return true;
        }
      }
      return false;
    };

    Circle.prototype.overlapsCircle = function(circle) {};

    Circle.prototype.overlapsRect = function(rectangle) {
      return this.overlapsPolygon(rectangle);
    };

    Circle.prototype.nudge = function(x, y) {
      this.attr({
        cx: function(cx) {
          return cx += x;
        },
        cy: function(cy) {
          return cy -= y;
        }
      });
      return this.commit();
    };

    return Circle;

  })(Monsvg);

  /*
  
    Ellipse
  */


  Ellipse = (function(_super) {
    __extends(Ellipse, _super);

    Ellipse.prototype.type = 'ellipse';

    function Ellipse(data) {
      this.data = data;
      Ellipse.__super__.constructor.call(this, this.data);
      this.data.cx = parseFloat(this.data.cx);
      this.data.cy = parseFloat(this.data.cy);
      this.data.rx = parseFloat(this.data.rx);
      this.data.ry = parseFloat(this.data.ry);
    }

    Ellipse.prototype.xRange = function() {
      return new Range(this.data.cx - this.data.rx, this.data.cx + this.data.rx);
    };

    Ellipse.prototype.yRange = function() {
      return new Range(this.data.cy - this.data.ry, this.data.cy + this.data.ry);
    };

    Ellipse.prototype.c = function() {
      return new Posn(this.data.cx, this.data.cy);
    };

    Ellipse.prototype.top = function() {
      return new Posn(this.data.cx, this.data.cy - this.data.ry);
    };

    Ellipse.prototype.right = function() {
      return new Posn(this.data.cx + this.data.rx, this.data.cy);
    };

    Ellipse.prototype.bottom = function() {
      return new Posn(this.data.cx, this.data.cy + this.data.ry);
    };

    Ellipse.prototype.left = function() {
      return new Posn(this.data.cx - this.data.rx, this.data.cy);
    };

    Ellipse.prototype.overlapsRect = function(r) {
      var l, _i, _len, _ref2;
      _ref2 = r.lineSegments();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        l = _ref2[_i];
        if ((l.intersectionWithEllipse(this)) instanceof Array) {
          return true;
        }
      }
    };

    Ellipse.prototype.nudge = function(x, y) {
      this.data.cx += x;
      this.data.cy -= y;
      return this.commit();
    };

    Ellipse.prototype.scale = function(x, y, origin) {
      var c;
      c = this.c().scale(x, y, origin);
      this.data.cx = c.x;
      this.data.cy = c.y;
      this.data.rx *= x;
      this.data.ry *= y;
      return this.commit();
    };

    Ellipse.prototype.convertToPath = function() {
      var bottom, kx, ky, left, p, right, rx, ry, top;
      p = new Path({
        d: "M" + this.data.cx + "," + (this.data.cy - this.data.ry)
      });
      p.eyedropper(this);
      top = this.top();
      right = this.right();
      bottom = this.bottom();
      left = this.left();
      rx = this.data.rx;
      ry = this.data.ry;
      ky = Math.KAPPA * ry;
      kx = Math.KAPPA * rx;
      p.points.push(new CurveTo(top.x + kx, top.y, right.x, right.y - ky, right.x, right.y));
      p.points.push(new CurveTo(right.x, right.y + ky, bottom.x + kx, bottom.y, bottom.x, bottom.y));
      p.points.push(new CurveTo(bottom.x - kx, bottom.y, left.x, left.y + ky, left.x, left.y));
      p.points.push(new CurveTo(left.x, left.y - ky, top.x - kx, top.y, top.x, top.y));
      p.points.close();
      p.points.drawBasePoints();
      p.updateDataArchived();
      return p;
    };

    return Ellipse;

  })(Monsvg);

  Polygon = (function(_super) {
    __extends(Polygon, _super);

    Polygon.prototype.type = 'polygon';

    function Polygon(data) {
      this.data = data;
      this.points = new PointsList(this.parsePoints(this.data.points));
      Polygon.__super__.constructor.call(this, this.data);
    }

    Polygon.prototype.appendTo = function(selector, track) {
      if (track == null) {
        track = true;
      }
      Polygon.__super__.appendTo.call(this, selector, track);
      this.points.drawBasePoints().hide();
      if (track) {
        this.redrawHoverTargets();
      }
      return this;
    };

    Polygon.prototype.commit = function() {
      this.data.points = this.points.toString();
      return Polygon.__super__.commit.apply(this, arguments);
    };

    Polygon.prototype.lineSegments = function() {
      var points, segments;
      points = this.points.points;
      segments = [];
      points.map(function(curr, ind) {
        var next;
        next = points[ind === (points.length - 1) ? 0 : ind + 1];
        return segments.push(new LineSegment(curr, next));
      });
      return segments;
    };

    Polygon.prototype.xs = function() {
      return this.points.all().map(function(posn) {
        return posn.x;
      });
    };

    Polygon.prototype.ys = function() {
      return this.points.all().map(function(posn) {
        return posn.y;
      });
    };

    Polygon.prototype.xRange = function() {
      return new Range().fromList(this.xs());
    };

    Polygon.prototype.yRange = function() {
      return new Range().fromList(this.ys());
    };

    Polygon.prototype.topLeftBound = function() {
      return new Posn(this.xRange().min, this.yRange().min);
    };

    Polygon.prototype.topRightBound = function() {
      return new Posn(this.xRange().max, this.yRange().min);
    };

    Polygon.prototype.bottomRightBound = function() {
      return new Posn(this.xRange().max, this.yRange().max);
    };

    Polygon.prototype.bottomLeftBound = function() {
      return new Posn(this.xRange().min, this.yRange().max);
    };

    Polygon.prototype.bounds = function() {
      var xr, yr;
      xr = this.xRange();
      yr = this.yRange();
      return new Bounds(xr.min, yr.min, xr.length(), yr.length());
    };

    Polygon.prototype.center = function() {
      return this.bounds().center();
    };

    Polygon.prototype.parsePoints = function() {
      var points,
        _this = this;
      if (this.data.points === '') {
        return [];
      }
      points = [];
      this.data.points = this.data.points.match(/[\d\,\. ]/gi).join('');
      this.data.points.split(' ').map(function(coords) {
        var p, x, y;
        coords = coords.split(',');
        if (coords.length === 2) {
          x = parseFloat(coords[0]);
          y = parseFloat(coords[1]);
          p = new Point(x, y, _this);
          return points.push(p);
        }
      });
      return points;
    };

    Polygon.prototype.clearCachedObjects = function() {};

    /*
      Transformations
        rotate
        nudge
    */


    Polygon.prototype.rotate = function(angle, center) {
      var _this = this;
      if (center == null) {
        center = this.center();
      }
      this.points.map(function(p) {
        return p.rotate(angle, center);
      });
      this.metadata.angle += angle;
      return this.metadata.angle %= 360;
    };

    Polygon.prototype.scale = function(x, y, origin) {
      if (origin == null) {
        origin = this.center();
      }
      this.points.map(function(p) {
        return p.scale(x, y, origin);
      });
      return this.commit();
    };

    Polygon.prototype.nudge = function(x, y) {
      this.points.map(function(p) {
        return p.nudge(x, y);
      });
      return this.commit();
    };

    Polygon.prototype.contains = function(posn) {
      return posn.insideOf(this.lineSegments());
    };

    Polygon.prototype.overlaps = function(other) {
      return this['overlaps' + other.type.capitalize()](other);
    };

    Polygon.prototype.overlapsPolygon = function(polygon) {
      var line, polyLine, _i, _j, _len, _len1, _ref2, _ref3;
      if (this.contains(polygon.center() || polygon.contains(this.center()))) {
        return true;
      }
      _ref2 = this.lineSegments();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        line = _ref2[_i];
        if (polygon.contains(line.a || polygon.contains(line.b))) {
          return true;
        }
        _ref3 = polygon.lineSegments();
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          polyLine = _ref3[_j];
          if (polyLine.intersects(line)) {
            return true;
          }
        }
      }
      return false;
    };

    Polygon.prototype.overlapsCircle = function(circle) {};

    Polygon.prototype.overlapsRect = function(rectangle) {
      return this.overlapsPolygon(rectangle);
    };

    Polygon.prototype.convertToPath = function() {
      var lt, old, p, path, _i, _len, _ref2;
      path = new Path({
        d: "M" + (this.points.at(0).x) + "," + (this.points.at(0).y)
      });
      path.eyedropper(this);
      old = path.points.at(0);
      _ref2 = this.points.all().slice(1);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        p = _ref2[_i];
        lt = new LineTo(p.x, p.y, path, old, false);
        path.points.push(lt);
        old = lt;
      }
      path.points.close();
      return path;
    };

    return Polygon;

  })(Monsvg);

  Polyline = (function(_super) {
    __extends(Polyline, _super);

    function Polyline() {
      _ref2 = Polyline.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    Polyline.prototype.convertToPath = function() {
      var lt, old, p, path, _i, _len, _ref3;
      path = new Path({
        d: "M" + (this.points.at(0).x) + "," + (this.points.at(0).y)
      });
      path.eyedropper(this);
      old = path.points.at(0);
      _ref3 = this.points.all().slice(1);
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        p = _ref3[_i];
        lt = new LineTo(p.x, p.y, path, old, false);
        path.points.push(lt);
        old = lt;
      }
      return path;
    };

    return Polyline;

  })(Polygon);

  /*
  
    Path
  
    Highest order of vector data. Lowest level of expression.
  */


  Path = (function(_super) {
    __extends(Path, _super);

    Path.prototype.type = 'path';

    function Path(data) {
      var _ref3, _ref4, _ref5;
      this.data = data;
      Path.__super__.constructor.call(this, this.data);
      if (((_ref3 = this.data) != null ? _ref3.d : void 0) != null) {
        this.importNewPoints(this.data.d);
      }
      this.antlerPoints = new PointsList([], this);
      if (((_ref4 = this.data) != null ? (_ref5 = _ref4.d) != null ? _ref5.match(/z$/gi) : void 0 : void 0) !== null) {
        this.points.closed = true;
      }
    }

    Path.prototype.caching = true;

    Path.prototype.commit = function() {
      this.data.d = this.points.toString();
      return Path.__super__.commit.apply(this, arguments);
    };

    Path.prototype.hover = function() {
      if (!ui.selection.elements.all.has(this)) {
        this.showPoints();
      }
      return ui.unhighlightHoverTargets();
    };

    Path.prototype.unhover = function() {
      return this.hidePoints();
    };

    Path.prototype.virgin = void 0;

    Path.prototype.virginMode = function() {
      this.virgin.eyedropper(this);
      return this.$rep.replaceWith(this.virgin.$rep);
    };

    Path.prototype.editMode = function() {
      return this.virgin.$rep.replaceWith(this.$rep);
    };

    Path.prototype.woohoo = function() {
      return this.virgin = void 0;
    };

    Path.prototype.importNewPoints = function(points) {
      if (points instanceof PointsList) {
        this.points = points;
      } else {
        this.points = new PointsList(points, this);
      }
      this.points = this.points.absolute();
      this.clearCachedObjects();
      return this;
    };

    Path.prototype.cleanUpPoints = function() {
      var p, _i, _len, _ref3;
      _ref3 = this.points.all();
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        p = _ref3[_i];
        p.cleanUp();
      }
      return this.commit();
    };

    Path.prototype.appendTo = function(selector, track) {
      if (track == null) {
        track = true;
      }
      Path.__super__.appendTo.call(this, selector, track);
      this.points.drawBasePoints().hide();
      if (track) {
        this.redrawHoverTargets();
      }
      return this;
    };

    Path.prototype.xRange = function() {
      var cached;
      cached = this.xRangeCached;
      if (cached !== null) {
        return cached;
      } else {
        return this.xRangeCached = new Range().fromRangeList(this.lineSegments().map(function(x) {
          return x.xRange();
        }));
      }
    };

    Path.prototype.xRangeCached = null;

    Path.prototype.yRange = function() {
      var cached;
      cached = this.yRangeCached;
      if (cached !== null) {
        return cached;
      } else {
        return this.yRangeCached = new Range().fromRangeList(this.lineSegments().map(function(x) {
          return x.yRange();
        }));
      }
    };

    Path.prototype.yRangeCached = null;

    Path.prototype.nudgeCachedObjects = function(x, y) {
      var _ref3, _ref4, _ref5, _ref6;
      if ((_ref3 = this.boundsCached) != null) {
        _ref3.nudge(x, y);
      }
      if ((_ref4 = this.xRangeCached) != null) {
        _ref4.nudge(x);
      }
      if ((_ref5 = this.yRangeCached) != null) {
        _ref5.nudge(y);
      }
      return (_ref6 = this.lineSegmentsCached) != null ? _ref6.map(function(ls) {
        return ls.nudge(x, y);
      }) : void 0;
    };

    Path.prototype.scaleCachedObjects = function(x, y, origin) {
      var _ref3, _ref4, _ref5;
      if ((_ref3 = this.boundsCached) != null) {
        _ref3.scale(x, y, origin);
      }
      if ((_ref4 = this.xRangeCached) != null) {
        _ref4.scale(x, origin.x);
      }
      if ((_ref5 = this.yRangeCached) != null) {
        _ref5.scale(y, origin.y);
      }
      return this.lineSegmentsCached = null;
      /*
      @lineSegmentsCached.map (ls) ->
        ls.scale(x, y, origin)
      */

    };

    Path.prototype.clearCachedObjects = function() {
      this.lineSegmentsCached = null;
      this.boundsCached = null;
      this.xRangeCached = null;
      this.yRangeCached = null;
      return this;
    };

    Path.prototype.lineSegments = function() {
      var cached, segments,
        _this = this;
      cached = this.lineSegmentsCached;
      if (cached !== null) {
        return cached;
      } else {
        segments = [];
        this.points.all().map(function(curr, ind) {
          return segments.push(lab.conversions.pathSegment(curr, curr.succ));
        });
        return this.lineSegmentsCached = segments;
      }
    };

    Path.prototype.lineSegmentsCached = null;

    Path.prototype.scale = function(x, y, origin) {
      var angle, _ref3,
        _this = this;
      if (origin == null) {
        origin = this.center();
      }
      this.scaleCachedObjects(x, y, origin);
      angle = this.metadata.angle;
      if (angle !== 0) {
        this.rotate(360 - angle, origin);
      }
      this.points.map(function(a) {
        return a.scale(x, y, origin);
      });
      if (angle !== 0) {
        this.rotate(angle, origin);
      }
      this.commit();
      return (_ref3 = this.virgin) != null ? _ref3.scale(x, y, origin) : void 0;
    };

    Path.prototype.nudge = function(x, y) {
      var _ref3;
      this.points.map(function(p) {
        return p.nudge(x, y, false);
      });
      this.nudgeCachedObjects(x, y);
      this.commit();
      return (_ref3 = this.virgin) != null ? _ref3.nudge(x, y) : void 0;
    };

    Path.prototype.rotate = function(a, origin) {
      if (origin == null) {
        origin = this.center();
      }
      this.metadata.angle += a;
      this.metadata.angle %= 360;
      this.clearCachedObjects();
      this.points.map(function(p) {
        return p.rotate(a, origin);
      });
      this.commit();
      return this.woohoo();
    };

    Path.prototype.fitToBounds = function(bounds) {
      var mb, myHeight, myWidth, sx, sy;
      this.clearCachedObjects();
      mb = this.bounds();
      myWidth = mb.width;
      myHeight = mb.height;
      sx = bounds.width / mb.width;
      sy = bounds.height / mb.height;
      if ((isNaN(sx)) || (sx === Infinity) || (sx === -Infinity) || (sx === 0)) {
        sx = 1;
      }
      if ((isNaN(sy)) || (sy === Infinity) || (sy === -Infinity) || (sy === 0)) {
        sy = 1;
      }
      sx = Math.max(1e-5, sx);
      sy = Math.max(1e-5, sy);
      this.scale(sx, sy, new Posn(mb.x, mb.y));
      this.nudge(bounds.x - mb.x, mb.y - bounds.y);
      if (this.points.toString().indexOf("NaN") > -1) {
        debugger;
      }
    };

    Path.prototype.overlapsRect = function(rect) {
      var point, _i, _len, _ref3;
      if (this.bounds().overlapsBounds(rect.bounds())) {
        _ref3 = this.points.all();
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          point = _ref3[_i];
          if (point.insideOf(rect)) {
            return true;
          }
        }
        return this.lineSegmentsIntersect(rect);
      } else {
        return false;
      }
    };

    Path.prototype.drawToCanvas = function(context) {
      var point, _i, _len, _ref3;
      context = this.setupToCanvas(context);
      _ref3 = this.points.all();
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        point = _ref3[_i];
        switch (point.constructor) {
          case MoveTo:
            context.moveTo(point.x, point.y);
            break;
          case LineTo:
          case HorizTo:
          case VertiTo:
            context.lineTo(point.x, point.y);
            break;
          case CurveTo:
          case SmoothTo:
            context.bezierCurveTo(point.x2, point.y2, point.x3, point.y3, point.x, point.y);
        }
      }
      return this.finishToCanvas(context);
    };

    return Path;

  })(Monsvg);

  /*
  */


  Text = (function(_super) {
    __extends(Text, _super);

    Text.prototype.type = 'text';

    function Text(data, content) {
      this.data = data;
      this.content = content != null ? content : "";
      this.data = $.extend({
        x: 0,
        y: 0,
        'font-size': ui.utilities.typography.sizeControl.read(),
        'font-family': ui.utilities.typography.faceControl.selected.val
      }, this.data);
      this.data.x = float(this.data.x);
      this.data.y = float(this.data.y);
      Text.__super__.constructor.call(this, this.data);
      this.transformations = new Transformations(this, [new RotateTransformation(0), new ScaleTransformation(1, 1), new TranslateTransformation(0, 0)]);
      this.origin = new Posn(this.data.x, this.data.y);
      this.textEditable = new TextEditable(this);
      this;
    }

    Text.prototype.caching = false;

    Text.prototype.setContent = function(content) {
      this.content = content;
      return this.commit();
    };

    Text.prototype.setSize = function(size) {
      return this.data['font-size'] = size;
    };

    Text.prototype.setFace = function(face) {
      return this.data['font-family'] = face;
    };

    Text.prototype.commit = function() {
      this.data.x = this.origin.x;
      this.data.y = this.origin.y;
      this.rep.textContent = this.content;
      this.transformations.commit();
      return Text.__super__.commit.apply(this, arguments);
    };

    Text.prototype.editableMode = function() {
      this.textEditable.show();
      this.hide();
      ui.textEditing = this;
      return ui.selection.elements.deselectAll();
    };

    Text.prototype.displayMode = function() {
      this.textEditable.hide();
      this.show();
      ui.textEditing = void 0;
      return this.adjustForScale();
    };

    Text.prototype.show = function() {
      return this.rep.style.display = "block";
    };

    Text.prototype.hide = function() {
      return this.rep.style.display = "none";
    };

    Text.prototype.originRotated = function() {
      return this.origin.clone().rotate(this.metadata.angle, this.center());
    };

    Text.prototype.simulateInSandbox = function() {
      return $("#text-sandbox").text(this.content).css({
        'font-size': this.data['font-size'],
        'font-family': this.data['font-family']
      });
    };

    Text.prototype.selectAll = function() {
      this.editableMode();
      this.textEditable.focus();
      document.execCommand('selectAll', false, null);
    };

    Text.prototype["delete"] = function() {
      Text.__super__["delete"].apply(this, arguments);
      return this.textEditable.hide();
    };

    Text.prototype.toSVG = function() {
      var self;
      self = Text.__super__.toSVG.apply(this, arguments);
      self.textContent = this.content;
      return self;
    };

    Text.prototype.normalizedOrigin = function() {
      return this.origin.clone().rotate(-this.metadata.angle, this.center());
    };

    Text.prototype.nudge = function(x, y) {
      this.origin.nudge(x, y);
      this.adjustForScale();
      return this.commit();
    };

    Text.prototype.rotate = function(a, origin, adjust) {
      var nc, oc;
      if (origin == null) {
        origin = this.center();
      }
      if (adjust == null) {
        adjust = true;
      }
      this.metadata.angle += a;
      this.metadata.angle %= 360;
      oc = this.center();
      nc = this.center().rotate(a, origin);
      this.origin.nudge(nc.x - oc.x, oc.y - nc.y);
      this.transformations.get('rotate').rotate(a);
      if (adjust) {
        this.adjustForScale();
      }
      return this.commit();
    };

    Text.prototype.scale = function(x, y, origin) {
      var angle;
      angle = this.metadata.angle;
      if (angle !== 0) {
        this.rotate(360 - angle, origin);
      }
      this.origin.scale(x, y, origin);
      this.transformations.get('scale').scale(x, y);
      this.adjustForScale();
      if (angle !== 0) {
        this.rotate(angle, origin);
      }
      return this.commit();
    };

    Text.prototype.adjustForScale = function() {
      var a, scale, translate;
      scale = this.transformations.get('scale');
      translate = this.transformations.get('translate');
      a = this.metadata.angle;
      this.rotate(-a, this.center(), false);
      translate.y = ((scale.y - 1) / scale.y) * -this.origin.y;
      translate.x = ((scale.x - 1) / scale.x) * -this.origin.x;
      this.rotate(a, this.center(), false);
      return this.commit();
    };

    Text.prototype.hover = function() {
      if (ui.selection.elements.all.has(this)) {

      }
      /*
      $("#text-underline").show().css
        left: @origin.x * ui.canvas.zoom
        top:  @origin.y * ui.canvas.zoom
        width: "#{@width() * ui.canvas.zoom}px"
      */

    };

    Text.prototype.unhover = function() {
      return $("#text-underline").hide();
    };

    Text.prototype.drawToCanvas = function() {};

    Text.prototype.clone = function() {
      var cloned;
      cloned = Text.__super__.clone.apply(this, arguments);
      cloned.setContent(this.content);
      return cloned;
    };

    Text.prototype.width = function() {
      this.simulateInSandbox();
      return $("#text-sandbox")[0].clientWidth * this.transformations.get('scale').x;
    };

    Text.prototype.height = function() {
      return this.data['font-size'] * this.transformations.get('scale').y;
    };

    Text.prototype.xRange = function() {
      return new Range(this.origin.x, this.origin.x + this.width());
    };

    Text.prototype.yRange = function() {
      return new Range(this.origin.y - this.height(), this.origin.y);
    };

    Text.prototype.overlapsRect = function(rect) {
      return this.bounds().toRect().overlaps(rect);
    };

    Text.prototype.setupToCavnas = function(context) {
      var orr, scale;
      scale = this.transformations.get('scale');
      orr = this.originRotated();
      context.translate(orr.x, orr.y);
      context.rotate(this.metadata.angle * (Math.PI / 180));
      context.scale(scale.x, scale.y);
      context.font = "" + this.data['font-size'] + "px " + this.data['font-family'];
      return context;
    };

    Text.prototype.drawToCanvas = function(context) {
      var scale;
      scale = this.transformations.get('scale');
      context = this.setupToCavnas(context);
      context.fillText(this.content.strip(), 0, 0);
      return context = this.finishToCanvas(context);
    };

    Text.prototype.finishToCanvas = function(context) {
      var orr, scale;
      scale = this.transformations.get('scale');
      orr = this.originRotated();
      context.scale(1 / scale.x, 1 / scale.y);
      context.rotate(-this.metadata.angle * (Math.PI / 180));
      context.translate(-orr.x, -orr.y);
      return context;
    };

    return Text;

  })(Monsvg);

  /*
  
    TextEditable
  
    A content-editable <p> that lives in the #typography div
    Used to edit the contents of a Text object, each of which
    are tied to one of these.
  */


  TextEditable = (function() {
    function TextEditable(owner) {
      this.owner = owner;
    }

    TextEditable.prototype.refresh = function() {
      var left, myOffset, ownerOffset, resetToBlank, top, tr;
      this.$rep.text(this.owner.content);
      if (this.owner.data['font-size'] != null) {
        this.$rep.css({
          'font-size': float(this.owner.data['font-size']) * ui.canvas.zoom + 'px'
        });
      }
      if (this.owner.data['font-family'] != null) {
        this.$rep.css({
          'font-family': this.owner.data['font-family']
        });
      }
      tr = this.owner.transformations.get('translate');
      if (this.owner.rep.textContent === '') {
        resetToBlank = true;
        this.owner.rep.textContent = '[FILLER]';
        this.$rep.text('[FILLER]');
      }
      ownerOffset = this.owner.$rep.offset();
      left = ownerOffset.left - ui.canvas.normal.x;
      top = ownerOffset.top - ui.canvas.normal.y;
      this.$rep.css({
        left: left.px(),
        top: top.px(),
        color: this.owner.data.fill
      });
      /*
      @rep.style.textShadow = @owner.data.strokeWidth.px()
      @rep.style.webkitTextStrokeWidth = @owner.data.strokeWidth.px()
      */

      this.$rep.css;
      this.owner.transformations.applyAsCSS(this.rep);
      myOffset = this.$rep.offset();
      if (resetToBlank) {
        this.$rep.text('');
        this.owner.rep.textContent = '';
      }
      return this.$rep.css({
        left: (left + ownerOffset.left - myOffset.left).px(),
        top: (top + ownerOffset.top - myOffset.top).px()
      });
    };

    TextEditable.prototype.show = function() {
      var _this = this;
      this.$rep = $("<div class=\"text\" contenteditable=\"true\"\n   quarantine spellcheck=\"false\">" + this.owner.content + "</div>");
      this.rep = this.$rep[0];
      $('#typography').append(this.$rep);
      this.$rep.one('blur', function() {
        _this.commit();
        return _this.owner.displayMode();
      });
      this.rep.style.display = "block";
      return this.refresh();
    };

    TextEditable.prototype.hide = function() {
      if (this.rep == null) {
        return;
      }
      this.rep.remove();
      return this.rep = void 0;
    };

    TextEditable.prototype.focus = function() {
      return this.$rep.focus();
    };

    TextEditable.prototype.commit = function() {
      var newOr, oldOr;
      oldOr = this.owner.originRotated();
      this.owner.setContent(this.$rep.text().replace(/$\s+/g, ''));
      newOr = this.owner.originRotated();
      return this.owner.nudge(oldOr.x - newOr.x, oldOr.y - newOr.y);
    };

    return TextEditable;

  })();

  /*
  */


  Tspan = (function(_super) {
    __extends(Tspan, _super);

    Tspan.prototype.type = 'tspan';

    function Tspan(data) {
      this.data = data;
    }

    return Tspan;

  })(Monsvg);

  /*
  
    Pathfinder
  
    Union, subtract, intersect.
  */


  DEBUGGING = true;

  pathfinder = {
    merge: function(elems) {
      var elemClones, finalResult, first, merged, second, _ref3;
      this._reset();
      print('---------------');
      elemClones = elems.map(function(elem) {
        return elem.clone();
      });
      while (elemClones.length > 1) {
        _ref3 = [elemClones[0], elemClones[1]], first = _ref3[0], second = _ref3[1];
        merged = this._mergePair(first, second);
        elemClones = [merged].concat(elemClones.slice(2));
      }
      finalResult = elemClones[0];
      finalResult.appendTo('#main');
      finalResult.eyedropper(elems[0]);
      return ui.selection.elements.select(finalResult);
    },
    _segments: [],
    _segmentAccumulation: [],
    _intersections: [],
    _keep: function(point) {
      this._segmentAccumulation.push(point);
      if (DEBUGGING) {
        ui.annotations.drawDot(point, ui.colors.black.hex, 4);
      }
      return point.flag('kept');
    },
    _commitCurrentSegment: function() {
      if (this._segmentAccumulation.length === 0) {
        return;
      }
      this._segments.push(new PointsSegment(this._segmentAccumulation).ensureMoveTo());
      return this._segmentAccumulation = [];
    },
    _getIntersection: function(point) {
      var fil;
      fil = this._intersections.filter(function(int) {
        return int.intersection.has(function(p) {
          return p.equal(point);
        });
      });
      if (fil.length > 0) {
        return fil[0];
      }
    },
    _packageSegmentsIntoPathElement: function() {
      var pathElement, pointsList;
      pointsList = new PointsList([], [], this._segments);
      pathElement = new Path({
        d: pointsList.toString(),
        fill: new Color(0, 0, 0, 0.4).toRGBString(),
        stroke: ui.colors.black.hex
      });
      return pathElement;
    },
    _reset: function() {
      return this._segments = this._segmentAccumulation = this._intersections = [];
    },
    _splitAtIntersections: function(elem, intersections) {
      var inter, ls, lsSplit, newListOfPoints, originalPoint, posns, workingPoints, _i, _len, _ref3;
      if (intersections.length === 0) {
        return elem;
      }
      workingPoints = elem.points.all();
      _ref3 = elem.lineSegments();
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        ls = _ref3[_i];
        inter = intersections.filter(function(int) {
          return (int.aline.equal(ls)) || (int.bline.equal(ls));
        });
        if (inter.length > 0) {
          originalPoint = ls.source;
          if (originalPoint.succ instanceof SmoothTo) {
            originalPoint.succ.replaceWithCurveTo();
          }
          posns = inter.reduce(function(x, y) {
            return x.concat(y.intersection);
          }, []);
          posns = posns.filter(function(p) {
            var valid;
            valid = workingPoints.filter(function(x) {
              return x.within(0.1, p);
            }).length === 0;
            if (valid) {
              workingPoints.push(p);
            }
            return valid;
          });
          lsSplit = ls.splitAt(posns);
          newListOfPoints = lsSplit.map(function(lx) {
            return lx.source;
          });
          newListOfPoints.slice(0, newListOfPoints.length - 1).forEach(function(p) {
            return p.flag('desired');
          });
          elem.points.replace(originalPoint, newListOfPoints);
        }
      }
      return elem;
    },
    _desiredPointsRemaining: function(points) {
      return points.filter(function(p) {
        return (p.flagged('desired')) && (!(p.flagged('kept')));
      });
    },
    _findAndSplitIntersections: function(a, b) {
      this._intersections = lab.analysis.intersections(a, b);
      a = this._splitAtIntersections(a, this._intersections);
      b = this._splitAtIntersections(b, this._intersections);
      return [a, b];
    },
    _removeOverlappingAdjecentPoints: function(elem) {
      return elem.points.forEach(function(p) {
        if (p.within(1e-5, p.succ)) {
          return elem.points.remove(p);
        }
      });
    },
    _flagDesiredPoints: function(a, b) {
      a.points.all().forEach(function(point) {
        if (!point.insideOf(b)) {
          return point.flag('desired');
        }
      });
      b.points.all().forEach(function(point) {
        if (!point.insideOf(a)) {
          return point.flag('desired');
        }
      });
      return [a, b];
    },
    _mergePair: function(first, second) {
      var pointsAlternate, pointsWalking, result, _ref3, _ref4;
      this._intersections = lab.analysis.intersections(first, second);
      _ref3 = this._findAndSplitIntersections(first, second), first = _ref3[0], second = _ref3[1];
      _ref4 = this._flagDesiredPoints(first, second), first = _ref4[0], second = _ref4[1];
      pointsWalking = first.points.withoutMoveTos();
      pointsAlternate = second.points.withoutMoveTos();
      print(pointsWalking.all().length);
      print(pointsAlternate.all().length);
      this._walk(pointsWalking, pointsAlternate);
      result = this._packageSegmentsIntoPathElement();
      this._reset();
      return result;
    },
    _walk: function(pointsWalking, pointsAlternate) {
      var current, desiredPoint, desiredPointsRemaining, desiredSegment, intersection, optionA, optionB, otherSamePoint, point, points, pointsRemainingAlternate, pointsRemainingWalking, precTooClose, segment, succTooClose, _i, _j, _len, _len1, _ref3;
      current = pointsWalking.owner;
      _ref3 = pointsWalking.segments;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        segment = _ref3[_i];
        points = segment.points;
        if (points[0].flagged('kept')) {
          this._commitCurrentSegment();
          pointsRemainingWalking = this._desiredPointsRemaining(pointsWalking);
          pointsRemainingAlternate = this._desiredPointsRemaining(pointsAlternate);
          if ((pointsRemainingWalking.length === 0) || (pointsRemainingAlternate.length === 0)) {
            return;
          }
          if (pointsRemainingWalking.length > 0) {
            pointsWalking.movePointToFront(pointsRemainingWalking[0]);
            return this._walk(pointsWalking, pointsAlternate);
          } else if (pointsRemainingAlternate.length > 0) {
            pointsAlternate.movePointToFront(pointsRemainingAlternate[0]);
            return this._walk(pointsAlternate, pointsWalking);
          }
        }
        for (_j = 0, _len1 = points.length; _j < _len1; _j++) {
          point = points[_j];
          if (DEBUGGING) {
            ui.annotations.drawDot(point, ui.colors.green.hex, 8);
          }
          intersection = this._getIntersection(point);
          if (intersection) {
            otherSamePoint = pointsAlternate.filter(function(p) {
              return p.equal(point);
            })[0];
            otherSamePoint.flag('kept');
            optionA = lab.conversions.pathSegment(otherSamePoint, otherSamePoint.succ);
            optionB = lab.conversions.pathSegment(otherSamePoint.prec, otherSamePoint);
            if (otherSamePoint.within(1e-2, otherSamePoint.succ)) {
              succTooClose = true;
              print("succ too close");
            }
            if (otherSamePoint.within(1e-2, otherSamePoint.prec)) {
              precTooClose = true;
              print("prec too close");
            }
            if (!(optionA.midPoint().insideOf(current))) {
              desiredPoint = otherSamePoint.succ;
            } else if (!(optionB.midPoint().insideOf(current))) {
              print("REVERSING");
              pointsAlternate = pointsAlternate.reverse();
              otherSamePoint = pointsAlternate.filter(function(p) {
                return p.equal(point);
              })[0];
              desiredPoint = otherSamePoint.succ;
            } else {
              print("PANIC");
            }
            desiredSegment = desiredPoint.segment;
            pointsAlternate.moveSegmentToFront(desiredSegment);
            desiredSegment.movePointToFront(desiredPoint);
            this._keep(point);
            return this._walk(pointsAlternate, pointsWalking);
          } else {
            if (point.flagged('kept')) {
              print('swedep');
              break;
            } else {
              this._keep(point);
            }
          }
        }
        this._commitCurrentSegment();
        desiredPointsRemaining = this._desiredPointsRemaining(segment.points);
        if (desiredPointsRemaining.length === 0) {
          if (pointsWalking.segments.without(segment).length === 0) {
            this._walk(pointsAlternate, pointsWalking);
          } else {
            pointsWalking.segments = pointsWalking.segments.cannibalize();
            this._walk(pointsWalking, pointsAlternate);
          }
        } else {
          segment.movePointToFront(desiredPointsRemaining[0]);
          this._walk(pointsWalking, pointsAlternate);
        }
      }
      this._commitCurrentSegment();
      return this._walk(pointsAlternate, pointsWalking);
    }
  };

  Test = (function() {
    function Test(expect, val, toEqual) {
      var begin, end;
      this.expect = expect;
      this.val = val;
      this.toEqual = toEqual;
      begin = new Date();
      this.result = this.val();
      end = new Date();
      this.runtime = end.valueOf() - begin.valueOf();
      if (this.result.toString() === this.toEqual.toString()) {
        this.printSuccess();
      } else {
        this.printFailure();
      }
    }

    Test.prototype.print = function(result, success) {
      return q("body").innerHTML += "<div class=\"" + (success ? "success" : "failed") + "\">" + result + "</div>";
    };

    Test.prototype.printSuccess = function() {
      return this.print("" + this.expect + " <b>success</b> in " + this.runtime + "ms", true);
    };

    Test.prototype.printFailure = function() {
      return this.print("" + this.expect + " <b>failed</b> in " + this.runtime + "ms\n  Expected: " + this.toEqual + "\n  Got:      " + this.result, false);
    };

    return Test;

  })();

  p1 = new Posn(10, 20);

  p2 = new Posn(50, 50);

  p3 = new Posn(56.375, 920.505);

  p4 = new Posn(78.2, 2.4);

  poly1 = new Polynomial([-8556.40625, 9786.5625, 1565.765625, -1798.09375]);

  poly2 = new Polynomial([-8556.40625, 9786.5625, 1565.765625, -1798.09375]);

  poly3 = new Polynomial([-2521.40325, 2015.7625, -2298.04175]);

  hugepoly = new Polynomial([819552855133368, -4059695028789612, 9135238247204166, -11299205179679670, 7817505757508070, -2752582173072824, -184979604186062.2, 759898652221607.1, -250714946036920.75, 6934793103614.088]);

  blob1 = new Path({
    d: "M207.337,68.753c-39.326,19.102-65.168,95.506-47.191,106.742\ns78.652,53.933,104.495,28.09s47.191-133.708,30.337-134.832\nS207.337,68.753,207.337,68.753z"
  });

  blob2 = new Path({
    d: "M346.664,158.641c-50.562-8.989-113.483-30.336-123.596-7.865\ns-27.439,21.987-9.787,54.252s54.731,79.456,69.338,65.973S346.664,158.641,346.664,158.641z"
  });

  ln1 = new LineSegment(new Posn(0, 0), new Posn(100, 100));

  ln110 = new LineSegment(new Posn(0, 0), new Posn(100, 110));

  ln2 = new LineSegment(new Posn(0, 100), new Posn(100, 0));

  ln3 = new LineSegment(new Posn(47.354, 107.08), new Posn(133.065, 161.985));

  ln4 = new LineSegment(new Posn(29.541, 146.268), new Posn(150.459, 120.072));

  ln5 = new LineSegment(new Posn(315, 309), new Posn(315, 228));

  ln6 = new LineSegment(new Posn(350, 170), new Posn(400, 250));

  ln7 = new LineSegment(new Posn(145.5, 58), new Posn(193.375, 23.125));

  ln8 = new LineSegment(new Posn(148.5, 19.625), new Posn(198.375, 58.875));

  bz = new CubicBezier(new Posn(0, 50), new Posn(200, 150), new Posn(100, 50), new Posn(50, 50));

  bz1 = new CubicBezier(new Posn(400, 200), new Posn(300, 185), new Posn(265, 230), new Posn(285, 250));

  bz2 = new CubicBezier(new Posn(154, 14.25), new Posn(138.25, 36.625), new Posn(230.625, 48.375), new Posn(165.875, 64));

  bz3 = new CubicBezier(new Posn(0, 0), new Posn(66.368, 66.368), new Posn(113.769, 70.044), new Posn(183.813, 0));

  bz4 = new CubicBezier(new Posn(0, 76.746), new Posn(70.043, 6.702), new Posn(117.444, 10.378), new Posn(183.813, 76.746));

  bz5 = new CubicBezier(new Posn(20, 91.738), new Posn(59.5, 168.738), new Posn(107, -100.762), new Posn(107, 91.738));

  bz6 = new CubicBezier(new Posn(46.148, 91.882), new Posn(78.648, 174.382), new Posn(69.648, -66.618), new Posn(88.148, 49.882));

  bz7 = new CubicBezier(new Posn(583.4471131233216, 244), new Posn(507.81821773433853, 338), new Posn(670.0103920088109, 183), new Posn(618.9836028774718, 267));

  bz8 = new CubicBezier(new Posn(577, 246), new Posn(754, 248), new Posn(446, 267), new Posn(594, 267));

  bz9 = new CubicBezier(new Posn(537, 89), new Posn(479, 126), new Posn(477, 206), new Posn(557, 166));

  bz10 = new CubicBezier(new Posn(517, 168), new Posn(536, 211), new Posn(472, 241), new Posn(463, 183));

  ell1 = new Ellipse({
    cx: 100,
    cy: 100,
    rx: 50,
    ry: 60
  });

  pth1 = new Path({
    stroke: '#F179AF',
    fill: 'none',
    d: "M0,0C80-80,200-85,300,0S165,125 165,130L0,0"
  });

  new Test('Posn reflection', (function() {
    return p1.reflect(p2);
  }), new Posn(90, 80));

  new Test('Posn reflection', (function() {
    return p2.reflect(p1);
  }), new Posn(-30, -10));

  new Test('Posn reflection', (function() {
    return p1.reflect(p1);
  }), p1);

  new Test('Posn linear interpolation', (function() {
    return p2.lerp(p3, 0.5);
  }), new Posn(53.1875, 485.2525));

  new Test('Posn linear interpolation (lerp)', (function() {
    return p1.lerp(p2, 0.8);
  }), new Posn(42, 44));

  new Test('Posn add to Posn', (function() {
    return p1.add(p2);
  }), new Posn(60, 70));

  new Test('Posn add to Posn', (function() {
    return p2.add(p1);
  }), new Posn(60, 70));

  new Test('Posn add to Posn', (function() {
    return p2.add(p3);
  }), new Posn(106.375, 970.505));

  new Test('Push Posn into end of PointsList', (function() {
    return new PointsList([p1, p2, p4]).push(p3);
  }), new PointsList([p1, p2, p4, p3]));

  new Test('Validate links in PointsList after push', (function() {
    return new PointsList([p1, p2, p4]).push(p3).firstSegment.validateLinks();
  }), true);

  new Test('PointsList.toString()', (function() {
    return new PointsList([new MoveTo(10, 10), new LineTo(45, 60), new CurveTo(100, 120, 300, 350, 90, 80)]).toString();
  }), "M10,10 L45,60 C100,120 300,350 90,80");

  new Test('PointsList.relative().toString()', (function() {
    return new PointsList([new MoveTo(10, 10), new LineTo(45, 60)]).relative().toString();
  }), "M10,10 l35,50");

  new Test('PointsList.relative().absolute().toString()', (function() {
    return new PointsList([new MoveTo(10, 10), new LineTo(45, 60)]).relative().absolute().toString();
  }), "M10,10 L45,60");

  new Test('PointsList.relative().toString()', (function() {
    return new PointsList([new MoveTo(10, 10), new LineTo(45, 60), new CurveTo(100, 120, 300, 350, 90, 80)]).relative().toString();
  }), "M10,10 l35,50 c55,60 255,290 45,20");

  new Test('PointsList.relative().absolute() consistency', (function() {
    return new PointsList([new MoveTo(10, 10), new LineTo(45, 60), new CurveTo(100, 120, 300, 350, 90, 80)]).relative().absolute().toString();
  }), "M10,10 L45,60 C100,120 300,350 90,80");

  new Test('PointsList.relative().absolute().relative() consistency', (function() {
    return new PointsList([new MoveTo(10, 10), new LineTo(45, 60), new CurveTo(100, 120, 300, 350, 90, 80)]).relative().absolute().relative().toString();
  }), "M10,10 l35,50 c55,60 255,290 45,20");

  pointsSegment = new PointsSegment([new MoveTo(10, 10), new LineTo(45, 60), new CurveTo(100, 120, 300, 350, 90, 80)]);

  new Test('LineTo.toLineSegment', (function() {
    return pointsSegment.moveMoveTo(pointsSegment.points[2]);
  }), '');

  new Test('new Path with mix of absolute and relative turns them absolute', (function() {
    return new Path({
      d: 'M10,10l30,40C50,60,70,80,90,100L40,40l50,50'
    }).points;
  }), 'M10,10 L40,50 C50,60 70,80 90,100 L40,40 L90,90');

  new Test('Cubic polynomial roots', (function() {
    return poly1.roots();
  }), [1.143019385425934, -0.4284039167874206, 0.42915473278220573]);

  new Test('Cubic Polynomial eval(3)', (function() {
    return poly2["eval"](3);
  }), -140044.703125);

  new Test('Cubic Polynomial roots()', (function() {
    return poly2.roots();
  }), [1.143019385425934, -0.4284039167874206, 0.42915473278220573]);

  new Test('Cubic Polynomial derivative()', (function() {
    return poly2.derivative().coefs;
  }), [1565.765625, 19573.125, -25669.21875]);

  new Test('Cubic Polynomial add()', (function() {
    return poly2.add(poly3).coefs;
  }), [-4096.1355, 3581.528125, 7265.159250000001, -8556.40625]);

  new Test('Cubic Polynomial bisection()', (function() {
    return poly2.bisection(0, 1);
  }), 0.4291543960571289);

  new Test('Cubic Polynomial rootsInterval()', (function() {
    return poly2.rootsInterval(0, 1);
  }), [0.42915499960917775]);

  new Test('Huge 10-coefficient Polynomial rootsInterval()', (function() {
    return hugepoly.rootsInterval(0, 1);
  }), [0.030439317609131572, 0.4865324847206747, 0.9484604318106424]);

  new Test('Cubic Bezier intersects LineSegment', (function() {
    return bz.intersectionWithLineSegment(ln1);
  }), [new Posn(89.20468634936002, 89.20468634935999), new Posn(50.00000000000004, 50)]);

  new Test('Cubic Bezier intersects LineSegment', (function() {
    return bz2.intersectionWithLineSegment(ln7);
  }), [new Posn(172.4987019088338, 38.33253829617591)]);

  new Test('Cubic Bezier xRange', (function() {
    return bz2.xRange();
  }), new Range(152.169, 189.1624));

  new Test('Cubic Bezier yRange', (function() {
    return bz2.yRange();
  }), new Range(14.25, 64));

  new Test('Cubic Bezier intersection with Cubic Bezier', (function() {
    return bz3.intersection(bz4);
  }), [new Posn(47.90415473177786, 38.43978101182949), new Posn(135.908264922779, 38.30620344719945)]);

  new Test('Cubic Bezier intersection with Cubic Bezier', (function() {
    return bz5.intersection(bz6);
  }), [new Posn(49.00242378510562, 98.5357189974139), new Posn(72.06070160020182, 60.998066741193696), new Posn(85.49725443971622, 34.62459876819878)]);

  new Test('Cubic Bezier intersection with Cubic Bezier', (function() {
    return bz4.intersection(bz6);
  }), [new Posn(76.26664017448732, 27.28211939958595), new Posn(83.63548811847966, 26.07062056075148)]);

  new Test('Cubic Bezier intersection with Cubic Bezier', (function() {
    return bz7.intersection(bz8);
  }), [new Posn(581.7959971383461, 246.0599451520868), new Posn(611.5468559995447, 246.8269484357895), new Posn(628.4619186189253, 248.10341235722106), new Posn(626.8506058391803, 252.40738666580168), new Posn(594.6339715885225, 257.48879390700273), new Posn(570.4713158190336, 260.85017444139413), new Posn(566.5128682640187, 266.6452081770431), new Posn(580.4224295094082, 266.93524733161775)]);

  new Test('Cubic Bezier intersection with Cubic Bezier', (function() {
    return bz9.intersection(bz10);
  }), [new Posn(519.8386947286634, 176.92274339432637)]);

  new Test('Cubic Bezier findPercentageOfPoint', (function() {
    return bz4.findPercentageOfPoint(new Posn(76.2666, 27.2822));
  }), 0.4012451171875);

  new Test('Cubic Bezier splitAt(0.5)', (function() {
    return bz4.splitAt(0.5);
  }), [new CubicBezier(new Posn(0, 76.746), new Posn(35.0215, 41.724), new Posn(64.38250000000001, 25.131999999999998), new Posn(93.28425000000001, 25.591499999999996)), new CubicBezier(new Posn(93.28425000000001, 25.591499999999996), new Posn(122.186, 26.051), new Posn(150.6285, 43.562), new Posn(183.813, 76.746))]);

  new Test('Cubic Bezier split at array of 8 points', (function() {
    return bz7.splitAt([new Posn(581.796, 246.06), new Posn(611.5469, 246.8269), new Posn(628.462, 248.1034), new Posn(626.8506, 252.4073), new Posn(594.6339, 257.4888), new Posn(570.4713, 260.8502), new Posn(566.5128, 266.6452), new Posn(580.4224, 266.9353)]);
  }), [new CubicBezier(new Posn(583.4471131233216, 244), new Posn(583.4471131233216, 244), new Posn(583.4471131233216, 244), new Posn(580.4224, 266.9353)), new CubicBezier(new Posn(580.4224, 266.9353), new Posn(580.4224, 266.9353), new Posn(580.4224, 266.9353), new Posn(581.796, 246.06)), new CubicBezier(new Posn(581.796, 246.06), new Posn(577.1272361534001, 251.86236572265625), new Posn(573.3991175174485, 256.6811900511384), new Posn(570.4713, 260.8502)), new CubicBezier(new Posn(570.4713, 260.8502), new Posn(568.9269994920714, 262.951033418894), new Posn(567.6176030414922, 264.80763180728394), new Posn(566.5128, 266.6452)), new CubicBezier(new Posn(566.5128, 266.6452), new Posn(552.8234755300266, 287.00990433663344), new Posn(573.4200716299288, 271.8794306807597), new Posn(594.6339, 257.4888)), new CubicBezier(new Posn(594.6339, 257.4888), new Posn(600.388768892232, 253.66825105981948), new Posn(606.1884500827612, 249.90638989498956), new Posn(611.5469, 246.8269)), new CubicBezier(new Posn(611.5469, 246.8269), new Posn(623.1194403147066, 240.1897686797748), new Posn(631.4839224387921, 237.6295916160095), new Posn(628.462, 248.1034)), new CubicBezier(new Posn(628.462, 248.1034), new Posn(628.1275684678864, 249.26742641511547), new Posn(627.626792524753, 250.63164231257952), new Posn(626.8506, 252.4073)), new CubicBezier(new Posn(626.8506, 252.4073), new Posn(625.3425898571114, 255.92451126762697), new Posn(622.7412270743075, 260.8142211589726), new Posn(618.9836028774718, 267))]);

  new Test('Cubic Bezier splitAt(0.5)[0].splitAt(0.5)', (function() {
    return bz4.splitAt(0.5)[0].splitAt(0.5);
  }), [new CubicBezier(new Posn(0, 76.746), new Posn(17.51075, 59.235), new Posn(33.606375, 46.3315), new Posn(48.937031250000004, 37.863187499999995)), new CubicBezier(new Posn(48.937031250000004, 37.863187499999995), new Posn(64.26768750000001, 29.394875), new Posn(78.83337500000002, 25.361749999999997), new Posn(93.28425000000001, 25.591499999999996))]);

  new Test('LineSegment intersects LineSegment', (function() {
    return ln1.intersection(ln2);
  }), [new Posn(50, 50)]);

  new Test('LineSegment intersects LineSegment', (function() {
    return ln3.intersection(ln4);
  }), [new Posn(88.56712407541042, 133.4804220853847)]);

  new Test('Path.lineSegments()', (function() {
    return pth1.lineSegments();
  }), [new CubicBezier(new Posn(0, 0), new Posn(80, -80), new Posn(200, -85), new Posn(300, 0)), new CubicBezier(new Posn(300, 0), new Posn(400, 85), new Posn(165, 125), new Posn(165, 130)), new LineSegment(new Posn(165, 130), new Posn(0, 0)), new LineSegment(new Posn(0, 0), new Posn(0, 0))]);

  new Test('Path.lineSegments().map(bounds)', (function() {
    return pth1.lineSegments().map(function(x) {
      return x.bounds();
    });
  }), [new Bounds(0, -61.875, 300, 61.875), new Bounds(165, 0, 159.77671875, 130), new Bounds(0, 0, 165, 130), new Bounds(0, 0, 0, 0)]);

  new Test('Path.bounds()', (function() {
    return pth1.bounds();
  }), [
    {
      "x": 0,
      "y": -61.875,
      "width": 324.77671875,
      "height": 191.875,
      "x2": 324.77671875,
      "y2": 130,
      "xr": {
        "min": 0,
        "max": 324.77671875
      },
      "yr": {
        "min": -61.875,
        "max": 130
      }
    }
  ]);

  new Test('Ellipse primitive coords', (function() {
    return [ell1.top().x, ell1.top().y, ell1.right().x, ell1.right().y, ell1.bottom().x, ell1.bottom().y, ell1.left().x, ell1.left().y];
  }), [100, 40, 150, 100, 100, 160, 50, 100]);

  print(blob1.points.reverse().toString());

}).call(this);
